
FreeRTOS_Example.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002bfa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000020  00800060  00002bfa  00002c8e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000003b6  00800080  00800080  00002cae  2**0
                  ALLOC
  3 .stab         000046e0  00000000  00000000  00002cb0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002f30  00000000  00000000  00007390  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 6d 0a 	jmp	0x14da	; 0x14da <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea ef       	ldi	r30, 0xFA	; 250
      68:	fb e2       	ldi	r31, 0x2B	; 43
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 38       	cpi	r26, 0x80	; 128
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a0 e8       	ldi	r26, 0x80	; 128
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 33       	cpi	r26, 0x36	; 54
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 64 07 	call	0xec8	; 0xec8 <main>
      8a:	0c 94 fb 15 	jmp	0x2bf6	; 0x2bf6 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <DIO_void_set_port_dir>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <DIO_void_set_port_dir+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	89 83       	std	Y+1, r24	; 0x01
      9e:	6a 83       	std	Y+2, r22	; 0x02
      a0:	89 81       	ldd	r24, Y+1	; 0x01
      a2:	88 2f       	mov	r24, r24
      a4:	90 e0       	ldi	r25, 0x00	; 0
      a6:	88 0f       	add	r24, r24
      a8:	99 1f       	adc	r25, r25
      aa:	fc 01       	movw	r30, r24
      ac:	e3 59       	subi	r30, 0x93	; 147
      ae:	ff 4f       	sbci	r31, 0xFF	; 255
      b0:	01 90       	ld	r0, Z+
      b2:	f0 81       	ld	r31, Z
      b4:	e0 2d       	mov	r30, r0
      b6:	8a 81       	ldd	r24, Y+2	; 0x02
      b8:	80 83       	st	Z, r24
      ba:	0f 90       	pop	r0
      bc:	0f 90       	pop	r0
      be:	cf 91       	pop	r28
      c0:	df 91       	pop	r29
      c2:	08 95       	ret

000000c4 <DIO_void_set_pin_dir>:

	*(DIO_DDRx[copy_u8_portID]) = port_copy_dir;

}

void DIO_void_set_pin_dir(u8 copy_u8_portID, u8 copy_u8_pinID, u8 pin_copy_dir){
      c4:	df 93       	push	r29
      c6:	cf 93       	push	r28
      c8:	00 d0       	rcall	.+0      	; 0xca <DIO_void_set_pin_dir+0x6>
      ca:	0f 92       	push	r0
      cc:	cd b7       	in	r28, 0x3d	; 61
      ce:	de b7       	in	r29, 0x3e	; 62
      d0:	89 83       	std	Y+1, r24	; 0x01
      d2:	6a 83       	std	Y+2, r22	; 0x02
      d4:	4b 83       	std	Y+3, r20	; 0x03
	 *  pin_copy_dir using the predefined macro INPUT //OUTPUT
	 *
	 *
	 */

	assign_Bit(*(DIO_DDRx[copy_u8_portID]),copy_u8_pinID,pin_copy_dir);
      d6:	8b 81       	ldd	r24, Y+3	; 0x03
      d8:	81 30       	cpi	r24, 0x01	; 1
      da:	29 f5       	brne	.+74     	; 0x126 <DIO_void_set_pin_dir+0x62>
      dc:	89 81       	ldd	r24, Y+1	; 0x01
      de:	88 2f       	mov	r24, r24
      e0:	90 e0       	ldi	r25, 0x00	; 0
      e2:	88 0f       	add	r24, r24
      e4:	99 1f       	adc	r25, r25
      e6:	fc 01       	movw	r30, r24
      e8:	e3 59       	subi	r30, 0x93	; 147
      ea:	ff 4f       	sbci	r31, 0xFF	; 255
      ec:	a0 81       	ld	r26, Z
      ee:	b1 81       	ldd	r27, Z+1	; 0x01
      f0:	89 81       	ldd	r24, Y+1	; 0x01
      f2:	88 2f       	mov	r24, r24
      f4:	90 e0       	ldi	r25, 0x00	; 0
      f6:	88 0f       	add	r24, r24
      f8:	99 1f       	adc	r25, r25
      fa:	fc 01       	movw	r30, r24
      fc:	e3 59       	subi	r30, 0x93	; 147
      fe:	ff 4f       	sbci	r31, 0xFF	; 255
     100:	01 90       	ld	r0, Z+
     102:	f0 81       	ld	r31, Z
     104:	e0 2d       	mov	r30, r0
     106:	80 81       	ld	r24, Z
     108:	48 2f       	mov	r20, r24
     10a:	8a 81       	ldd	r24, Y+2	; 0x02
     10c:	28 2f       	mov	r18, r24
     10e:	30 e0       	ldi	r19, 0x00	; 0
     110:	81 e0       	ldi	r24, 0x01	; 1
     112:	90 e0       	ldi	r25, 0x00	; 0
     114:	02 2e       	mov	r0, r18
     116:	02 c0       	rjmp	.+4      	; 0x11c <DIO_void_set_pin_dir+0x58>
     118:	88 0f       	add	r24, r24
     11a:	99 1f       	adc	r25, r25
     11c:	0a 94       	dec	r0
     11e:	e2 f7       	brpl	.-8      	; 0x118 <DIO_void_set_pin_dir+0x54>
     120:	84 2b       	or	r24, r20
     122:	8c 93       	st	X, r24
     124:	25 c0       	rjmp	.+74     	; 0x170 <DIO_void_set_pin_dir+0xac>
     126:	89 81       	ldd	r24, Y+1	; 0x01
     128:	88 2f       	mov	r24, r24
     12a:	90 e0       	ldi	r25, 0x00	; 0
     12c:	88 0f       	add	r24, r24
     12e:	99 1f       	adc	r25, r25
     130:	fc 01       	movw	r30, r24
     132:	e3 59       	subi	r30, 0x93	; 147
     134:	ff 4f       	sbci	r31, 0xFF	; 255
     136:	a0 81       	ld	r26, Z
     138:	b1 81       	ldd	r27, Z+1	; 0x01
     13a:	89 81       	ldd	r24, Y+1	; 0x01
     13c:	88 2f       	mov	r24, r24
     13e:	90 e0       	ldi	r25, 0x00	; 0
     140:	88 0f       	add	r24, r24
     142:	99 1f       	adc	r25, r25
     144:	fc 01       	movw	r30, r24
     146:	e3 59       	subi	r30, 0x93	; 147
     148:	ff 4f       	sbci	r31, 0xFF	; 255
     14a:	01 90       	ld	r0, Z+
     14c:	f0 81       	ld	r31, Z
     14e:	e0 2d       	mov	r30, r0
     150:	80 81       	ld	r24, Z
     152:	48 2f       	mov	r20, r24
     154:	8a 81       	ldd	r24, Y+2	; 0x02
     156:	28 2f       	mov	r18, r24
     158:	30 e0       	ldi	r19, 0x00	; 0
     15a:	81 e0       	ldi	r24, 0x01	; 1
     15c:	90 e0       	ldi	r25, 0x00	; 0
     15e:	02 2e       	mov	r0, r18
     160:	02 c0       	rjmp	.+4      	; 0x166 <DIO_void_set_pin_dir+0xa2>
     162:	88 0f       	add	r24, r24
     164:	99 1f       	adc	r25, r25
     166:	0a 94       	dec	r0
     168:	e2 f7       	brpl	.-8      	; 0x162 <DIO_void_set_pin_dir+0x9e>
     16a:	80 95       	com	r24
     16c:	84 23       	and	r24, r20
     16e:	8c 93       	st	X, r24

}
     170:	0f 90       	pop	r0
     172:	0f 90       	pop	r0
     174:	0f 90       	pop	r0
     176:	cf 91       	pop	r28
     178:	df 91       	pop	r29
     17a:	08 95       	ret

0000017c <DIO_void_port_pullup>:

void DIO_void_port_pullup(u8 copy_u8_portID){
     17c:	df 93       	push	r29
     17e:	cf 93       	push	r28
     180:	0f 92       	push	r0
     182:	cd b7       	in	r28, 0x3d	; 61
     184:	de b7       	in	r29, 0x3e	; 62
     186:	89 83       	std	Y+1, r24	; 0x01
	 *  so that is what the function does
	 *  using the pullup for any button prevents the floating effect
	 *
	 *
	 */
	*(DIO_DDRx[copy_u8_portID]) = INPUT;
     188:	89 81       	ldd	r24, Y+1	; 0x01
     18a:	88 2f       	mov	r24, r24
     18c:	90 e0       	ldi	r25, 0x00	; 0
     18e:	88 0f       	add	r24, r24
     190:	99 1f       	adc	r25, r25
     192:	fc 01       	movw	r30, r24
     194:	e3 59       	subi	r30, 0x93	; 147
     196:	ff 4f       	sbci	r31, 0xFF	; 255
     198:	01 90       	ld	r0, Z+
     19a:	f0 81       	ld	r31, Z
     19c:	e0 2d       	mov	r30, r0
     19e:	10 82       	st	Z, r1
	*(DIO_PORTx[copy_u8_portID]) = PORT_MAX;
     1a0:	89 81       	ldd	r24, Y+1	; 0x01
     1a2:	88 2f       	mov	r24, r24
     1a4:	90 e0       	ldi	r25, 0x00	; 0
     1a6:	88 0f       	add	r24, r24
     1a8:	99 1f       	adc	r25, r25
     1aa:	fc 01       	movw	r30, r24
     1ac:	eb 58       	subi	r30, 0x8B	; 139
     1ae:	ff 4f       	sbci	r31, 0xFF	; 255
     1b0:	01 90       	ld	r0, Z+
     1b2:	f0 81       	ld	r31, Z
     1b4:	e0 2d       	mov	r30, r0
     1b6:	8f ef       	ldi	r24, 0xFF	; 255
     1b8:	80 83       	st	Z, r24
}
     1ba:	0f 90       	pop	r0
     1bc:	cf 91       	pop	r28
     1be:	df 91       	pop	r29
     1c0:	08 95       	ret

000001c2 <DIO_void_pin_pullup>:

void DIO_void_pin_pullup(u8 copy_u8_portID, u8 copy_u8_pinID){
     1c2:	df 93       	push	r29
     1c4:	cf 93       	push	r28
     1c6:	00 d0       	rcall	.+0      	; 0x1c8 <DIO_void_pin_pullup+0x6>
     1c8:	cd b7       	in	r28, 0x3d	; 61
     1ca:	de b7       	in	r29, 0x3e	; 62
     1cc:	89 83       	std	Y+1, r24	; 0x01
     1ce:	6a 83       	std	Y+2, r22	; 0x02
	/*  the function works as the one that set pullup for the whole port
	 *
	 *
	 */

	clear_Bit(*(DIO_DDRx[copy_u8_portID]),copy_u8_pinID);
     1d0:	89 81       	ldd	r24, Y+1	; 0x01
     1d2:	88 2f       	mov	r24, r24
     1d4:	90 e0       	ldi	r25, 0x00	; 0
     1d6:	88 0f       	add	r24, r24
     1d8:	99 1f       	adc	r25, r25
     1da:	fc 01       	movw	r30, r24
     1dc:	e3 59       	subi	r30, 0x93	; 147
     1de:	ff 4f       	sbci	r31, 0xFF	; 255
     1e0:	a0 81       	ld	r26, Z
     1e2:	b1 81       	ldd	r27, Z+1	; 0x01
     1e4:	89 81       	ldd	r24, Y+1	; 0x01
     1e6:	88 2f       	mov	r24, r24
     1e8:	90 e0       	ldi	r25, 0x00	; 0
     1ea:	88 0f       	add	r24, r24
     1ec:	99 1f       	adc	r25, r25
     1ee:	fc 01       	movw	r30, r24
     1f0:	e3 59       	subi	r30, 0x93	; 147
     1f2:	ff 4f       	sbci	r31, 0xFF	; 255
     1f4:	01 90       	ld	r0, Z+
     1f6:	f0 81       	ld	r31, Z
     1f8:	e0 2d       	mov	r30, r0
     1fa:	80 81       	ld	r24, Z
     1fc:	48 2f       	mov	r20, r24
     1fe:	8a 81       	ldd	r24, Y+2	; 0x02
     200:	28 2f       	mov	r18, r24
     202:	30 e0       	ldi	r19, 0x00	; 0
     204:	81 e0       	ldi	r24, 0x01	; 1
     206:	90 e0       	ldi	r25, 0x00	; 0
     208:	02 c0       	rjmp	.+4      	; 0x20e <DIO_void_pin_pullup+0x4c>
     20a:	88 0f       	add	r24, r24
     20c:	99 1f       	adc	r25, r25
     20e:	2a 95       	dec	r18
     210:	e2 f7       	brpl	.-8      	; 0x20a <DIO_void_pin_pullup+0x48>
     212:	80 95       	com	r24
     214:	84 23       	and	r24, r20
     216:	8c 93       	st	X, r24
	set_Bit(*(DIO_PORTx[copy_u8_portID]),copy_u8_pinID);
     218:	89 81       	ldd	r24, Y+1	; 0x01
     21a:	88 2f       	mov	r24, r24
     21c:	90 e0       	ldi	r25, 0x00	; 0
     21e:	88 0f       	add	r24, r24
     220:	99 1f       	adc	r25, r25
     222:	fc 01       	movw	r30, r24
     224:	eb 58       	subi	r30, 0x8B	; 139
     226:	ff 4f       	sbci	r31, 0xFF	; 255
     228:	a0 81       	ld	r26, Z
     22a:	b1 81       	ldd	r27, Z+1	; 0x01
     22c:	89 81       	ldd	r24, Y+1	; 0x01
     22e:	88 2f       	mov	r24, r24
     230:	90 e0       	ldi	r25, 0x00	; 0
     232:	88 0f       	add	r24, r24
     234:	99 1f       	adc	r25, r25
     236:	fc 01       	movw	r30, r24
     238:	eb 58       	subi	r30, 0x8B	; 139
     23a:	ff 4f       	sbci	r31, 0xFF	; 255
     23c:	01 90       	ld	r0, Z+
     23e:	f0 81       	ld	r31, Z
     240:	e0 2d       	mov	r30, r0
     242:	80 81       	ld	r24, Z
     244:	48 2f       	mov	r20, r24
     246:	8a 81       	ldd	r24, Y+2	; 0x02
     248:	28 2f       	mov	r18, r24
     24a:	30 e0       	ldi	r19, 0x00	; 0
     24c:	81 e0       	ldi	r24, 0x01	; 1
     24e:	90 e0       	ldi	r25, 0x00	; 0
     250:	02 2e       	mov	r0, r18
     252:	02 c0       	rjmp	.+4      	; 0x258 <DIO_void_pin_pullup+0x96>
     254:	88 0f       	add	r24, r24
     256:	99 1f       	adc	r25, r25
     258:	0a 94       	dec	r0
     25a:	e2 f7       	brpl	.-8      	; 0x254 <DIO_void_pin_pullup+0x92>
     25c:	84 2b       	or	r24, r20
     25e:	8c 93       	st	X, r24

}
     260:	0f 90       	pop	r0
     262:	0f 90       	pop	r0
     264:	cf 91       	pop	r28
     266:	df 91       	pop	r29
     268:	08 95       	ret

0000026a <DIO_void_set_port>:

void DIO_void_set_port(u8 copy_u8_portID){
     26a:	df 93       	push	r29
     26c:	cf 93       	push	r28
     26e:	0f 92       	push	r0
     270:	cd b7       	in	r28, 0x3d	; 61
     272:	de b7       	in	r29, 0x3e	; 62
     274:	89 83       	std	Y+1, r24	; 0x01
	 *
	 */



	*(DIO_PORTx[copy_u8_portID]) = PORT_MAX;
     276:	89 81       	ldd	r24, Y+1	; 0x01
     278:	88 2f       	mov	r24, r24
     27a:	90 e0       	ldi	r25, 0x00	; 0
     27c:	88 0f       	add	r24, r24
     27e:	99 1f       	adc	r25, r25
     280:	fc 01       	movw	r30, r24
     282:	eb 58       	subi	r30, 0x8B	; 139
     284:	ff 4f       	sbci	r31, 0xFF	; 255
     286:	01 90       	ld	r0, Z+
     288:	f0 81       	ld	r31, Z
     28a:	e0 2d       	mov	r30, r0
     28c:	8f ef       	ldi	r24, 0xFF	; 255
     28e:	80 83       	st	Z, r24

}
     290:	0f 90       	pop	r0
     292:	cf 91       	pop	r28
     294:	df 91       	pop	r29
     296:	08 95       	ret

00000298 <DIO_void_clear_port>:

void DIO_void_clear_port(u8 copy_u8_portID){
     298:	df 93       	push	r29
     29a:	cf 93       	push	r28
     29c:	0f 92       	push	r0
     29e:	cd b7       	in	r28, 0x3d	; 61
     2a0:	de b7       	in	r29, 0x3e	; 62
     2a2:	89 83       	std	Y+1, r24	; 0x01
	 *
	 *
	 */


	*(DIO_PORTx[copy_u8_portID]) = LOW;
     2a4:	89 81       	ldd	r24, Y+1	; 0x01
     2a6:	88 2f       	mov	r24, r24
     2a8:	90 e0       	ldi	r25, 0x00	; 0
     2aa:	88 0f       	add	r24, r24
     2ac:	99 1f       	adc	r25, r25
     2ae:	fc 01       	movw	r30, r24
     2b0:	eb 58       	subi	r30, 0x8B	; 139
     2b2:	ff 4f       	sbci	r31, 0xFF	; 255
     2b4:	01 90       	ld	r0, Z+
     2b6:	f0 81       	ld	r31, Z
     2b8:	e0 2d       	mov	r30, r0
     2ba:	10 82       	st	Z, r1

}
     2bc:	0f 90       	pop	r0
     2be:	cf 91       	pop	r28
     2c0:	df 91       	pop	r29
     2c2:	08 95       	ret

000002c4 <DIO_void_assign_port>:

void DIO_void_assign_port(u8 copy_u8_portID, u8 copy_value){
     2c4:	df 93       	push	r29
     2c6:	cf 93       	push	r28
     2c8:	00 d0       	rcall	.+0      	; 0x2ca <DIO_void_assign_port+0x6>
     2ca:	cd b7       	in	r28, 0x3d	; 61
     2cc:	de b7       	in	r29, 0x3e	; 62
     2ce:	89 83       	std	Y+1, r24	; 0x01
     2d0:	6a 83       	std	Y+2, r22	; 0x02
	 *
	 */



	*(DIO_PORTx[copy_u8_portID]) = copy_value;
     2d2:	89 81       	ldd	r24, Y+1	; 0x01
     2d4:	88 2f       	mov	r24, r24
     2d6:	90 e0       	ldi	r25, 0x00	; 0
     2d8:	88 0f       	add	r24, r24
     2da:	99 1f       	adc	r25, r25
     2dc:	fc 01       	movw	r30, r24
     2de:	eb 58       	subi	r30, 0x8B	; 139
     2e0:	ff 4f       	sbci	r31, 0xFF	; 255
     2e2:	01 90       	ld	r0, Z+
     2e4:	f0 81       	ld	r31, Z
     2e6:	e0 2d       	mov	r30, r0
     2e8:	8a 81       	ldd	r24, Y+2	; 0x02
     2ea:	80 83       	st	Z, r24

}
     2ec:	0f 90       	pop	r0
     2ee:	0f 90       	pop	r0
     2f0:	cf 91       	pop	r28
     2f2:	df 91       	pop	r29
     2f4:	08 95       	ret

000002f6 <DIO_void_toggle_port>:

void DIO_void_toggle_port(u8 copy_u8_portID){
     2f6:	df 93       	push	r29
     2f8:	cf 93       	push	r28
     2fa:	0f 92       	push	r0
     2fc:	cd b7       	in	r28, 0x3d	; 61
     2fe:	de b7       	in	r29, 0x3e	; 62
     300:	89 83       	std	Y+1, r24	; 0x01
	 *
	 *
	 */


	*(DIO_PORTx[copy_u8_portID]) ^= PORT_MAX;
     302:	89 81       	ldd	r24, Y+1	; 0x01
     304:	88 2f       	mov	r24, r24
     306:	90 e0       	ldi	r25, 0x00	; 0
     308:	88 0f       	add	r24, r24
     30a:	99 1f       	adc	r25, r25
     30c:	fc 01       	movw	r30, r24
     30e:	eb 58       	subi	r30, 0x8B	; 139
     310:	ff 4f       	sbci	r31, 0xFF	; 255
     312:	a0 81       	ld	r26, Z
     314:	b1 81       	ldd	r27, Z+1	; 0x01
     316:	89 81       	ldd	r24, Y+1	; 0x01
     318:	88 2f       	mov	r24, r24
     31a:	90 e0       	ldi	r25, 0x00	; 0
     31c:	88 0f       	add	r24, r24
     31e:	99 1f       	adc	r25, r25
     320:	fc 01       	movw	r30, r24
     322:	eb 58       	subi	r30, 0x8B	; 139
     324:	ff 4f       	sbci	r31, 0xFF	; 255
     326:	01 90       	ld	r0, Z+
     328:	f0 81       	ld	r31, Z
     32a:	e0 2d       	mov	r30, r0
     32c:	80 81       	ld	r24, Z
     32e:	80 95       	com	r24
     330:	8c 93       	st	X, r24
}
     332:	0f 90       	pop	r0
     334:	cf 91       	pop	r28
     336:	df 91       	pop	r29
     338:	08 95       	ret

0000033a <DIO_void_set_pin>:

void DIO_void_set_pin(u8 copy_u8_portID , u8 copy_u8_pinID){
     33a:	df 93       	push	r29
     33c:	cf 93       	push	r28
     33e:	00 d0       	rcall	.+0      	; 0x340 <DIO_void_set_pin+0x6>
     340:	cd b7       	in	r28, 0x3d	; 61
     342:	de b7       	in	r29, 0x3e	; 62
     344:	89 83       	std	Y+1, r24	; 0x01
     346:	6a 83       	std	Y+2, r22	; 0x02
	 *
	 *
	 */


	set_Bit(*(DIO_PORTx[copy_u8_portID]),copy_u8_pinID);
     348:	89 81       	ldd	r24, Y+1	; 0x01
     34a:	88 2f       	mov	r24, r24
     34c:	90 e0       	ldi	r25, 0x00	; 0
     34e:	88 0f       	add	r24, r24
     350:	99 1f       	adc	r25, r25
     352:	fc 01       	movw	r30, r24
     354:	eb 58       	subi	r30, 0x8B	; 139
     356:	ff 4f       	sbci	r31, 0xFF	; 255
     358:	a0 81       	ld	r26, Z
     35a:	b1 81       	ldd	r27, Z+1	; 0x01
     35c:	89 81       	ldd	r24, Y+1	; 0x01
     35e:	88 2f       	mov	r24, r24
     360:	90 e0       	ldi	r25, 0x00	; 0
     362:	88 0f       	add	r24, r24
     364:	99 1f       	adc	r25, r25
     366:	fc 01       	movw	r30, r24
     368:	eb 58       	subi	r30, 0x8B	; 139
     36a:	ff 4f       	sbci	r31, 0xFF	; 255
     36c:	01 90       	ld	r0, Z+
     36e:	f0 81       	ld	r31, Z
     370:	e0 2d       	mov	r30, r0
     372:	80 81       	ld	r24, Z
     374:	48 2f       	mov	r20, r24
     376:	8a 81       	ldd	r24, Y+2	; 0x02
     378:	28 2f       	mov	r18, r24
     37a:	30 e0       	ldi	r19, 0x00	; 0
     37c:	81 e0       	ldi	r24, 0x01	; 1
     37e:	90 e0       	ldi	r25, 0x00	; 0
     380:	02 2e       	mov	r0, r18
     382:	02 c0       	rjmp	.+4      	; 0x388 <DIO_void_set_pin+0x4e>
     384:	88 0f       	add	r24, r24
     386:	99 1f       	adc	r25, r25
     388:	0a 94       	dec	r0
     38a:	e2 f7       	brpl	.-8      	; 0x384 <DIO_void_set_pin+0x4a>
     38c:	84 2b       	or	r24, r20
     38e:	8c 93       	st	X, r24
}
     390:	0f 90       	pop	r0
     392:	0f 90       	pop	r0
     394:	cf 91       	pop	r28
     396:	df 91       	pop	r29
     398:	08 95       	ret

0000039a <DIO_void_clear_pin>:

void DIO_void_clear_pin(u8 copy_u8_portID , u8 copy_u8_pinID){
     39a:	df 93       	push	r29
     39c:	cf 93       	push	r28
     39e:	00 d0       	rcall	.+0      	; 0x3a0 <DIO_void_clear_pin+0x6>
     3a0:	cd b7       	in	r28, 0x3d	; 61
     3a2:	de b7       	in	r29, 0x3e	; 62
     3a4:	89 83       	std	Y+1, r24	; 0x01
     3a6:	6a 83       	std	Y+2, r22	; 0x02
	 *
	 *
	 */


	clear_Bit(*(DIO_PORTx[copy_u8_portID]),copy_u8_pinID);
     3a8:	89 81       	ldd	r24, Y+1	; 0x01
     3aa:	88 2f       	mov	r24, r24
     3ac:	90 e0       	ldi	r25, 0x00	; 0
     3ae:	88 0f       	add	r24, r24
     3b0:	99 1f       	adc	r25, r25
     3b2:	fc 01       	movw	r30, r24
     3b4:	eb 58       	subi	r30, 0x8B	; 139
     3b6:	ff 4f       	sbci	r31, 0xFF	; 255
     3b8:	a0 81       	ld	r26, Z
     3ba:	b1 81       	ldd	r27, Z+1	; 0x01
     3bc:	89 81       	ldd	r24, Y+1	; 0x01
     3be:	88 2f       	mov	r24, r24
     3c0:	90 e0       	ldi	r25, 0x00	; 0
     3c2:	88 0f       	add	r24, r24
     3c4:	99 1f       	adc	r25, r25
     3c6:	fc 01       	movw	r30, r24
     3c8:	eb 58       	subi	r30, 0x8B	; 139
     3ca:	ff 4f       	sbci	r31, 0xFF	; 255
     3cc:	01 90       	ld	r0, Z+
     3ce:	f0 81       	ld	r31, Z
     3d0:	e0 2d       	mov	r30, r0
     3d2:	80 81       	ld	r24, Z
     3d4:	48 2f       	mov	r20, r24
     3d6:	8a 81       	ldd	r24, Y+2	; 0x02
     3d8:	28 2f       	mov	r18, r24
     3da:	30 e0       	ldi	r19, 0x00	; 0
     3dc:	81 e0       	ldi	r24, 0x01	; 1
     3de:	90 e0       	ldi	r25, 0x00	; 0
     3e0:	02 2e       	mov	r0, r18
     3e2:	02 c0       	rjmp	.+4      	; 0x3e8 <DIO_void_clear_pin+0x4e>
     3e4:	88 0f       	add	r24, r24
     3e6:	99 1f       	adc	r25, r25
     3e8:	0a 94       	dec	r0
     3ea:	e2 f7       	brpl	.-8      	; 0x3e4 <DIO_void_clear_pin+0x4a>
     3ec:	80 95       	com	r24
     3ee:	84 23       	and	r24, r20
     3f0:	8c 93       	st	X, r24
}
     3f2:	0f 90       	pop	r0
     3f4:	0f 90       	pop	r0
     3f6:	cf 91       	pop	r28
     3f8:	df 91       	pop	r29
     3fa:	08 95       	ret

000003fc <DIO_void_assign_pin>:

void DIO_void_assign_pin(u8 copy_u8_portID,u8 copy_u8_pinID ,u8 copy_value){
     3fc:	df 93       	push	r29
     3fe:	cf 93       	push	r28
     400:	00 d0       	rcall	.+0      	; 0x402 <DIO_void_assign_pin+0x6>
     402:	0f 92       	push	r0
     404:	cd b7       	in	r28, 0x3d	; 61
     406:	de b7       	in	r29, 0x3e	; 62
     408:	89 83       	std	Y+1, r24	; 0x01
     40a:	6a 83       	std	Y+2, r22	; 0x02
     40c:	4b 83       	std	Y+3, r20	; 0x03
	 *
	 */



	assign_Bit(*(DIO_PORTx[copy_u8_portID]),copy_u8_pinID,copy_value);
     40e:	8b 81       	ldd	r24, Y+3	; 0x03
     410:	81 30       	cpi	r24, 0x01	; 1
     412:	29 f5       	brne	.+74     	; 0x45e <DIO_void_assign_pin+0x62>
     414:	89 81       	ldd	r24, Y+1	; 0x01
     416:	88 2f       	mov	r24, r24
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	88 0f       	add	r24, r24
     41c:	99 1f       	adc	r25, r25
     41e:	fc 01       	movw	r30, r24
     420:	eb 58       	subi	r30, 0x8B	; 139
     422:	ff 4f       	sbci	r31, 0xFF	; 255
     424:	a0 81       	ld	r26, Z
     426:	b1 81       	ldd	r27, Z+1	; 0x01
     428:	89 81       	ldd	r24, Y+1	; 0x01
     42a:	88 2f       	mov	r24, r24
     42c:	90 e0       	ldi	r25, 0x00	; 0
     42e:	88 0f       	add	r24, r24
     430:	99 1f       	adc	r25, r25
     432:	fc 01       	movw	r30, r24
     434:	eb 58       	subi	r30, 0x8B	; 139
     436:	ff 4f       	sbci	r31, 0xFF	; 255
     438:	01 90       	ld	r0, Z+
     43a:	f0 81       	ld	r31, Z
     43c:	e0 2d       	mov	r30, r0
     43e:	80 81       	ld	r24, Z
     440:	48 2f       	mov	r20, r24
     442:	8a 81       	ldd	r24, Y+2	; 0x02
     444:	28 2f       	mov	r18, r24
     446:	30 e0       	ldi	r19, 0x00	; 0
     448:	81 e0       	ldi	r24, 0x01	; 1
     44a:	90 e0       	ldi	r25, 0x00	; 0
     44c:	02 2e       	mov	r0, r18
     44e:	02 c0       	rjmp	.+4      	; 0x454 <DIO_void_assign_pin+0x58>
     450:	88 0f       	add	r24, r24
     452:	99 1f       	adc	r25, r25
     454:	0a 94       	dec	r0
     456:	e2 f7       	brpl	.-8      	; 0x450 <DIO_void_assign_pin+0x54>
     458:	84 2b       	or	r24, r20
     45a:	8c 93       	st	X, r24
     45c:	25 c0       	rjmp	.+74     	; 0x4a8 <DIO_void_assign_pin+0xac>
     45e:	89 81       	ldd	r24, Y+1	; 0x01
     460:	88 2f       	mov	r24, r24
     462:	90 e0       	ldi	r25, 0x00	; 0
     464:	88 0f       	add	r24, r24
     466:	99 1f       	adc	r25, r25
     468:	fc 01       	movw	r30, r24
     46a:	eb 58       	subi	r30, 0x8B	; 139
     46c:	ff 4f       	sbci	r31, 0xFF	; 255
     46e:	a0 81       	ld	r26, Z
     470:	b1 81       	ldd	r27, Z+1	; 0x01
     472:	89 81       	ldd	r24, Y+1	; 0x01
     474:	88 2f       	mov	r24, r24
     476:	90 e0       	ldi	r25, 0x00	; 0
     478:	88 0f       	add	r24, r24
     47a:	99 1f       	adc	r25, r25
     47c:	fc 01       	movw	r30, r24
     47e:	eb 58       	subi	r30, 0x8B	; 139
     480:	ff 4f       	sbci	r31, 0xFF	; 255
     482:	01 90       	ld	r0, Z+
     484:	f0 81       	ld	r31, Z
     486:	e0 2d       	mov	r30, r0
     488:	80 81       	ld	r24, Z
     48a:	48 2f       	mov	r20, r24
     48c:	8a 81       	ldd	r24, Y+2	; 0x02
     48e:	28 2f       	mov	r18, r24
     490:	30 e0       	ldi	r19, 0x00	; 0
     492:	81 e0       	ldi	r24, 0x01	; 1
     494:	90 e0       	ldi	r25, 0x00	; 0
     496:	02 2e       	mov	r0, r18
     498:	02 c0       	rjmp	.+4      	; 0x49e <DIO_void_assign_pin+0xa2>
     49a:	88 0f       	add	r24, r24
     49c:	99 1f       	adc	r25, r25
     49e:	0a 94       	dec	r0
     4a0:	e2 f7       	brpl	.-8      	; 0x49a <DIO_void_assign_pin+0x9e>
     4a2:	80 95       	com	r24
     4a4:	84 23       	and	r24, r20
     4a6:	8c 93       	st	X, r24
}
     4a8:	0f 90       	pop	r0
     4aa:	0f 90       	pop	r0
     4ac:	0f 90       	pop	r0
     4ae:	cf 91       	pop	r28
     4b0:	df 91       	pop	r29
     4b2:	08 95       	ret

000004b4 <DIO_void_toggle_pin>:

void DIO_void_toggle_pin(u8 copy_u8_portID , u8 copy_u8_pinID){
     4b4:	df 93       	push	r29
     4b6:	cf 93       	push	r28
     4b8:	00 d0       	rcall	.+0      	; 0x4ba <DIO_void_toggle_pin+0x6>
     4ba:	cd b7       	in	r28, 0x3d	; 61
     4bc:	de b7       	in	r29, 0x3e	; 62
     4be:	89 83       	std	Y+1, r24	; 0x01
     4c0:	6a 83       	std	Y+2, r22	; 0x02
	 *
	 *
	 */


	toggle_Bit(*(DIO_PORTx[copy_u8_portID]),copy_u8_pinID);
     4c2:	89 81       	ldd	r24, Y+1	; 0x01
     4c4:	88 2f       	mov	r24, r24
     4c6:	90 e0       	ldi	r25, 0x00	; 0
     4c8:	88 0f       	add	r24, r24
     4ca:	99 1f       	adc	r25, r25
     4cc:	fc 01       	movw	r30, r24
     4ce:	eb 58       	subi	r30, 0x8B	; 139
     4d0:	ff 4f       	sbci	r31, 0xFF	; 255
     4d2:	a0 81       	ld	r26, Z
     4d4:	b1 81       	ldd	r27, Z+1	; 0x01
     4d6:	89 81       	ldd	r24, Y+1	; 0x01
     4d8:	88 2f       	mov	r24, r24
     4da:	90 e0       	ldi	r25, 0x00	; 0
     4dc:	88 0f       	add	r24, r24
     4de:	99 1f       	adc	r25, r25
     4e0:	fc 01       	movw	r30, r24
     4e2:	eb 58       	subi	r30, 0x8B	; 139
     4e4:	ff 4f       	sbci	r31, 0xFF	; 255
     4e6:	01 90       	ld	r0, Z+
     4e8:	f0 81       	ld	r31, Z
     4ea:	e0 2d       	mov	r30, r0
     4ec:	80 81       	ld	r24, Z
     4ee:	48 2f       	mov	r20, r24
     4f0:	8a 81       	ldd	r24, Y+2	; 0x02
     4f2:	28 2f       	mov	r18, r24
     4f4:	30 e0       	ldi	r19, 0x00	; 0
     4f6:	81 e0       	ldi	r24, 0x01	; 1
     4f8:	90 e0       	ldi	r25, 0x00	; 0
     4fa:	02 2e       	mov	r0, r18
     4fc:	02 c0       	rjmp	.+4      	; 0x502 <DIO_void_toggle_pin+0x4e>
     4fe:	88 0f       	add	r24, r24
     500:	99 1f       	adc	r25, r25
     502:	0a 94       	dec	r0
     504:	e2 f7       	brpl	.-8      	; 0x4fe <DIO_void_toggle_pin+0x4a>
     506:	84 27       	eor	r24, r20
     508:	8c 93       	st	X, r24

}
     50a:	0f 90       	pop	r0
     50c:	0f 90       	pop	r0
     50e:	cf 91       	pop	r28
     510:	df 91       	pop	r29
     512:	08 95       	ret

00000514 <DIO_u8_get_port>:

u8 DIO_u8_get_port(u8 copy_u8_portID){
     514:	df 93       	push	r29
     516:	cf 93       	push	r28
     518:	0f 92       	push	r0
     51a:	cd b7       	in	r28, 0x3d	; 61
     51c:	de b7       	in	r29, 0x3e	; 62
     51e:	89 83       	std	Y+1, r24	; 0x01
	 *  1 byte data
	 */



	return *(DIO_PINx[copy_u8_portID]);
     520:	89 81       	ldd	r24, Y+1	; 0x01
     522:	88 2f       	mov	r24, r24
     524:	90 e0       	ldi	r25, 0x00	; 0
     526:	88 0f       	add	r24, r24
     528:	99 1f       	adc	r25, r25
     52a:	fc 01       	movw	r30, r24
     52c:	eb 59       	subi	r30, 0x9B	; 155
     52e:	ff 4f       	sbci	r31, 0xFF	; 255
     530:	01 90       	ld	r0, Z+
     532:	f0 81       	ld	r31, Z
     534:	e0 2d       	mov	r30, r0
     536:	80 81       	ld	r24, Z
}
     538:	0f 90       	pop	r0
     53a:	cf 91       	pop	r28
     53c:	df 91       	pop	r29
     53e:	08 95       	ret

00000540 <DIO_u8_get_pin>:

u8 DIO_u8_get_pin(u8 copy_u8_portID, u8 copy_u8_pinID){
     540:	df 93       	push	r29
     542:	cf 93       	push	r28
     544:	00 d0       	rcall	.+0      	; 0x546 <DIO_u8_get_pin+0x6>
     546:	cd b7       	in	r28, 0x3d	; 61
     548:	de b7       	in	r29, 0x3e	; 62
     54a:	89 83       	std	Y+1, r24	; 0x01
     54c:	6a 83       	std	Y+2, r22	; 0x02
	 *
	 *
	 */


	return get_Bit(*(DIO_PINx[copy_u8_portID]),copy_u8_pinID);
     54e:	89 81       	ldd	r24, Y+1	; 0x01
     550:	88 2f       	mov	r24, r24
     552:	90 e0       	ldi	r25, 0x00	; 0
     554:	88 0f       	add	r24, r24
     556:	99 1f       	adc	r25, r25
     558:	fc 01       	movw	r30, r24
     55a:	eb 59       	subi	r30, 0x9B	; 155
     55c:	ff 4f       	sbci	r31, 0xFF	; 255
     55e:	01 90       	ld	r0, Z+
     560:	f0 81       	ld	r31, Z
     562:	e0 2d       	mov	r30, r0
     564:	80 81       	ld	r24, Z
     566:	28 2f       	mov	r18, r24
     568:	30 e0       	ldi	r19, 0x00	; 0
     56a:	8a 81       	ldd	r24, Y+2	; 0x02
     56c:	88 2f       	mov	r24, r24
     56e:	90 e0       	ldi	r25, 0x00	; 0
     570:	a9 01       	movw	r20, r18
     572:	02 c0       	rjmp	.+4      	; 0x578 <DIO_u8_get_pin+0x38>
     574:	55 95       	asr	r21
     576:	47 95       	ror	r20
     578:	8a 95       	dec	r24
     57a:	e2 f7       	brpl	.-8      	; 0x574 <DIO_u8_get_pin+0x34>
     57c:	ca 01       	movw	r24, r20
     57e:	81 70       	andi	r24, 0x01	; 1
}
     580:	0f 90       	pop	r0
     582:	0f 90       	pop	r0
     584:	cf 91       	pop	r28
     586:	df 91       	pop	r29
     588:	08 95       	ret

0000058a <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     58a:	df 93       	push	r29
     58c:	cf 93       	push	r28
     58e:	cd b7       	in	r28, 0x3d	; 61
     590:	de b7       	in	r29, 0x3e	; 62
     592:	27 97       	sbiw	r28, 0x07	; 7
     594:	0f b6       	in	r0, 0x3f	; 63
     596:	f8 94       	cli
     598:	de bf       	out	0x3e, r29	; 62
     59a:	0f be       	out	0x3f, r0	; 63
     59c:	cd bf       	out	0x3d, r28	; 61
     59e:	9d 83       	std	Y+5, r25	; 0x05
     5a0:	8c 83       	std	Y+4, r24	; 0x04
     5a2:	6e 83       	std	Y+6, r22	; 0x06
     5a4:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     5a6:	8a e1       	ldi	r24, 0x1A	; 26
     5a8:	90 e0       	ldi	r25, 0x00	; 0
     5aa:	0e 94 9d 05 	call	0xb3a	; 0xb3a <pvPortMalloc>
     5ae:	9a 83       	std	Y+2, r25	; 0x02
     5b0:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     5b2:	89 81       	ldd	r24, Y+1	; 0x01
     5b4:	9a 81       	ldd	r25, Y+2	; 0x02
     5b6:	00 97       	sbiw	r24, 0x00	; 0
     5b8:	09 f4       	brne	.+2      	; 0x5bc <xCoRoutineCreate+0x32>
     5ba:	6f c0       	rjmp	.+222    	; 0x69a <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     5bc:	80 91 80 00 	lds	r24, 0x0080
     5c0:	90 91 81 00 	lds	r25, 0x0081
     5c4:	00 97       	sbiw	r24, 0x00	; 0
     5c6:	41 f4       	brne	.+16     	; 0x5d8 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     5c8:	89 81       	ldd	r24, Y+1	; 0x01
     5ca:	9a 81       	ldd	r25, Y+2	; 0x02
     5cc:	90 93 81 00 	sts	0x0081, r25
     5d0:	80 93 80 00 	sts	0x0080, r24
			prvInitialiseCoRoutineLists();
     5d4:	0e 94 2c 05 	call	0xa58	; 0xa58 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     5d8:	8e 81       	ldd	r24, Y+6	; 0x06
     5da:	82 30       	cpi	r24, 0x02	; 2
     5dc:	10 f0       	brcs	.+4      	; 0x5e2 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     5de:	81 e0       	ldi	r24, 0x01	; 1
     5e0:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     5e2:	e9 81       	ldd	r30, Y+1	; 0x01
     5e4:	fa 81       	ldd	r31, Y+2	; 0x02
     5e6:	11 8e       	std	Z+25, r1	; 0x19
     5e8:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     5ea:	e9 81       	ldd	r30, Y+1	; 0x01
     5ec:	fa 81       	ldd	r31, Y+2	; 0x02
     5ee:	8e 81       	ldd	r24, Y+6	; 0x06
     5f0:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     5f2:	e9 81       	ldd	r30, Y+1	; 0x01
     5f4:	fa 81       	ldd	r31, Y+2	; 0x02
     5f6:	8f 81       	ldd	r24, Y+7	; 0x07
     5f8:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     5fa:	e9 81       	ldd	r30, Y+1	; 0x01
     5fc:	fa 81       	ldd	r31, Y+2	; 0x02
     5fe:	8c 81       	ldd	r24, Y+4	; 0x04
     600:	9d 81       	ldd	r25, Y+5	; 0x05
     602:	91 83       	std	Z+1, r25	; 0x01
     604:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     606:	89 81       	ldd	r24, Y+1	; 0x01
     608:	9a 81       	ldd	r25, Y+2	; 0x02
     60a:	02 96       	adiw	r24, 0x02	; 2
     60c:	0e 94 33 06 	call	0xc66	; 0xc66 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     610:	89 81       	ldd	r24, Y+1	; 0x01
     612:	9a 81       	ldd	r25, Y+2	; 0x02
     614:	0c 96       	adiw	r24, 0x0c	; 12
     616:	0e 94 33 06 	call	0xc66	; 0xc66 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     61a:	e9 81       	ldd	r30, Y+1	; 0x01
     61c:	fa 81       	ldd	r31, Y+2	; 0x02
     61e:	89 81       	ldd	r24, Y+1	; 0x01
     620:	9a 81       	ldd	r25, Y+2	; 0x02
     622:	91 87       	std	Z+9, r25	; 0x09
     624:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     626:	e9 81       	ldd	r30, Y+1	; 0x01
     628:	fa 81       	ldd	r31, Y+2	; 0x02
     62a:	89 81       	ldd	r24, Y+1	; 0x01
     62c:	9a 81       	ldd	r25, Y+2	; 0x02
     62e:	93 8b       	std	Z+19, r25	; 0x13
     630:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     632:	8e 81       	ldd	r24, Y+6	; 0x06
     634:	28 2f       	mov	r18, r24
     636:	30 e0       	ldi	r19, 0x00	; 0
     638:	84 e0       	ldi	r24, 0x04	; 4
     63a:	90 e0       	ldi	r25, 0x00	; 0
     63c:	82 1b       	sub	r24, r18
     63e:	93 0b       	sbc	r25, r19
     640:	e9 81       	ldd	r30, Y+1	; 0x01
     642:	fa 81       	ldd	r31, Y+2	; 0x02
     644:	95 87       	std	Z+13, r25	; 0x0d
     646:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     648:	e9 81       	ldd	r30, Y+1	; 0x01
     64a:	fa 81       	ldd	r31, Y+2	; 0x02
     64c:	96 89       	ldd	r25, Z+22	; 0x16
     64e:	80 91 82 00 	lds	r24, 0x0082
     652:	89 17       	cp	r24, r25
     654:	28 f4       	brcc	.+10     	; 0x660 <xCoRoutineCreate+0xd6>
     656:	e9 81       	ldd	r30, Y+1	; 0x01
     658:	fa 81       	ldd	r31, Y+2	; 0x02
     65a:	86 89       	ldd	r24, Z+22	; 0x16
     65c:	80 93 82 00 	sts	0x0082, r24
     660:	e9 81       	ldd	r30, Y+1	; 0x01
     662:	fa 81       	ldd	r31, Y+2	; 0x02
     664:	86 89       	ldd	r24, Z+22	; 0x16
     666:	28 2f       	mov	r18, r24
     668:	30 e0       	ldi	r19, 0x00	; 0
     66a:	c9 01       	movw	r24, r18
     66c:	88 0f       	add	r24, r24
     66e:	99 1f       	adc	r25, r25
     670:	88 0f       	add	r24, r24
     672:	99 1f       	adc	r25, r25
     674:	88 0f       	add	r24, r24
     676:	99 1f       	adc	r25, r25
     678:	82 0f       	add	r24, r18
     67a:	93 1f       	adc	r25, r19
     67c:	ac 01       	movw	r20, r24
     67e:	47 57       	subi	r20, 0x77	; 119
     680:	5f 4f       	sbci	r21, 0xFF	; 255
     682:	89 81       	ldd	r24, Y+1	; 0x01
     684:	9a 81       	ldd	r25, Y+2	; 0x02
     686:	9c 01       	movw	r18, r24
     688:	2e 5f       	subi	r18, 0xFE	; 254
     68a:	3f 4f       	sbci	r19, 0xFF	; 255
     68c:	ca 01       	movw	r24, r20
     68e:	b9 01       	movw	r22, r18
     690:	0e 94 43 06 	call	0xc86	; 0xc86 <vListInsertEnd>

		xReturn = pdPASS;
     694:	81 e0       	ldi	r24, 0x01	; 1
     696:	8b 83       	std	Y+3, r24	; 0x03
     698:	02 c0       	rjmp	.+4      	; 0x69e <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     69a:	8f ef       	ldi	r24, 0xFF	; 255
     69c:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     69e:	8b 81       	ldd	r24, Y+3	; 0x03
}
     6a0:	27 96       	adiw	r28, 0x07	; 7
     6a2:	0f b6       	in	r0, 0x3f	; 63
     6a4:	f8 94       	cli
     6a6:	de bf       	out	0x3e, r29	; 62
     6a8:	0f be       	out	0x3f, r0	; 63
     6aa:	cd bf       	out	0x3d, r28	; 61
     6ac:	cf 91       	pop	r28
     6ae:	df 91       	pop	r29
     6b0:	08 95       	ret

000006b2 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     6b2:	df 93       	push	r29
     6b4:	cf 93       	push	r28
     6b6:	00 d0       	rcall	.+0      	; 0x6b8 <vCoRoutineAddToDelayedList+0x6>
     6b8:	00 d0       	rcall	.+0      	; 0x6ba <vCoRoutineAddToDelayedList+0x8>
     6ba:	00 d0       	rcall	.+0      	; 0x6bc <vCoRoutineAddToDelayedList+0xa>
     6bc:	cd b7       	in	r28, 0x3d	; 61
     6be:	de b7       	in	r29, 0x3e	; 62
     6c0:	9c 83       	std	Y+4, r25	; 0x04
     6c2:	8b 83       	std	Y+3, r24	; 0x03
     6c4:	7e 83       	std	Y+6, r23	; 0x06
     6c6:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     6c8:	20 91 83 00 	lds	r18, 0x0083
     6cc:	30 91 84 00 	lds	r19, 0x0084
     6d0:	8b 81       	ldd	r24, Y+3	; 0x03
     6d2:	9c 81       	ldd	r25, Y+4	; 0x04
     6d4:	82 0f       	add	r24, r18
     6d6:	93 1f       	adc	r25, r19
     6d8:	9a 83       	std	Y+2, r25	; 0x02
     6da:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     6dc:	80 91 80 00 	lds	r24, 0x0080
     6e0:	90 91 81 00 	lds	r25, 0x0081
     6e4:	02 96       	adiw	r24, 0x02	; 2
     6e6:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     6ea:	e0 91 80 00 	lds	r30, 0x0080
     6ee:	f0 91 81 00 	lds	r31, 0x0081
     6f2:	89 81       	ldd	r24, Y+1	; 0x01
     6f4:	9a 81       	ldd	r25, Y+2	; 0x02
     6f6:	93 83       	std	Z+3, r25	; 0x03
     6f8:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     6fa:	20 91 83 00 	lds	r18, 0x0083
     6fe:	30 91 84 00 	lds	r19, 0x0084
     702:	89 81       	ldd	r24, Y+1	; 0x01
     704:	9a 81       	ldd	r25, Y+2	; 0x02
     706:	82 17       	cp	r24, r18
     708:	93 07       	cpc	r25, r19
     70a:	70 f4       	brcc	.+28     	; 0x728 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     70c:	80 91 af 00 	lds	r24, 0x00AF
     710:	90 91 b0 00 	lds	r25, 0x00B0
     714:	20 91 80 00 	lds	r18, 0x0080
     718:	30 91 81 00 	lds	r19, 0x0081
     71c:	2e 5f       	subi	r18, 0xFE	; 254
     71e:	3f 4f       	sbci	r19, 0xFF	; 255
     720:	b9 01       	movw	r22, r18
     722:	0e 94 8f 06 	call	0xd1e	; 0xd1e <vListInsert>
     726:	0d c0       	rjmp	.+26     	; 0x742 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     728:	80 91 ad 00 	lds	r24, 0x00AD
     72c:	90 91 ae 00 	lds	r25, 0x00AE
     730:	20 91 80 00 	lds	r18, 0x0080
     734:	30 91 81 00 	lds	r19, 0x0081
     738:	2e 5f       	subi	r18, 0xFE	; 254
     73a:	3f 4f       	sbci	r19, 0xFF	; 255
     73c:	b9 01       	movw	r22, r18
     73e:	0e 94 8f 06 	call	0xd1e	; 0xd1e <vListInsert>
	}

	if( pxEventList )
     742:	8d 81       	ldd	r24, Y+5	; 0x05
     744:	9e 81       	ldd	r25, Y+6	; 0x06
     746:	00 97       	sbiw	r24, 0x00	; 0
     748:	61 f0       	breq	.+24     	; 0x762 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     74a:	80 91 80 00 	lds	r24, 0x0080
     74e:	90 91 81 00 	lds	r25, 0x0081
     752:	9c 01       	movw	r18, r24
     754:	24 5f       	subi	r18, 0xF4	; 244
     756:	3f 4f       	sbci	r19, 0xFF	; 255
     758:	8d 81       	ldd	r24, Y+5	; 0x05
     75a:	9e 81       	ldd	r25, Y+6	; 0x06
     75c:	b9 01       	movw	r22, r18
     75e:	0e 94 8f 06 	call	0xd1e	; 0xd1e <vListInsert>
	}
}
     762:	26 96       	adiw	r28, 0x06	; 6
     764:	0f b6       	in	r0, 0x3f	; 63
     766:	f8 94       	cli
     768:	de bf       	out	0x3e, r29	; 62
     76a:	0f be       	out	0x3f, r0	; 63
     76c:	cd bf       	out	0x3d, r28	; 61
     76e:	cf 91       	pop	r28
     770:	df 91       	pop	r29
     772:	08 95       	ret

00000774 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
     774:	df 93       	push	r29
     776:	cf 93       	push	r28
     778:	00 d0       	rcall	.+0      	; 0x77a <prvCheckPendingReadyList+0x6>
     77a:	cd b7       	in	r28, 0x3d	; 61
     77c:	de b7       	in	r29, 0x3e	; 62
     77e:	3a c0       	rjmp	.+116    	; 0x7f4 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     780:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
     782:	e0 91 b6 00 	lds	r30, 0x00B6
     786:	f0 91 b7 00 	lds	r31, 0x00B7
     78a:	86 81       	ldd	r24, Z+6	; 0x06
     78c:	97 81       	ldd	r25, Z+7	; 0x07
     78e:	9a 83       	std	Y+2, r25	; 0x02
     790:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     792:	89 81       	ldd	r24, Y+1	; 0x01
     794:	9a 81       	ldd	r25, Y+2	; 0x02
     796:	0c 96       	adiw	r24, 0x0c	; 12
     798:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>
		}
		portENABLE_INTERRUPTS();
     79c:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     79e:	89 81       	ldd	r24, Y+1	; 0x01
     7a0:	9a 81       	ldd	r25, Y+2	; 0x02
     7a2:	02 96       	adiw	r24, 0x02	; 2
     7a4:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
     7a8:	e9 81       	ldd	r30, Y+1	; 0x01
     7aa:	fa 81       	ldd	r31, Y+2	; 0x02
     7ac:	96 89       	ldd	r25, Z+22	; 0x16
     7ae:	80 91 82 00 	lds	r24, 0x0082
     7b2:	89 17       	cp	r24, r25
     7b4:	28 f4       	brcc	.+10     	; 0x7c0 <prvCheckPendingReadyList+0x4c>
     7b6:	e9 81       	ldd	r30, Y+1	; 0x01
     7b8:	fa 81       	ldd	r31, Y+2	; 0x02
     7ba:	86 89       	ldd	r24, Z+22	; 0x16
     7bc:	80 93 82 00 	sts	0x0082, r24
     7c0:	e9 81       	ldd	r30, Y+1	; 0x01
     7c2:	fa 81       	ldd	r31, Y+2	; 0x02
     7c4:	86 89       	ldd	r24, Z+22	; 0x16
     7c6:	28 2f       	mov	r18, r24
     7c8:	30 e0       	ldi	r19, 0x00	; 0
     7ca:	c9 01       	movw	r24, r18
     7cc:	88 0f       	add	r24, r24
     7ce:	99 1f       	adc	r25, r25
     7d0:	88 0f       	add	r24, r24
     7d2:	99 1f       	adc	r25, r25
     7d4:	88 0f       	add	r24, r24
     7d6:	99 1f       	adc	r25, r25
     7d8:	82 0f       	add	r24, r18
     7da:	93 1f       	adc	r25, r19
     7dc:	ac 01       	movw	r20, r24
     7de:	47 57       	subi	r20, 0x77	; 119
     7e0:	5f 4f       	sbci	r21, 0xFF	; 255
     7e2:	89 81       	ldd	r24, Y+1	; 0x01
     7e4:	9a 81       	ldd	r25, Y+2	; 0x02
     7e6:	9c 01       	movw	r18, r24
     7e8:	2e 5f       	subi	r18, 0xFE	; 254
     7ea:	3f 4f       	sbci	r19, 0xFF	; 255
     7ec:	ca 01       	movw	r24, r20
     7ee:	b9 01       	movw	r22, r18
     7f0:	0e 94 43 06 	call	0xc86	; 0xc86 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     7f4:	80 91 b1 00 	lds	r24, 0x00B1
     7f8:	88 23       	and	r24, r24
     7fa:	09 f0       	breq	.+2      	; 0x7fe <prvCheckPendingReadyList+0x8a>
     7fc:	c1 cf       	rjmp	.-126    	; 0x780 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
     7fe:	0f 90       	pop	r0
     800:	0f 90       	pop	r0
     802:	cf 91       	pop	r28
     804:	df 91       	pop	r29
     806:	08 95       	ret

00000808 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
     808:	df 93       	push	r29
     80a:	cf 93       	push	r28
     80c:	00 d0       	rcall	.+0      	; 0x80e <prvCheckDelayedList+0x6>
     80e:	00 d0       	rcall	.+0      	; 0x810 <prvCheckDelayedList+0x8>
     810:	cd b7       	in	r28, 0x3d	; 61
     812:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     814:	0e 94 c3 11 	call	0x2386	; 0x2386 <xTaskGetTickCount>
     818:	20 91 85 00 	lds	r18, 0x0085
     81c:	30 91 86 00 	lds	r19, 0x0086
     820:	82 1b       	sub	r24, r18
     822:	93 0b       	sbc	r25, r19
     824:	90 93 88 00 	sts	0x0088, r25
     828:	80 93 87 00 	sts	0x0087, r24
     82c:	85 c0       	rjmp	.+266    	; 0x938 <__stack+0xd9>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     82e:	80 91 83 00 	lds	r24, 0x0083
     832:	90 91 84 00 	lds	r25, 0x0084
     836:	01 96       	adiw	r24, 0x01	; 1
     838:	90 93 84 00 	sts	0x0084, r25
     83c:	80 93 83 00 	sts	0x0083, r24
		xPassedTicks--;
     840:	80 91 87 00 	lds	r24, 0x0087
     844:	90 91 88 00 	lds	r25, 0x0088
     848:	01 97       	sbiw	r24, 0x01	; 1
     84a:	90 93 88 00 	sts	0x0088, r25
     84e:	80 93 87 00 	sts	0x0087, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     852:	80 91 83 00 	lds	r24, 0x0083
     856:	90 91 84 00 	lds	r25, 0x0084
     85a:	00 97       	sbiw	r24, 0x00	; 0
     85c:	09 f0       	breq	.+2      	; 0x860 <__stack+0x1>
     85e:	64 c0       	rjmp	.+200    	; 0x928 <__stack+0xc9>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     860:	80 91 ad 00 	lds	r24, 0x00AD
     864:	90 91 ae 00 	lds	r25, 0x00AE
     868:	9a 83       	std	Y+2, r25	; 0x02
     86a:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     86c:	80 91 af 00 	lds	r24, 0x00AF
     870:	90 91 b0 00 	lds	r25, 0x00B0
     874:	90 93 ae 00 	sts	0x00AE, r25
     878:	80 93 ad 00 	sts	0x00AD, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
     87c:	89 81       	ldd	r24, Y+1	; 0x01
     87e:	9a 81       	ldd	r25, Y+2	; 0x02
     880:	90 93 b0 00 	sts	0x00B0, r25
     884:	80 93 af 00 	sts	0x00AF, r24
     888:	4f c0       	rjmp	.+158    	; 0x928 <__stack+0xc9>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     88a:	e0 91 ad 00 	lds	r30, 0x00AD
     88e:	f0 91 ae 00 	lds	r31, 0x00AE
     892:	05 80       	ldd	r0, Z+5	; 0x05
     894:	f6 81       	ldd	r31, Z+6	; 0x06
     896:	e0 2d       	mov	r30, r0
     898:	86 81       	ldd	r24, Z+6	; 0x06
     89a:	97 81       	ldd	r25, Z+7	; 0x07
     89c:	9c 83       	std	Y+4, r25	; 0x04
     89e:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
     8a0:	eb 81       	ldd	r30, Y+3	; 0x03
     8a2:	fc 81       	ldd	r31, Y+4	; 0x04
     8a4:	22 81       	ldd	r18, Z+2	; 0x02
     8a6:	33 81       	ldd	r19, Z+3	; 0x03
     8a8:	80 91 83 00 	lds	r24, 0x0083
     8ac:	90 91 84 00 	lds	r25, 0x0084
     8b0:	82 17       	cp	r24, r18
     8b2:	93 07       	cpc	r25, r19
     8b4:	08 f4       	brcc	.+2      	; 0x8b8 <__stack+0x59>
     8b6:	40 c0       	rjmp	.+128    	; 0x938 <__stack+0xd9>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
     8b8:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
     8ba:	8b 81       	ldd	r24, Y+3	; 0x03
     8bc:	9c 81       	ldd	r25, Y+4	; 0x04
     8be:	02 96       	adiw	r24, 0x02	; 2
     8c0:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
     8c4:	eb 81       	ldd	r30, Y+3	; 0x03
     8c6:	fc 81       	ldd	r31, Y+4	; 0x04
     8c8:	84 89       	ldd	r24, Z+20	; 0x14
     8ca:	95 89       	ldd	r25, Z+21	; 0x15
     8cc:	00 97       	sbiw	r24, 0x00	; 0
     8ce:	29 f0       	breq	.+10     	; 0x8da <__stack+0x7b>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
     8d0:	8b 81       	ldd	r24, Y+3	; 0x03
     8d2:	9c 81       	ldd	r25, Y+4	; 0x04
     8d4:	0c 96       	adiw	r24, 0x0c	; 12
     8d6:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     8da:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
     8dc:	eb 81       	ldd	r30, Y+3	; 0x03
     8de:	fc 81       	ldd	r31, Y+4	; 0x04
     8e0:	96 89       	ldd	r25, Z+22	; 0x16
     8e2:	80 91 82 00 	lds	r24, 0x0082
     8e6:	89 17       	cp	r24, r25
     8e8:	28 f4       	brcc	.+10     	; 0x8f4 <__stack+0x95>
     8ea:	eb 81       	ldd	r30, Y+3	; 0x03
     8ec:	fc 81       	ldd	r31, Y+4	; 0x04
     8ee:	86 89       	ldd	r24, Z+22	; 0x16
     8f0:	80 93 82 00 	sts	0x0082, r24
     8f4:	eb 81       	ldd	r30, Y+3	; 0x03
     8f6:	fc 81       	ldd	r31, Y+4	; 0x04
     8f8:	86 89       	ldd	r24, Z+22	; 0x16
     8fa:	28 2f       	mov	r18, r24
     8fc:	30 e0       	ldi	r19, 0x00	; 0
     8fe:	c9 01       	movw	r24, r18
     900:	88 0f       	add	r24, r24
     902:	99 1f       	adc	r25, r25
     904:	88 0f       	add	r24, r24
     906:	99 1f       	adc	r25, r25
     908:	88 0f       	add	r24, r24
     90a:	99 1f       	adc	r25, r25
     90c:	82 0f       	add	r24, r18
     90e:	93 1f       	adc	r25, r19
     910:	ac 01       	movw	r20, r24
     912:	47 57       	subi	r20, 0x77	; 119
     914:	5f 4f       	sbci	r21, 0xFF	; 255
     916:	8b 81       	ldd	r24, Y+3	; 0x03
     918:	9c 81       	ldd	r25, Y+4	; 0x04
     91a:	9c 01       	movw	r18, r24
     91c:	2e 5f       	subi	r18, 0xFE	; 254
     91e:	3f 4f       	sbci	r19, 0xFF	; 255
     920:	ca 01       	movw	r24, r20
     922:	b9 01       	movw	r22, r18
     924:	0e 94 43 06 	call	0xc86	; 0xc86 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     928:	e0 91 ad 00 	lds	r30, 0x00AD
     92c:	f0 91 ae 00 	lds	r31, 0x00AE
     930:	80 81       	ld	r24, Z
     932:	88 23       	and	r24, r24
     934:	09 f0       	breq	.+2      	; 0x938 <__stack+0xd9>
     936:	a9 cf       	rjmp	.-174    	; 0x88a <__stack+0x2b>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     938:	80 91 87 00 	lds	r24, 0x0087
     93c:	90 91 88 00 	lds	r25, 0x0088
     940:	00 97       	sbiw	r24, 0x00	; 0
     942:	09 f0       	breq	.+2      	; 0x946 <__stack+0xe7>
     944:	74 cf       	rjmp	.-280    	; 0x82e <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
     946:	80 91 83 00 	lds	r24, 0x0083
     94a:	90 91 84 00 	lds	r25, 0x0084
     94e:	90 93 86 00 	sts	0x0086, r25
     952:	80 93 85 00 	sts	0x0085, r24
}
     956:	0f 90       	pop	r0
     958:	0f 90       	pop	r0
     95a:	0f 90       	pop	r0
     95c:	0f 90       	pop	r0
     95e:	cf 91       	pop	r28
     960:	df 91       	pop	r29
     962:	08 95       	ret

00000964 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     964:	df 93       	push	r29
     966:	cf 93       	push	r28
     968:	00 d0       	rcall	.+0      	; 0x96a <vCoRoutineSchedule+0x6>
     96a:	cd b7       	in	r28, 0x3d	; 61
     96c:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
     96e:	0e 94 ba 03 	call	0x774	; 0x774 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
     972:	0e 94 04 04 	call	0x808	; 0x808 <prvCheckDelayedList>
     976:	0a c0       	rjmp	.+20     	; 0x98c <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     978:	80 91 82 00 	lds	r24, 0x0082
     97c:	88 23       	and	r24, r24
     97e:	09 f4       	brne	.+2      	; 0x982 <vCoRoutineSchedule+0x1e>
     980:	66 c0       	rjmp	.+204    	; 0xa4e <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     982:	80 91 82 00 	lds	r24, 0x0082
     986:	81 50       	subi	r24, 0x01	; 1
     988:	80 93 82 00 	sts	0x0082, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     98c:	80 91 82 00 	lds	r24, 0x0082
     990:	28 2f       	mov	r18, r24
     992:	30 e0       	ldi	r19, 0x00	; 0
     994:	c9 01       	movw	r24, r18
     996:	88 0f       	add	r24, r24
     998:	99 1f       	adc	r25, r25
     99a:	88 0f       	add	r24, r24
     99c:	99 1f       	adc	r25, r25
     99e:	88 0f       	add	r24, r24
     9a0:	99 1f       	adc	r25, r25
     9a2:	82 0f       	add	r24, r18
     9a4:	93 1f       	adc	r25, r19
     9a6:	fc 01       	movw	r30, r24
     9a8:	e7 57       	subi	r30, 0x77	; 119
     9aa:	ff 4f       	sbci	r31, 0xFF	; 255
     9ac:	80 81       	ld	r24, Z
     9ae:	88 23       	and	r24, r24
     9b0:	19 f3       	breq	.-58     	; 0x978 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     9b2:	80 91 82 00 	lds	r24, 0x0082
     9b6:	28 2f       	mov	r18, r24
     9b8:	30 e0       	ldi	r19, 0x00	; 0
     9ba:	c9 01       	movw	r24, r18
     9bc:	88 0f       	add	r24, r24
     9be:	99 1f       	adc	r25, r25
     9c0:	88 0f       	add	r24, r24
     9c2:	99 1f       	adc	r25, r25
     9c4:	88 0f       	add	r24, r24
     9c6:	99 1f       	adc	r25, r25
     9c8:	82 0f       	add	r24, r18
     9ca:	93 1f       	adc	r25, r19
     9cc:	87 57       	subi	r24, 0x77	; 119
     9ce:	9f 4f       	sbci	r25, 0xFF	; 255
     9d0:	9a 83       	std	Y+2, r25	; 0x02
     9d2:	89 83       	std	Y+1, r24	; 0x01
     9d4:	e9 81       	ldd	r30, Y+1	; 0x01
     9d6:	fa 81       	ldd	r31, Y+2	; 0x02
     9d8:	01 80       	ldd	r0, Z+1	; 0x01
     9da:	f2 81       	ldd	r31, Z+2	; 0x02
     9dc:	e0 2d       	mov	r30, r0
     9de:	82 81       	ldd	r24, Z+2	; 0x02
     9e0:	93 81       	ldd	r25, Z+3	; 0x03
     9e2:	e9 81       	ldd	r30, Y+1	; 0x01
     9e4:	fa 81       	ldd	r31, Y+2	; 0x02
     9e6:	92 83       	std	Z+2, r25	; 0x02
     9e8:	81 83       	std	Z+1, r24	; 0x01
     9ea:	e9 81       	ldd	r30, Y+1	; 0x01
     9ec:	fa 81       	ldd	r31, Y+2	; 0x02
     9ee:	21 81       	ldd	r18, Z+1	; 0x01
     9f0:	32 81       	ldd	r19, Z+2	; 0x02
     9f2:	89 81       	ldd	r24, Y+1	; 0x01
     9f4:	9a 81       	ldd	r25, Y+2	; 0x02
     9f6:	03 96       	adiw	r24, 0x03	; 3
     9f8:	28 17       	cp	r18, r24
     9fa:	39 07       	cpc	r19, r25
     9fc:	59 f4       	brne	.+22     	; 0xa14 <vCoRoutineSchedule+0xb0>
     9fe:	e9 81       	ldd	r30, Y+1	; 0x01
     a00:	fa 81       	ldd	r31, Y+2	; 0x02
     a02:	01 80       	ldd	r0, Z+1	; 0x01
     a04:	f2 81       	ldd	r31, Z+2	; 0x02
     a06:	e0 2d       	mov	r30, r0
     a08:	82 81       	ldd	r24, Z+2	; 0x02
     a0a:	93 81       	ldd	r25, Z+3	; 0x03
     a0c:	e9 81       	ldd	r30, Y+1	; 0x01
     a0e:	fa 81       	ldd	r31, Y+2	; 0x02
     a10:	92 83       	std	Z+2, r25	; 0x02
     a12:	81 83       	std	Z+1, r24	; 0x01
     a14:	e9 81       	ldd	r30, Y+1	; 0x01
     a16:	fa 81       	ldd	r31, Y+2	; 0x02
     a18:	01 80       	ldd	r0, Z+1	; 0x01
     a1a:	f2 81       	ldd	r31, Z+2	; 0x02
     a1c:	e0 2d       	mov	r30, r0
     a1e:	86 81       	ldd	r24, Z+6	; 0x06
     a20:	97 81       	ldd	r25, Z+7	; 0x07
     a22:	90 93 81 00 	sts	0x0081, r25
     a26:	80 93 80 00 	sts	0x0080, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     a2a:	e0 91 80 00 	lds	r30, 0x0080
     a2e:	f0 91 81 00 	lds	r31, 0x0081
     a32:	40 81       	ld	r20, Z
     a34:	51 81       	ldd	r21, Z+1	; 0x01
     a36:	80 91 80 00 	lds	r24, 0x0080
     a3a:	90 91 81 00 	lds	r25, 0x0081
     a3e:	e0 91 80 00 	lds	r30, 0x0080
     a42:	f0 91 81 00 	lds	r31, 0x0081
     a46:	27 89       	ldd	r18, Z+23	; 0x17
     a48:	62 2f       	mov	r22, r18
     a4a:	fa 01       	movw	r30, r20
     a4c:	09 95       	icall

	return;
}
     a4e:	0f 90       	pop	r0
     a50:	0f 90       	pop	r0
     a52:	cf 91       	pop	r28
     a54:	df 91       	pop	r29
     a56:	08 95       	ret

00000a58 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
     a58:	df 93       	push	r29
     a5a:	cf 93       	push	r28
     a5c:	0f 92       	push	r0
     a5e:	cd b7       	in	r28, 0x3d	; 61
     a60:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     a62:	19 82       	std	Y+1, r1	; 0x01
     a64:	13 c0       	rjmp	.+38     	; 0xa8c <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     a66:	89 81       	ldd	r24, Y+1	; 0x01
     a68:	28 2f       	mov	r18, r24
     a6a:	30 e0       	ldi	r19, 0x00	; 0
     a6c:	c9 01       	movw	r24, r18
     a6e:	88 0f       	add	r24, r24
     a70:	99 1f       	adc	r25, r25
     a72:	88 0f       	add	r24, r24
     a74:	99 1f       	adc	r25, r25
     a76:	88 0f       	add	r24, r24
     a78:	99 1f       	adc	r25, r25
     a7a:	82 0f       	add	r24, r18
     a7c:	93 1f       	adc	r25, r19
     a7e:	87 57       	subi	r24, 0x77	; 119
     a80:	9f 4f       	sbci	r25, 0xFF	; 255
     a82:	0e 94 09 06 	call	0xc12	; 0xc12 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
     a86:	89 81       	ldd	r24, Y+1	; 0x01
     a88:	8f 5f       	subi	r24, 0xFF	; 255
     a8a:	89 83       	std	Y+1, r24	; 0x01
     a8c:	89 81       	ldd	r24, Y+1	; 0x01
     a8e:	82 30       	cpi	r24, 0x02	; 2
     a90:	50 f3       	brcs	.-44     	; 0xa66 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     a92:	8b e9       	ldi	r24, 0x9B	; 155
     a94:	90 e0       	ldi	r25, 0x00	; 0
     a96:	0e 94 09 06 	call	0xc12	; 0xc12 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     a9a:	84 ea       	ldi	r24, 0xA4	; 164
     a9c:	90 e0       	ldi	r25, 0x00	; 0
     a9e:	0e 94 09 06 	call	0xc12	; 0xc12 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     aa2:	81 eb       	ldi	r24, 0xB1	; 177
     aa4:	90 e0       	ldi	r25, 0x00	; 0
     aa6:	0e 94 09 06 	call	0xc12	; 0xc12 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     aaa:	8b e9       	ldi	r24, 0x9B	; 155
     aac:	90 e0       	ldi	r25, 0x00	; 0
     aae:	90 93 ae 00 	sts	0x00AE, r25
     ab2:	80 93 ad 00 	sts	0x00AD, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     ab6:	84 ea       	ldi	r24, 0xA4	; 164
     ab8:	90 e0       	ldi	r25, 0x00	; 0
     aba:	90 93 b0 00 	sts	0x00B0, r25
     abe:	80 93 af 00 	sts	0x00AF, r24
}
     ac2:	0f 90       	pop	r0
     ac4:	cf 91       	pop	r28
     ac6:	df 91       	pop	r29
     ac8:	08 95       	ret

00000aca <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     aca:	df 93       	push	r29
     acc:	cf 93       	push	r28
     ace:	00 d0       	rcall	.+0      	; 0xad0 <xCoRoutineRemoveFromEventList+0x6>
     ad0:	00 d0       	rcall	.+0      	; 0xad2 <xCoRoutineRemoveFromEventList+0x8>
     ad2:	0f 92       	push	r0
     ad4:	cd b7       	in	r28, 0x3d	; 61
     ad6:	de b7       	in	r29, 0x3e	; 62
     ad8:	9d 83       	std	Y+5, r25	; 0x05
     ada:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     adc:	ec 81       	ldd	r30, Y+4	; 0x04
     ade:	fd 81       	ldd	r31, Y+5	; 0x05
     ae0:	05 80       	ldd	r0, Z+5	; 0x05
     ae2:	f6 81       	ldd	r31, Z+6	; 0x06
     ae4:	e0 2d       	mov	r30, r0
     ae6:	86 81       	ldd	r24, Z+6	; 0x06
     ae8:	97 81       	ldd	r25, Z+7	; 0x07
     aea:	9b 83       	std	Y+3, r25	; 0x03
     aec:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     aee:	8a 81       	ldd	r24, Y+2	; 0x02
     af0:	9b 81       	ldd	r25, Y+3	; 0x03
     af2:	0c 96       	adiw	r24, 0x0c	; 12
     af4:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     af8:	8a 81       	ldd	r24, Y+2	; 0x02
     afa:	9b 81       	ldd	r25, Y+3	; 0x03
     afc:	9c 01       	movw	r18, r24
     afe:	24 5f       	subi	r18, 0xF4	; 244
     b00:	3f 4f       	sbci	r19, 0xFF	; 255
     b02:	81 eb       	ldi	r24, 0xB1	; 177
     b04:	90 e0       	ldi	r25, 0x00	; 0
     b06:	b9 01       	movw	r22, r18
     b08:	0e 94 43 06 	call	0xc86	; 0xc86 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     b0c:	ea 81       	ldd	r30, Y+2	; 0x02
     b0e:	fb 81       	ldd	r31, Y+3	; 0x03
     b10:	96 89       	ldd	r25, Z+22	; 0x16
     b12:	e0 91 80 00 	lds	r30, 0x0080
     b16:	f0 91 81 00 	lds	r31, 0x0081
     b1a:	86 89       	ldd	r24, Z+22	; 0x16
     b1c:	98 17       	cp	r25, r24
     b1e:	18 f0       	brcs	.+6      	; 0xb26 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
     b20:	81 e0       	ldi	r24, 0x01	; 1
     b22:	89 83       	std	Y+1, r24	; 0x01
     b24:	01 c0       	rjmp	.+2      	; 0xb28 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
     b26:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
     b28:	89 81       	ldd	r24, Y+1	; 0x01
}
     b2a:	0f 90       	pop	r0
     b2c:	0f 90       	pop	r0
     b2e:	0f 90       	pop	r0
     b30:	0f 90       	pop	r0
     b32:	0f 90       	pop	r0
     b34:	cf 91       	pop	r28
     b36:	df 91       	pop	r29
     b38:	08 95       	ret

00000b3a <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     b3a:	df 93       	push	r29
     b3c:	cf 93       	push	r28
     b3e:	00 d0       	rcall	.+0      	; 0xb40 <pvPortMalloc+0x6>
     b40:	00 d0       	rcall	.+0      	; 0xb42 <pvPortMalloc+0x8>
     b42:	cd b7       	in	r28, 0x3d	; 61
     b44:	de b7       	in	r29, 0x3e	; 62
     b46:	9c 83       	std	Y+4, r25	; 0x04
     b48:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
     b4a:	1a 82       	std	Y+2, r1	; 0x02
     b4c:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     b4e:	0e 94 2d 11 	call	0x225a	; 0x225a <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     b52:	80 91 ba 00 	lds	r24, 0x00BA
     b56:	90 91 bb 00 	lds	r25, 0x00BB
     b5a:	2b 81       	ldd	r18, Y+3	; 0x03
     b5c:	3c 81       	ldd	r19, Y+4	; 0x04
     b5e:	82 0f       	add	r24, r18
     b60:	93 1f       	adc	r25, r19
     b62:	23 e0       	ldi	r18, 0x03	; 3
     b64:	80 32       	cpi	r24, 0x20	; 32
     b66:	92 07       	cpc	r25, r18
     b68:	18 f5       	brcc	.+70     	; 0xbb0 <pvPortMalloc+0x76>
     b6a:	20 91 ba 00 	lds	r18, 0x00BA
     b6e:	30 91 bb 00 	lds	r19, 0x00BB
     b72:	8b 81       	ldd	r24, Y+3	; 0x03
     b74:	9c 81       	ldd	r25, Y+4	; 0x04
     b76:	28 0f       	add	r18, r24
     b78:	39 1f       	adc	r19, r25
     b7a:	80 91 ba 00 	lds	r24, 0x00BA
     b7e:	90 91 bb 00 	lds	r25, 0x00BB
     b82:	82 17       	cp	r24, r18
     b84:	93 07       	cpc	r25, r19
     b86:	a0 f4       	brcc	.+40     	; 0xbb0 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     b88:	80 91 ba 00 	lds	r24, 0x00BA
     b8c:	90 91 bb 00 	lds	r25, 0x00BB
     b90:	84 54       	subi	r24, 0x44	; 68
     b92:	9f 4f       	sbci	r25, 0xFF	; 255
     b94:	9a 83       	std	Y+2, r25	; 0x02
     b96:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
     b98:	20 91 ba 00 	lds	r18, 0x00BA
     b9c:	30 91 bb 00 	lds	r19, 0x00BB
     ba0:	8b 81       	ldd	r24, Y+3	; 0x03
     ba2:	9c 81       	ldd	r25, Y+4	; 0x04
     ba4:	82 0f       	add	r24, r18
     ba6:	93 1f       	adc	r25, r19
     ba8:	90 93 bb 00 	sts	0x00BB, r25
     bac:	80 93 ba 00 	sts	0x00BA, r24
		}	
	}
	xTaskResumeAll();
     bb0:	0e 94 39 11 	call	0x2272	; 0x2272 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
     bb4:	89 81       	ldd	r24, Y+1	; 0x01
     bb6:	9a 81       	ldd	r25, Y+2	; 0x02
}
     bb8:	0f 90       	pop	r0
     bba:	0f 90       	pop	r0
     bbc:	0f 90       	pop	r0
     bbe:	0f 90       	pop	r0
     bc0:	cf 91       	pop	r28
     bc2:	df 91       	pop	r29
     bc4:	08 95       	ret

00000bc6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     bc6:	df 93       	push	r29
     bc8:	cf 93       	push	r28
     bca:	00 d0       	rcall	.+0      	; 0xbcc <vPortFree+0x6>
     bcc:	cd b7       	in	r28, 0x3d	; 61
     bce:	de b7       	in	r29, 0x3e	; 62
     bd0:	9a 83       	std	Y+2, r25	; 0x02
     bd2:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
     bd4:	0f 90       	pop	r0
     bd6:	0f 90       	pop	r0
     bd8:	cf 91       	pop	r28
     bda:	df 91       	pop	r29
     bdc:	08 95       	ret

00000bde <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     bde:	df 93       	push	r29
     be0:	cf 93       	push	r28
     be2:	cd b7       	in	r28, 0x3d	; 61
     be4:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     be6:	10 92 bb 00 	sts	0x00BB, r1
     bea:	10 92 ba 00 	sts	0x00BA, r1
}
     bee:	cf 91       	pop	r28
     bf0:	df 91       	pop	r29
     bf2:	08 95       	ret

00000bf4 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     bf4:	df 93       	push	r29
     bf6:	cf 93       	push	r28
     bf8:	cd b7       	in	r28, 0x3d	; 61
     bfa:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
     bfc:	20 91 ba 00 	lds	r18, 0x00BA
     c00:	30 91 bb 00 	lds	r19, 0x00BB
     c04:	80 e2       	ldi	r24, 0x20	; 32
     c06:	93 e0       	ldi	r25, 0x03	; 3
     c08:	82 1b       	sub	r24, r18
     c0a:	93 0b       	sbc	r25, r19
}
     c0c:	cf 91       	pop	r28
     c0e:	df 91       	pop	r29
     c10:	08 95       	ret

00000c12 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     c12:	df 93       	push	r29
     c14:	cf 93       	push	r28
     c16:	00 d0       	rcall	.+0      	; 0xc18 <vListInitialise+0x6>
     c18:	cd b7       	in	r28, 0x3d	; 61
     c1a:	de b7       	in	r29, 0x3e	; 62
     c1c:	9a 83       	std	Y+2, r25	; 0x02
     c1e:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     c20:	89 81       	ldd	r24, Y+1	; 0x01
     c22:	9a 81       	ldd	r25, Y+2	; 0x02
     c24:	03 96       	adiw	r24, 0x03	; 3
     c26:	e9 81       	ldd	r30, Y+1	; 0x01
     c28:	fa 81       	ldd	r31, Y+2	; 0x02
     c2a:	92 83       	std	Z+2, r25	; 0x02
     c2c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     c2e:	e9 81       	ldd	r30, Y+1	; 0x01
     c30:	fa 81       	ldd	r31, Y+2	; 0x02
     c32:	8f ef       	ldi	r24, 0xFF	; 255
     c34:	9f ef       	ldi	r25, 0xFF	; 255
     c36:	94 83       	std	Z+4, r25	; 0x04
     c38:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     c3a:	89 81       	ldd	r24, Y+1	; 0x01
     c3c:	9a 81       	ldd	r25, Y+2	; 0x02
     c3e:	03 96       	adiw	r24, 0x03	; 3
     c40:	e9 81       	ldd	r30, Y+1	; 0x01
     c42:	fa 81       	ldd	r31, Y+2	; 0x02
     c44:	96 83       	std	Z+6, r25	; 0x06
     c46:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     c48:	89 81       	ldd	r24, Y+1	; 0x01
     c4a:	9a 81       	ldd	r25, Y+2	; 0x02
     c4c:	03 96       	adiw	r24, 0x03	; 3
     c4e:	e9 81       	ldd	r30, Y+1	; 0x01
     c50:	fa 81       	ldd	r31, Y+2	; 0x02
     c52:	90 87       	std	Z+8, r25	; 0x08
     c54:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     c56:	e9 81       	ldd	r30, Y+1	; 0x01
     c58:	fa 81       	ldd	r31, Y+2	; 0x02
     c5a:	10 82       	st	Z, r1
}
     c5c:	0f 90       	pop	r0
     c5e:	0f 90       	pop	r0
     c60:	cf 91       	pop	r28
     c62:	df 91       	pop	r29
     c64:	08 95       	ret

00000c66 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
     c66:	df 93       	push	r29
     c68:	cf 93       	push	r28
     c6a:	00 d0       	rcall	.+0      	; 0xc6c <vListInitialiseItem+0x6>
     c6c:	cd b7       	in	r28, 0x3d	; 61
     c6e:	de b7       	in	r29, 0x3e	; 62
     c70:	9a 83       	std	Y+2, r25	; 0x02
     c72:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     c74:	e9 81       	ldd	r30, Y+1	; 0x01
     c76:	fa 81       	ldd	r31, Y+2	; 0x02
     c78:	11 86       	std	Z+9, r1	; 0x09
     c7a:	10 86       	std	Z+8, r1	; 0x08
}
     c7c:	0f 90       	pop	r0
     c7e:	0f 90       	pop	r0
     c80:	cf 91       	pop	r28
     c82:	df 91       	pop	r29
     c84:	08 95       	ret

00000c86 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     c86:	df 93       	push	r29
     c88:	cf 93       	push	r28
     c8a:	00 d0       	rcall	.+0      	; 0xc8c <vListInsertEnd+0x6>
     c8c:	00 d0       	rcall	.+0      	; 0xc8e <vListInsertEnd+0x8>
     c8e:	00 d0       	rcall	.+0      	; 0xc90 <vListInsertEnd+0xa>
     c90:	cd b7       	in	r28, 0x3d	; 61
     c92:	de b7       	in	r29, 0x3e	; 62
     c94:	9c 83       	std	Y+4, r25	; 0x04
     c96:	8b 83       	std	Y+3, r24	; 0x03
     c98:	7e 83       	std	Y+6, r23	; 0x06
     c9a:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     c9c:	eb 81       	ldd	r30, Y+3	; 0x03
     c9e:	fc 81       	ldd	r31, Y+4	; 0x04
     ca0:	81 81       	ldd	r24, Z+1	; 0x01
     ca2:	92 81       	ldd	r25, Z+2	; 0x02
     ca4:	9a 83       	std	Y+2, r25	; 0x02
     ca6:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
     ca8:	e9 81       	ldd	r30, Y+1	; 0x01
     caa:	fa 81       	ldd	r31, Y+2	; 0x02
     cac:	82 81       	ldd	r24, Z+2	; 0x02
     cae:	93 81       	ldd	r25, Z+3	; 0x03
     cb0:	ed 81       	ldd	r30, Y+5	; 0x05
     cb2:	fe 81       	ldd	r31, Y+6	; 0x06
     cb4:	93 83       	std	Z+3, r25	; 0x03
     cb6:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     cb8:	eb 81       	ldd	r30, Y+3	; 0x03
     cba:	fc 81       	ldd	r31, Y+4	; 0x04
     cbc:	81 81       	ldd	r24, Z+1	; 0x01
     cbe:	92 81       	ldd	r25, Z+2	; 0x02
     cc0:	ed 81       	ldd	r30, Y+5	; 0x05
     cc2:	fe 81       	ldd	r31, Y+6	; 0x06
     cc4:	95 83       	std	Z+5, r25	; 0x05
     cc6:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     cc8:	e9 81       	ldd	r30, Y+1	; 0x01
     cca:	fa 81       	ldd	r31, Y+2	; 0x02
     ccc:	02 80       	ldd	r0, Z+2	; 0x02
     cce:	f3 81       	ldd	r31, Z+3	; 0x03
     cd0:	e0 2d       	mov	r30, r0
     cd2:	8d 81       	ldd	r24, Y+5	; 0x05
     cd4:	9e 81       	ldd	r25, Y+6	; 0x06
     cd6:	95 83       	std	Z+5, r25	; 0x05
     cd8:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     cda:	8d 81       	ldd	r24, Y+5	; 0x05
     cdc:	9e 81       	ldd	r25, Y+6	; 0x06
     cde:	e9 81       	ldd	r30, Y+1	; 0x01
     ce0:	fa 81       	ldd	r31, Y+2	; 0x02
     ce2:	93 83       	std	Z+3, r25	; 0x03
     ce4:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     ce6:	8d 81       	ldd	r24, Y+5	; 0x05
     ce8:	9e 81       	ldd	r25, Y+6	; 0x06
     cea:	eb 81       	ldd	r30, Y+3	; 0x03
     cec:	fc 81       	ldd	r31, Y+4	; 0x04
     cee:	92 83       	std	Z+2, r25	; 0x02
     cf0:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     cf2:	ed 81       	ldd	r30, Y+5	; 0x05
     cf4:	fe 81       	ldd	r31, Y+6	; 0x06
     cf6:	8b 81       	ldd	r24, Y+3	; 0x03
     cf8:	9c 81       	ldd	r25, Y+4	; 0x04
     cfa:	91 87       	std	Z+9, r25	; 0x09
     cfc:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     cfe:	eb 81       	ldd	r30, Y+3	; 0x03
     d00:	fc 81       	ldd	r31, Y+4	; 0x04
     d02:	80 81       	ld	r24, Z
     d04:	8f 5f       	subi	r24, 0xFF	; 255
     d06:	eb 81       	ldd	r30, Y+3	; 0x03
     d08:	fc 81       	ldd	r31, Y+4	; 0x04
     d0a:	80 83       	st	Z, r24
}
     d0c:	26 96       	adiw	r28, 0x06	; 6
     d0e:	0f b6       	in	r0, 0x3f	; 63
     d10:	f8 94       	cli
     d12:	de bf       	out	0x3e, r29	; 62
     d14:	0f be       	out	0x3f, r0	; 63
     d16:	cd bf       	out	0x3d, r28	; 61
     d18:	cf 91       	pop	r28
     d1a:	df 91       	pop	r29
     d1c:	08 95       	ret

00000d1e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     d1e:	df 93       	push	r29
     d20:	cf 93       	push	r28
     d22:	cd b7       	in	r28, 0x3d	; 61
     d24:	de b7       	in	r29, 0x3e	; 62
     d26:	28 97       	sbiw	r28, 0x08	; 8
     d28:	0f b6       	in	r0, 0x3f	; 63
     d2a:	f8 94       	cli
     d2c:	de bf       	out	0x3e, r29	; 62
     d2e:	0f be       	out	0x3f, r0	; 63
     d30:	cd bf       	out	0x3d, r28	; 61
     d32:	9e 83       	std	Y+6, r25	; 0x06
     d34:	8d 83       	std	Y+5, r24	; 0x05
     d36:	78 87       	std	Y+8, r23	; 0x08
     d38:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     d3a:	ef 81       	ldd	r30, Y+7	; 0x07
     d3c:	f8 85       	ldd	r31, Y+8	; 0x08
     d3e:	80 81       	ld	r24, Z
     d40:	91 81       	ldd	r25, Z+1	; 0x01
     d42:	9a 83       	std	Y+2, r25	; 0x02
     d44:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     d46:	89 81       	ldd	r24, Y+1	; 0x01
     d48:	9a 81       	ldd	r25, Y+2	; 0x02
     d4a:	2f ef       	ldi	r18, 0xFF	; 255
     d4c:	8f 3f       	cpi	r24, 0xFF	; 255
     d4e:	92 07       	cpc	r25, r18
     d50:	39 f4       	brne	.+14     	; 0xd60 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     d52:	ed 81       	ldd	r30, Y+5	; 0x05
     d54:	fe 81       	ldd	r31, Y+6	; 0x06
     d56:	87 81       	ldd	r24, Z+7	; 0x07
     d58:	90 85       	ldd	r25, Z+8	; 0x08
     d5a:	9c 83       	std	Y+4, r25	; 0x04
     d5c:	8b 83       	std	Y+3, r24	; 0x03
     d5e:	18 c0       	rjmp	.+48     	; 0xd90 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     d60:	8d 81       	ldd	r24, Y+5	; 0x05
     d62:	9e 81       	ldd	r25, Y+6	; 0x06
     d64:	03 96       	adiw	r24, 0x03	; 3
     d66:	9c 83       	std	Y+4, r25	; 0x04
     d68:	8b 83       	std	Y+3, r24	; 0x03
     d6a:	06 c0       	rjmp	.+12     	; 0xd78 <vListInsert+0x5a>
     d6c:	eb 81       	ldd	r30, Y+3	; 0x03
     d6e:	fc 81       	ldd	r31, Y+4	; 0x04
     d70:	82 81       	ldd	r24, Z+2	; 0x02
     d72:	93 81       	ldd	r25, Z+3	; 0x03
     d74:	9c 83       	std	Y+4, r25	; 0x04
     d76:	8b 83       	std	Y+3, r24	; 0x03
     d78:	eb 81       	ldd	r30, Y+3	; 0x03
     d7a:	fc 81       	ldd	r31, Y+4	; 0x04
     d7c:	02 80       	ldd	r0, Z+2	; 0x02
     d7e:	f3 81       	ldd	r31, Z+3	; 0x03
     d80:	e0 2d       	mov	r30, r0
     d82:	20 81       	ld	r18, Z
     d84:	31 81       	ldd	r19, Z+1	; 0x01
     d86:	89 81       	ldd	r24, Y+1	; 0x01
     d88:	9a 81       	ldd	r25, Y+2	; 0x02
     d8a:	82 17       	cp	r24, r18
     d8c:	93 07       	cpc	r25, r19
     d8e:	70 f7       	brcc	.-36     	; 0xd6c <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     d90:	eb 81       	ldd	r30, Y+3	; 0x03
     d92:	fc 81       	ldd	r31, Y+4	; 0x04
     d94:	82 81       	ldd	r24, Z+2	; 0x02
     d96:	93 81       	ldd	r25, Z+3	; 0x03
     d98:	ef 81       	ldd	r30, Y+7	; 0x07
     d9a:	f8 85       	ldd	r31, Y+8	; 0x08
     d9c:	93 83       	std	Z+3, r25	; 0x03
     d9e:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     da0:	ef 81       	ldd	r30, Y+7	; 0x07
     da2:	f8 85       	ldd	r31, Y+8	; 0x08
     da4:	02 80       	ldd	r0, Z+2	; 0x02
     da6:	f3 81       	ldd	r31, Z+3	; 0x03
     da8:	e0 2d       	mov	r30, r0
     daa:	8f 81       	ldd	r24, Y+7	; 0x07
     dac:	98 85       	ldd	r25, Y+8	; 0x08
     dae:	95 83       	std	Z+5, r25	; 0x05
     db0:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     db2:	ef 81       	ldd	r30, Y+7	; 0x07
     db4:	f8 85       	ldd	r31, Y+8	; 0x08
     db6:	8b 81       	ldd	r24, Y+3	; 0x03
     db8:	9c 81       	ldd	r25, Y+4	; 0x04
     dba:	95 83       	std	Z+5, r25	; 0x05
     dbc:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     dbe:	8f 81       	ldd	r24, Y+7	; 0x07
     dc0:	98 85       	ldd	r25, Y+8	; 0x08
     dc2:	eb 81       	ldd	r30, Y+3	; 0x03
     dc4:	fc 81       	ldd	r31, Y+4	; 0x04
     dc6:	93 83       	std	Z+3, r25	; 0x03
     dc8:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     dca:	ef 81       	ldd	r30, Y+7	; 0x07
     dcc:	f8 85       	ldd	r31, Y+8	; 0x08
     dce:	8d 81       	ldd	r24, Y+5	; 0x05
     dd0:	9e 81       	ldd	r25, Y+6	; 0x06
     dd2:	91 87       	std	Z+9, r25	; 0x09
     dd4:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     dd6:	ed 81       	ldd	r30, Y+5	; 0x05
     dd8:	fe 81       	ldd	r31, Y+6	; 0x06
     dda:	80 81       	ld	r24, Z
     ddc:	8f 5f       	subi	r24, 0xFF	; 255
     dde:	ed 81       	ldd	r30, Y+5	; 0x05
     de0:	fe 81       	ldd	r31, Y+6	; 0x06
     de2:	80 83       	st	Z, r24
}
     de4:	28 96       	adiw	r28, 0x08	; 8
     de6:	0f b6       	in	r0, 0x3f	; 63
     de8:	f8 94       	cli
     dea:	de bf       	out	0x3e, r29	; 62
     dec:	0f be       	out	0x3f, r0	; 63
     dee:	cd bf       	out	0x3d, r28	; 61
     df0:	cf 91       	pop	r28
     df2:	df 91       	pop	r29
     df4:	08 95       	ret

00000df6 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     df6:	df 93       	push	r29
     df8:	cf 93       	push	r28
     dfa:	00 d0       	rcall	.+0      	; 0xdfc <vListRemove+0x6>
     dfc:	00 d0       	rcall	.+0      	; 0xdfe <vListRemove+0x8>
     dfe:	cd b7       	in	r28, 0x3d	; 61
     e00:	de b7       	in	r29, 0x3e	; 62
     e02:	9c 83       	std	Y+4, r25	; 0x04
     e04:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     e06:	eb 81       	ldd	r30, Y+3	; 0x03
     e08:	fc 81       	ldd	r31, Y+4	; 0x04
     e0a:	a2 81       	ldd	r26, Z+2	; 0x02
     e0c:	b3 81       	ldd	r27, Z+3	; 0x03
     e0e:	eb 81       	ldd	r30, Y+3	; 0x03
     e10:	fc 81       	ldd	r31, Y+4	; 0x04
     e12:	84 81       	ldd	r24, Z+4	; 0x04
     e14:	95 81       	ldd	r25, Z+5	; 0x05
     e16:	15 96       	adiw	r26, 0x05	; 5
     e18:	9c 93       	st	X, r25
     e1a:	8e 93       	st	-X, r24
     e1c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     e1e:	eb 81       	ldd	r30, Y+3	; 0x03
     e20:	fc 81       	ldd	r31, Y+4	; 0x04
     e22:	a4 81       	ldd	r26, Z+4	; 0x04
     e24:	b5 81       	ldd	r27, Z+5	; 0x05
     e26:	eb 81       	ldd	r30, Y+3	; 0x03
     e28:	fc 81       	ldd	r31, Y+4	; 0x04
     e2a:	82 81       	ldd	r24, Z+2	; 0x02
     e2c:	93 81       	ldd	r25, Z+3	; 0x03
     e2e:	13 96       	adiw	r26, 0x03	; 3
     e30:	9c 93       	st	X, r25
     e32:	8e 93       	st	-X, r24
     e34:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     e36:	eb 81       	ldd	r30, Y+3	; 0x03
     e38:	fc 81       	ldd	r31, Y+4	; 0x04
     e3a:	80 85       	ldd	r24, Z+8	; 0x08
     e3c:	91 85       	ldd	r25, Z+9	; 0x09
     e3e:	9a 83       	std	Y+2, r25	; 0x02
     e40:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     e42:	e9 81       	ldd	r30, Y+1	; 0x01
     e44:	fa 81       	ldd	r31, Y+2	; 0x02
     e46:	21 81       	ldd	r18, Z+1	; 0x01
     e48:	32 81       	ldd	r19, Z+2	; 0x02
     e4a:	8b 81       	ldd	r24, Y+3	; 0x03
     e4c:	9c 81       	ldd	r25, Y+4	; 0x04
     e4e:	28 17       	cp	r18, r24
     e50:	39 07       	cpc	r19, r25
     e52:	41 f4       	brne	.+16     	; 0xe64 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     e54:	eb 81       	ldd	r30, Y+3	; 0x03
     e56:	fc 81       	ldd	r31, Y+4	; 0x04
     e58:	84 81       	ldd	r24, Z+4	; 0x04
     e5a:	95 81       	ldd	r25, Z+5	; 0x05
     e5c:	e9 81       	ldd	r30, Y+1	; 0x01
     e5e:	fa 81       	ldd	r31, Y+2	; 0x02
     e60:	92 83       	std	Z+2, r25	; 0x02
     e62:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
     e64:	eb 81       	ldd	r30, Y+3	; 0x03
     e66:	fc 81       	ldd	r31, Y+4	; 0x04
     e68:	11 86       	std	Z+9, r1	; 0x09
     e6a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     e6c:	e9 81       	ldd	r30, Y+1	; 0x01
     e6e:	fa 81       	ldd	r31, Y+2	; 0x02
     e70:	80 81       	ld	r24, Z
     e72:	81 50       	subi	r24, 0x01	; 1
     e74:	e9 81       	ldd	r30, Y+1	; 0x01
     e76:	fa 81       	ldd	r31, Y+2	; 0x02
     e78:	80 83       	st	Z, r24
}
     e7a:	0f 90       	pop	r0
     e7c:	0f 90       	pop	r0
     e7e:	0f 90       	pop	r0
     e80:	0f 90       	pop	r0
     e82:	cf 91       	pop	r28
     e84:	df 91       	pop	r29
     e86:	08 95       	ret

00000e88 <toggle_led1>:
#include "FreeRTOS.h"
#include "task.h"



void toggle_led1(void* ptr){
     e88:	df 93       	push	r29
     e8a:	cf 93       	push	r28
     e8c:	00 d0       	rcall	.+0      	; 0xe8e <toggle_led1+0x6>
     e8e:	cd b7       	in	r28, 0x3d	; 61
     e90:	de b7       	in	r29, 0x3e	; 62
     e92:	9a 83       	std	Y+2, r25	; 0x02
     e94:	89 83       	std	Y+1, r24	; 0x01

	while(1){

		DIO_void_toggle_pin(PORTA, PIN0);
     e96:	80 e0       	ldi	r24, 0x00	; 0
     e98:	60 e0       	ldi	r22, 0x00	; 0
     e9a:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <DIO_void_toggle_pin>
			vTaskDelay(500);
     e9e:	84 ef       	ldi	r24, 0xF4	; 244
     ea0:	91 e0       	ldi	r25, 0x01	; 1
     ea2:	0e 94 b5 10 	call	0x216a	; 0x216a <vTaskDelay>
     ea6:	f7 cf       	rjmp	.-18     	; 0xe96 <toggle_led1+0xe>

00000ea8 <toggle_led2>:

	}

}

void toggle_led2(void* ptr){
     ea8:	df 93       	push	r29
     eaa:	cf 93       	push	r28
     eac:	00 d0       	rcall	.+0      	; 0xeae <toggle_led2+0x6>
     eae:	cd b7       	in	r28, 0x3d	; 61
     eb0:	de b7       	in	r29, 0x3e	; 62
     eb2:	9a 83       	std	Y+2, r25	; 0x02
     eb4:	89 83       	std	Y+1, r24	; 0x01

	while(1){

		DIO_void_toggle_pin(PORTA, PIN1);
     eb6:	80 e0       	ldi	r24, 0x00	; 0
     eb8:	61 e0       	ldi	r22, 0x01	; 1
     eba:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <DIO_void_toggle_pin>
		vTaskDelay(1000);
     ebe:	88 ee       	ldi	r24, 0xE8	; 232
     ec0:	93 e0       	ldi	r25, 0x03	; 3
     ec2:	0e 94 b5 10 	call	0x216a	; 0x216a <vTaskDelay>
     ec6:	f7 cf       	rjmp	.-18     	; 0xeb6 <toggle_led2+0xe>

00000ec8 <main>:
	}
}

int main(){
     ec8:	af 92       	push	r10
     eca:	bf 92       	push	r11
     ecc:	cf 92       	push	r12
     ece:	df 92       	push	r13
     ed0:	ef 92       	push	r14
     ed2:	ff 92       	push	r15
     ed4:	0f 93       	push	r16
     ed6:	df 93       	push	r29
     ed8:	cf 93       	push	r28
     eda:	cd b7       	in	r28, 0x3d	; 61
     edc:	de b7       	in	r29, 0x3e	; 62

	DIO_void_set_pin_dir(PORTA, PIN0, OUTPUT);
     ede:	80 e0       	ldi	r24, 0x00	; 0
     ee0:	60 e0       	ldi	r22, 0x00	; 0
     ee2:	41 e0       	ldi	r20, 0x01	; 1
     ee4:	0e 94 62 00 	call	0xc4	; 0xc4 <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(PORTA, PIN1, OUTPUT);
     ee8:	80 e0       	ldi	r24, 0x00	; 0
     eea:	61 e0       	ldi	r22, 0x01	; 1
     eec:	41 e0       	ldi	r20, 0x01	; 1
     eee:	0e 94 62 00 	call	0xc4	; 0xc4 <DIO_void_set_pin_dir>


	xTaskCreate(toggle_led1,NULL,100,NULL,3,NULL);
     ef2:	84 e4       	ldi	r24, 0x44	; 68
     ef4:	97 e0       	ldi	r25, 0x07	; 7
     ef6:	60 e0       	ldi	r22, 0x00	; 0
     ef8:	70 e0       	ldi	r23, 0x00	; 0
     efa:	44 e6       	ldi	r20, 0x64	; 100
     efc:	50 e0       	ldi	r21, 0x00	; 0
     efe:	20 e0       	ldi	r18, 0x00	; 0
     f00:	30 e0       	ldi	r19, 0x00	; 0
     f02:	03 e0       	ldi	r16, 0x03	; 3
     f04:	ee 24       	eor	r14, r14
     f06:	ff 24       	eor	r15, r15
     f08:	cc 24       	eor	r12, r12
     f0a:	dd 24       	eor	r13, r13
     f0c:	aa 24       	eor	r10, r10
     f0e:	bb 24       	eor	r11, r11
     f10:	0e 94 f1 0e 	call	0x1de2	; 0x1de2 <xTaskGenericCreate>
	xTaskCreate(toggle_led2,NULL,100,NULL,1,NULL);
     f14:	84 e5       	ldi	r24, 0x54	; 84
     f16:	97 e0       	ldi	r25, 0x07	; 7
     f18:	60 e0       	ldi	r22, 0x00	; 0
     f1a:	70 e0       	ldi	r23, 0x00	; 0
     f1c:	44 e6       	ldi	r20, 0x64	; 100
     f1e:	50 e0       	ldi	r21, 0x00	; 0
     f20:	20 e0       	ldi	r18, 0x00	; 0
     f22:	30 e0       	ldi	r19, 0x00	; 0
     f24:	01 e0       	ldi	r16, 0x01	; 1
     f26:	ee 24       	eor	r14, r14
     f28:	ff 24       	eor	r15, r15
     f2a:	cc 24       	eor	r12, r12
     f2c:	dd 24       	eor	r13, r13
     f2e:	aa 24       	eor	r10, r10
     f30:	bb 24       	eor	r11, r11
     f32:	0e 94 f1 0e 	call	0x1de2	; 0x1de2 <xTaskGenericCreate>

	vTaskStartScheduler();
     f36:	0e 94 ea 10 	call	0x21d4	; 0x21d4 <vTaskStartScheduler>
     f3a:	ff cf       	rjmp	.-2      	; 0xf3a <main+0x72>

00000f3c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
     f3c:	df 93       	push	r29
     f3e:	cf 93       	push	r28
     f40:	cd b7       	in	r28, 0x3d	; 61
     f42:	de b7       	in	r29, 0x3e	; 62
     f44:	28 97       	sbiw	r28, 0x08	; 8
     f46:	0f b6       	in	r0, 0x3f	; 63
     f48:	f8 94       	cli
     f4a:	de bf       	out	0x3e, r29	; 62
     f4c:	0f be       	out	0x3f, r0	; 63
     f4e:	cd bf       	out	0x3d, r28	; 61
     f50:	9c 83       	std	Y+4, r25	; 0x04
     f52:	8b 83       	std	Y+3, r24	; 0x03
     f54:	7e 83       	std	Y+6, r23	; 0x06
     f56:	6d 83       	std	Y+5, r22	; 0x05
     f58:	58 87       	std	Y+8, r21	; 0x08
     f5a:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     f5c:	eb 81       	ldd	r30, Y+3	; 0x03
     f5e:	fc 81       	ldd	r31, Y+4	; 0x04
     f60:	81 e1       	ldi	r24, 0x11	; 17
     f62:	80 83       	st	Z, r24
	pxTopOfStack--;
     f64:	8b 81       	ldd	r24, Y+3	; 0x03
     f66:	9c 81       	ldd	r25, Y+4	; 0x04
     f68:	01 97       	sbiw	r24, 0x01	; 1
     f6a:	9c 83       	std	Y+4, r25	; 0x04
     f6c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     f6e:	eb 81       	ldd	r30, Y+3	; 0x03
     f70:	fc 81       	ldd	r31, Y+4	; 0x04
     f72:	82 e2       	ldi	r24, 0x22	; 34
     f74:	80 83       	st	Z, r24
	pxTopOfStack--;
     f76:	8b 81       	ldd	r24, Y+3	; 0x03
     f78:	9c 81       	ldd	r25, Y+4	; 0x04
     f7a:	01 97       	sbiw	r24, 0x01	; 1
     f7c:	9c 83       	std	Y+4, r25	; 0x04
     f7e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     f80:	eb 81       	ldd	r30, Y+3	; 0x03
     f82:	fc 81       	ldd	r31, Y+4	; 0x04
     f84:	83 e3       	ldi	r24, 0x33	; 51
     f86:	80 83       	st	Z, r24
	pxTopOfStack--;
     f88:	8b 81       	ldd	r24, Y+3	; 0x03
     f8a:	9c 81       	ldd	r25, Y+4	; 0x04
     f8c:	01 97       	sbiw	r24, 0x01	; 1
     f8e:	9c 83       	std	Y+4, r25	; 0x04
     f90:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
     f92:	8d 81       	ldd	r24, Y+5	; 0x05
     f94:	9e 81       	ldd	r25, Y+6	; 0x06
     f96:	9a 83       	std	Y+2, r25	; 0x02
     f98:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     f9a:	89 81       	ldd	r24, Y+1	; 0x01
     f9c:	eb 81       	ldd	r30, Y+3	; 0x03
     f9e:	fc 81       	ldd	r31, Y+4	; 0x04
     fa0:	80 83       	st	Z, r24
	pxTopOfStack--;
     fa2:	8b 81       	ldd	r24, Y+3	; 0x03
     fa4:	9c 81       	ldd	r25, Y+4	; 0x04
     fa6:	01 97       	sbiw	r24, 0x01	; 1
     fa8:	9c 83       	std	Y+4, r25	; 0x04
     faa:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     fac:	89 81       	ldd	r24, Y+1	; 0x01
     fae:	9a 81       	ldd	r25, Y+2	; 0x02
     fb0:	89 2f       	mov	r24, r25
     fb2:	99 27       	eor	r25, r25
     fb4:	9a 83       	std	Y+2, r25	; 0x02
     fb6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     fb8:	89 81       	ldd	r24, Y+1	; 0x01
     fba:	eb 81       	ldd	r30, Y+3	; 0x03
     fbc:	fc 81       	ldd	r31, Y+4	; 0x04
     fbe:	80 83       	st	Z, r24
	pxTopOfStack--;
     fc0:	8b 81       	ldd	r24, Y+3	; 0x03
     fc2:	9c 81       	ldd	r25, Y+4	; 0x04
     fc4:	01 97       	sbiw	r24, 0x01	; 1
     fc6:	9c 83       	std	Y+4, r25	; 0x04
     fc8:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     fca:	eb 81       	ldd	r30, Y+3	; 0x03
     fcc:	fc 81       	ldd	r31, Y+4	; 0x04
     fce:	10 82       	st	Z, r1
	pxTopOfStack--;
     fd0:	8b 81       	ldd	r24, Y+3	; 0x03
     fd2:	9c 81       	ldd	r25, Y+4	; 0x04
     fd4:	01 97       	sbiw	r24, 0x01	; 1
     fd6:	9c 83       	std	Y+4, r25	; 0x04
     fd8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     fda:	eb 81       	ldd	r30, Y+3	; 0x03
     fdc:	fc 81       	ldd	r31, Y+4	; 0x04
     fde:	80 e8       	ldi	r24, 0x80	; 128
     fe0:	80 83       	st	Z, r24
	pxTopOfStack--;
     fe2:	8b 81       	ldd	r24, Y+3	; 0x03
     fe4:	9c 81       	ldd	r25, Y+4	; 0x04
     fe6:	01 97       	sbiw	r24, 0x01	; 1
     fe8:	9c 83       	std	Y+4, r25	; 0x04
     fea:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     fec:	eb 81       	ldd	r30, Y+3	; 0x03
     fee:	fc 81       	ldd	r31, Y+4	; 0x04
     ff0:	10 82       	st	Z, r1
	pxTopOfStack--;
     ff2:	8b 81       	ldd	r24, Y+3	; 0x03
     ff4:	9c 81       	ldd	r25, Y+4	; 0x04
     ff6:	01 97       	sbiw	r24, 0x01	; 1
     ff8:	9c 83       	std	Y+4, r25	; 0x04
     ffa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     ffc:	eb 81       	ldd	r30, Y+3	; 0x03
     ffe:	fc 81       	ldd	r31, Y+4	; 0x04
    1000:	82 e0       	ldi	r24, 0x02	; 2
    1002:	80 83       	st	Z, r24
	pxTopOfStack--;
    1004:	8b 81       	ldd	r24, Y+3	; 0x03
    1006:	9c 81       	ldd	r25, Y+4	; 0x04
    1008:	01 97       	sbiw	r24, 0x01	; 1
    100a:	9c 83       	std	Y+4, r25	; 0x04
    100c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    100e:	eb 81       	ldd	r30, Y+3	; 0x03
    1010:	fc 81       	ldd	r31, Y+4	; 0x04
    1012:	83 e0       	ldi	r24, 0x03	; 3
    1014:	80 83       	st	Z, r24
	pxTopOfStack--;
    1016:	8b 81       	ldd	r24, Y+3	; 0x03
    1018:	9c 81       	ldd	r25, Y+4	; 0x04
    101a:	01 97       	sbiw	r24, 0x01	; 1
    101c:	9c 83       	std	Y+4, r25	; 0x04
    101e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1020:	eb 81       	ldd	r30, Y+3	; 0x03
    1022:	fc 81       	ldd	r31, Y+4	; 0x04
    1024:	84 e0       	ldi	r24, 0x04	; 4
    1026:	80 83       	st	Z, r24
	pxTopOfStack--;
    1028:	8b 81       	ldd	r24, Y+3	; 0x03
    102a:	9c 81       	ldd	r25, Y+4	; 0x04
    102c:	01 97       	sbiw	r24, 0x01	; 1
    102e:	9c 83       	std	Y+4, r25	; 0x04
    1030:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1032:	eb 81       	ldd	r30, Y+3	; 0x03
    1034:	fc 81       	ldd	r31, Y+4	; 0x04
    1036:	85 e0       	ldi	r24, 0x05	; 5
    1038:	80 83       	st	Z, r24
	pxTopOfStack--;
    103a:	8b 81       	ldd	r24, Y+3	; 0x03
    103c:	9c 81       	ldd	r25, Y+4	; 0x04
    103e:	01 97       	sbiw	r24, 0x01	; 1
    1040:	9c 83       	std	Y+4, r25	; 0x04
    1042:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1044:	eb 81       	ldd	r30, Y+3	; 0x03
    1046:	fc 81       	ldd	r31, Y+4	; 0x04
    1048:	86 e0       	ldi	r24, 0x06	; 6
    104a:	80 83       	st	Z, r24
	pxTopOfStack--;
    104c:	8b 81       	ldd	r24, Y+3	; 0x03
    104e:	9c 81       	ldd	r25, Y+4	; 0x04
    1050:	01 97       	sbiw	r24, 0x01	; 1
    1052:	9c 83       	std	Y+4, r25	; 0x04
    1054:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1056:	eb 81       	ldd	r30, Y+3	; 0x03
    1058:	fc 81       	ldd	r31, Y+4	; 0x04
    105a:	87 e0       	ldi	r24, 0x07	; 7
    105c:	80 83       	st	Z, r24
	pxTopOfStack--;
    105e:	8b 81       	ldd	r24, Y+3	; 0x03
    1060:	9c 81       	ldd	r25, Y+4	; 0x04
    1062:	01 97       	sbiw	r24, 0x01	; 1
    1064:	9c 83       	std	Y+4, r25	; 0x04
    1066:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1068:	eb 81       	ldd	r30, Y+3	; 0x03
    106a:	fc 81       	ldd	r31, Y+4	; 0x04
    106c:	88 e0       	ldi	r24, 0x08	; 8
    106e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1070:	8b 81       	ldd	r24, Y+3	; 0x03
    1072:	9c 81       	ldd	r25, Y+4	; 0x04
    1074:	01 97       	sbiw	r24, 0x01	; 1
    1076:	9c 83       	std	Y+4, r25	; 0x04
    1078:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    107a:	eb 81       	ldd	r30, Y+3	; 0x03
    107c:	fc 81       	ldd	r31, Y+4	; 0x04
    107e:	89 e0       	ldi	r24, 0x09	; 9
    1080:	80 83       	st	Z, r24
	pxTopOfStack--;
    1082:	8b 81       	ldd	r24, Y+3	; 0x03
    1084:	9c 81       	ldd	r25, Y+4	; 0x04
    1086:	01 97       	sbiw	r24, 0x01	; 1
    1088:	9c 83       	std	Y+4, r25	; 0x04
    108a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    108c:	eb 81       	ldd	r30, Y+3	; 0x03
    108e:	fc 81       	ldd	r31, Y+4	; 0x04
    1090:	80 e1       	ldi	r24, 0x10	; 16
    1092:	80 83       	st	Z, r24
	pxTopOfStack--;
    1094:	8b 81       	ldd	r24, Y+3	; 0x03
    1096:	9c 81       	ldd	r25, Y+4	; 0x04
    1098:	01 97       	sbiw	r24, 0x01	; 1
    109a:	9c 83       	std	Y+4, r25	; 0x04
    109c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    109e:	eb 81       	ldd	r30, Y+3	; 0x03
    10a0:	fc 81       	ldd	r31, Y+4	; 0x04
    10a2:	81 e1       	ldi	r24, 0x11	; 17
    10a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    10a6:	8b 81       	ldd	r24, Y+3	; 0x03
    10a8:	9c 81       	ldd	r25, Y+4	; 0x04
    10aa:	01 97       	sbiw	r24, 0x01	; 1
    10ac:	9c 83       	std	Y+4, r25	; 0x04
    10ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    10b0:	eb 81       	ldd	r30, Y+3	; 0x03
    10b2:	fc 81       	ldd	r31, Y+4	; 0x04
    10b4:	82 e1       	ldi	r24, 0x12	; 18
    10b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    10b8:	8b 81       	ldd	r24, Y+3	; 0x03
    10ba:	9c 81       	ldd	r25, Y+4	; 0x04
    10bc:	01 97       	sbiw	r24, 0x01	; 1
    10be:	9c 83       	std	Y+4, r25	; 0x04
    10c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    10c2:	eb 81       	ldd	r30, Y+3	; 0x03
    10c4:	fc 81       	ldd	r31, Y+4	; 0x04
    10c6:	83 e1       	ldi	r24, 0x13	; 19
    10c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    10ca:	8b 81       	ldd	r24, Y+3	; 0x03
    10cc:	9c 81       	ldd	r25, Y+4	; 0x04
    10ce:	01 97       	sbiw	r24, 0x01	; 1
    10d0:	9c 83       	std	Y+4, r25	; 0x04
    10d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    10d4:	eb 81       	ldd	r30, Y+3	; 0x03
    10d6:	fc 81       	ldd	r31, Y+4	; 0x04
    10d8:	84 e1       	ldi	r24, 0x14	; 20
    10da:	80 83       	st	Z, r24
	pxTopOfStack--;
    10dc:	8b 81       	ldd	r24, Y+3	; 0x03
    10de:	9c 81       	ldd	r25, Y+4	; 0x04
    10e0:	01 97       	sbiw	r24, 0x01	; 1
    10e2:	9c 83       	std	Y+4, r25	; 0x04
    10e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    10e6:	eb 81       	ldd	r30, Y+3	; 0x03
    10e8:	fc 81       	ldd	r31, Y+4	; 0x04
    10ea:	85 e1       	ldi	r24, 0x15	; 21
    10ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    10ee:	8b 81       	ldd	r24, Y+3	; 0x03
    10f0:	9c 81       	ldd	r25, Y+4	; 0x04
    10f2:	01 97       	sbiw	r24, 0x01	; 1
    10f4:	9c 83       	std	Y+4, r25	; 0x04
    10f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    10f8:	eb 81       	ldd	r30, Y+3	; 0x03
    10fa:	fc 81       	ldd	r31, Y+4	; 0x04
    10fc:	86 e1       	ldi	r24, 0x16	; 22
    10fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1100:	8b 81       	ldd	r24, Y+3	; 0x03
    1102:	9c 81       	ldd	r25, Y+4	; 0x04
    1104:	01 97       	sbiw	r24, 0x01	; 1
    1106:	9c 83       	std	Y+4, r25	; 0x04
    1108:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    110a:	eb 81       	ldd	r30, Y+3	; 0x03
    110c:	fc 81       	ldd	r31, Y+4	; 0x04
    110e:	87 e1       	ldi	r24, 0x17	; 23
    1110:	80 83       	st	Z, r24
	pxTopOfStack--;
    1112:	8b 81       	ldd	r24, Y+3	; 0x03
    1114:	9c 81       	ldd	r25, Y+4	; 0x04
    1116:	01 97       	sbiw	r24, 0x01	; 1
    1118:	9c 83       	std	Y+4, r25	; 0x04
    111a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    111c:	eb 81       	ldd	r30, Y+3	; 0x03
    111e:	fc 81       	ldd	r31, Y+4	; 0x04
    1120:	88 e1       	ldi	r24, 0x18	; 24
    1122:	80 83       	st	Z, r24
	pxTopOfStack--;
    1124:	8b 81       	ldd	r24, Y+3	; 0x03
    1126:	9c 81       	ldd	r25, Y+4	; 0x04
    1128:	01 97       	sbiw	r24, 0x01	; 1
    112a:	9c 83       	std	Y+4, r25	; 0x04
    112c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    112e:	eb 81       	ldd	r30, Y+3	; 0x03
    1130:	fc 81       	ldd	r31, Y+4	; 0x04
    1132:	89 e1       	ldi	r24, 0x19	; 25
    1134:	80 83       	st	Z, r24
	pxTopOfStack--;
    1136:	8b 81       	ldd	r24, Y+3	; 0x03
    1138:	9c 81       	ldd	r25, Y+4	; 0x04
    113a:	01 97       	sbiw	r24, 0x01	; 1
    113c:	9c 83       	std	Y+4, r25	; 0x04
    113e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1140:	eb 81       	ldd	r30, Y+3	; 0x03
    1142:	fc 81       	ldd	r31, Y+4	; 0x04
    1144:	80 e2       	ldi	r24, 0x20	; 32
    1146:	80 83       	st	Z, r24
	pxTopOfStack--;
    1148:	8b 81       	ldd	r24, Y+3	; 0x03
    114a:	9c 81       	ldd	r25, Y+4	; 0x04
    114c:	01 97       	sbiw	r24, 0x01	; 1
    114e:	9c 83       	std	Y+4, r25	; 0x04
    1150:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1152:	eb 81       	ldd	r30, Y+3	; 0x03
    1154:	fc 81       	ldd	r31, Y+4	; 0x04
    1156:	81 e2       	ldi	r24, 0x21	; 33
    1158:	80 83       	st	Z, r24
	pxTopOfStack--;
    115a:	8b 81       	ldd	r24, Y+3	; 0x03
    115c:	9c 81       	ldd	r25, Y+4	; 0x04
    115e:	01 97       	sbiw	r24, 0x01	; 1
    1160:	9c 83       	std	Y+4, r25	; 0x04
    1162:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1164:	eb 81       	ldd	r30, Y+3	; 0x03
    1166:	fc 81       	ldd	r31, Y+4	; 0x04
    1168:	82 e2       	ldi	r24, 0x22	; 34
    116a:	80 83       	st	Z, r24
	pxTopOfStack--;
    116c:	8b 81       	ldd	r24, Y+3	; 0x03
    116e:	9c 81       	ldd	r25, Y+4	; 0x04
    1170:	01 97       	sbiw	r24, 0x01	; 1
    1172:	9c 83       	std	Y+4, r25	; 0x04
    1174:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1176:	eb 81       	ldd	r30, Y+3	; 0x03
    1178:	fc 81       	ldd	r31, Y+4	; 0x04
    117a:	83 e2       	ldi	r24, 0x23	; 35
    117c:	80 83       	st	Z, r24
	pxTopOfStack--;
    117e:	8b 81       	ldd	r24, Y+3	; 0x03
    1180:	9c 81       	ldd	r25, Y+4	; 0x04
    1182:	01 97       	sbiw	r24, 0x01	; 1
    1184:	9c 83       	std	Y+4, r25	; 0x04
    1186:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    1188:	8f 81       	ldd	r24, Y+7	; 0x07
    118a:	98 85       	ldd	r25, Y+8	; 0x08
    118c:	9a 83       	std	Y+2, r25	; 0x02
    118e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1190:	89 81       	ldd	r24, Y+1	; 0x01
    1192:	eb 81       	ldd	r30, Y+3	; 0x03
    1194:	fc 81       	ldd	r31, Y+4	; 0x04
    1196:	80 83       	st	Z, r24
	pxTopOfStack--;
    1198:	8b 81       	ldd	r24, Y+3	; 0x03
    119a:	9c 81       	ldd	r25, Y+4	; 0x04
    119c:	01 97       	sbiw	r24, 0x01	; 1
    119e:	9c 83       	std	Y+4, r25	; 0x04
    11a0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    11a2:	89 81       	ldd	r24, Y+1	; 0x01
    11a4:	9a 81       	ldd	r25, Y+2	; 0x02
    11a6:	89 2f       	mov	r24, r25
    11a8:	99 27       	eor	r25, r25
    11aa:	9a 83       	std	Y+2, r25	; 0x02
    11ac:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    11ae:	89 81       	ldd	r24, Y+1	; 0x01
    11b0:	eb 81       	ldd	r30, Y+3	; 0x03
    11b2:	fc 81       	ldd	r31, Y+4	; 0x04
    11b4:	80 83       	st	Z, r24
	pxTopOfStack--;
    11b6:	8b 81       	ldd	r24, Y+3	; 0x03
    11b8:	9c 81       	ldd	r25, Y+4	; 0x04
    11ba:	01 97       	sbiw	r24, 0x01	; 1
    11bc:	9c 83       	std	Y+4, r25	; 0x04
    11be:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    11c0:	eb 81       	ldd	r30, Y+3	; 0x03
    11c2:	fc 81       	ldd	r31, Y+4	; 0x04
    11c4:	86 e2       	ldi	r24, 0x26	; 38
    11c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    11c8:	8b 81       	ldd	r24, Y+3	; 0x03
    11ca:	9c 81       	ldd	r25, Y+4	; 0x04
    11cc:	01 97       	sbiw	r24, 0x01	; 1
    11ce:	9c 83       	std	Y+4, r25	; 0x04
    11d0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    11d2:	eb 81       	ldd	r30, Y+3	; 0x03
    11d4:	fc 81       	ldd	r31, Y+4	; 0x04
    11d6:	87 e2       	ldi	r24, 0x27	; 39
    11d8:	80 83       	st	Z, r24
	pxTopOfStack--;
    11da:	8b 81       	ldd	r24, Y+3	; 0x03
    11dc:	9c 81       	ldd	r25, Y+4	; 0x04
    11de:	01 97       	sbiw	r24, 0x01	; 1
    11e0:	9c 83       	std	Y+4, r25	; 0x04
    11e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    11e4:	eb 81       	ldd	r30, Y+3	; 0x03
    11e6:	fc 81       	ldd	r31, Y+4	; 0x04
    11e8:	88 e2       	ldi	r24, 0x28	; 40
    11ea:	80 83       	st	Z, r24
	pxTopOfStack--;
    11ec:	8b 81       	ldd	r24, Y+3	; 0x03
    11ee:	9c 81       	ldd	r25, Y+4	; 0x04
    11f0:	01 97       	sbiw	r24, 0x01	; 1
    11f2:	9c 83       	std	Y+4, r25	; 0x04
    11f4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    11f6:	eb 81       	ldd	r30, Y+3	; 0x03
    11f8:	fc 81       	ldd	r31, Y+4	; 0x04
    11fa:	89 e2       	ldi	r24, 0x29	; 41
    11fc:	80 83       	st	Z, r24
	pxTopOfStack--;
    11fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1200:	9c 81       	ldd	r25, Y+4	; 0x04
    1202:	01 97       	sbiw	r24, 0x01	; 1
    1204:	9c 83       	std	Y+4, r25	; 0x04
    1206:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1208:	eb 81       	ldd	r30, Y+3	; 0x03
    120a:	fc 81       	ldd	r31, Y+4	; 0x04
    120c:	80 e3       	ldi	r24, 0x30	; 48
    120e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1210:	8b 81       	ldd	r24, Y+3	; 0x03
    1212:	9c 81       	ldd	r25, Y+4	; 0x04
    1214:	01 97       	sbiw	r24, 0x01	; 1
    1216:	9c 83       	std	Y+4, r25	; 0x04
    1218:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    121a:	eb 81       	ldd	r30, Y+3	; 0x03
    121c:	fc 81       	ldd	r31, Y+4	; 0x04
    121e:	81 e3       	ldi	r24, 0x31	; 49
    1220:	80 83       	st	Z, r24
	pxTopOfStack--;
    1222:	8b 81       	ldd	r24, Y+3	; 0x03
    1224:	9c 81       	ldd	r25, Y+4	; 0x04
    1226:	01 97       	sbiw	r24, 0x01	; 1
    1228:	9c 83       	std	Y+4, r25	; 0x04
    122a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    122c:	8b 81       	ldd	r24, Y+3	; 0x03
    122e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1230:	28 96       	adiw	r28, 0x08	; 8
    1232:	0f b6       	in	r0, 0x3f	; 63
    1234:	f8 94       	cli
    1236:	de bf       	out	0x3e, r29	; 62
    1238:	0f be       	out	0x3f, r0	; 63
    123a:	cd bf       	out	0x3d, r28	; 61
    123c:	cf 91       	pop	r28
    123e:	df 91       	pop	r29
    1240:	08 95       	ret

00001242 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    1242:	df 93       	push	r29
    1244:	cf 93       	push	r28
    1246:	cd b7       	in	r28, 0x3d	; 61
    1248:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    124a:	0e 94 11 0a 	call	0x1422	; 0x1422 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    124e:	a0 91 dc 03 	lds	r26, 0x03DC
    1252:	b0 91 dd 03 	lds	r27, 0x03DD
    1256:	cd 91       	ld	r28, X+
    1258:	cd bf       	out	0x3d, r28	; 61
    125a:	dd 91       	ld	r29, X+
    125c:	de bf       	out	0x3e, r29	; 62
    125e:	ff 91       	pop	r31
    1260:	ef 91       	pop	r30
    1262:	df 91       	pop	r29
    1264:	cf 91       	pop	r28
    1266:	bf 91       	pop	r27
    1268:	af 91       	pop	r26
    126a:	9f 91       	pop	r25
    126c:	8f 91       	pop	r24
    126e:	7f 91       	pop	r23
    1270:	6f 91       	pop	r22
    1272:	5f 91       	pop	r21
    1274:	4f 91       	pop	r20
    1276:	3f 91       	pop	r19
    1278:	2f 91       	pop	r18
    127a:	1f 91       	pop	r17
    127c:	0f 91       	pop	r16
    127e:	ff 90       	pop	r15
    1280:	ef 90       	pop	r14
    1282:	df 90       	pop	r13
    1284:	cf 90       	pop	r12
    1286:	bf 90       	pop	r11
    1288:	af 90       	pop	r10
    128a:	9f 90       	pop	r9
    128c:	8f 90       	pop	r8
    128e:	7f 90       	pop	r7
    1290:	6f 90       	pop	r6
    1292:	5f 90       	pop	r5
    1294:	4f 90       	pop	r4
    1296:	3f 90       	pop	r3
    1298:	2f 90       	pop	r2
    129a:	1f 90       	pop	r1
    129c:	0f 90       	pop	r0
    129e:	0f be       	out	0x3f, r0	; 63
    12a0:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    12a2:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    12a4:	81 e0       	ldi	r24, 0x01	; 1
}
    12a6:	cf 91       	pop	r28
    12a8:	df 91       	pop	r29
    12aa:	08 95       	ret

000012ac <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    12ac:	df 93       	push	r29
    12ae:	cf 93       	push	r28
    12b0:	cd b7       	in	r28, 0x3d	; 61
    12b2:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    12b4:	cf 91       	pop	r28
    12b6:	df 91       	pop	r29
    12b8:	08 95       	ret

000012ba <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    12ba:	0f 92       	push	r0
    12bc:	0f b6       	in	r0, 0x3f	; 63
    12be:	f8 94       	cli
    12c0:	0f 92       	push	r0
    12c2:	1f 92       	push	r1
    12c4:	11 24       	eor	r1, r1
    12c6:	2f 92       	push	r2
    12c8:	3f 92       	push	r3
    12ca:	4f 92       	push	r4
    12cc:	5f 92       	push	r5
    12ce:	6f 92       	push	r6
    12d0:	7f 92       	push	r7
    12d2:	8f 92       	push	r8
    12d4:	9f 92       	push	r9
    12d6:	af 92       	push	r10
    12d8:	bf 92       	push	r11
    12da:	cf 92       	push	r12
    12dc:	df 92       	push	r13
    12de:	ef 92       	push	r14
    12e0:	ff 92       	push	r15
    12e2:	0f 93       	push	r16
    12e4:	1f 93       	push	r17
    12e6:	2f 93       	push	r18
    12e8:	3f 93       	push	r19
    12ea:	4f 93       	push	r20
    12ec:	5f 93       	push	r21
    12ee:	6f 93       	push	r22
    12f0:	7f 93       	push	r23
    12f2:	8f 93       	push	r24
    12f4:	9f 93       	push	r25
    12f6:	af 93       	push	r26
    12f8:	bf 93       	push	r27
    12fa:	cf 93       	push	r28
    12fc:	df 93       	push	r29
    12fe:	ef 93       	push	r30
    1300:	ff 93       	push	r31
    1302:	a0 91 dc 03 	lds	r26, 0x03DC
    1306:	b0 91 dd 03 	lds	r27, 0x03DD
    130a:	0d b6       	in	r0, 0x3d	; 61
    130c:	0d 92       	st	X+, r0
    130e:	0e b6       	in	r0, 0x3e	; 62
    1310:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1312:	0e 94 cd 12 	call	0x259a	; 0x259a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1316:	a0 91 dc 03 	lds	r26, 0x03DC
    131a:	b0 91 dd 03 	lds	r27, 0x03DD
    131e:	cd 91       	ld	r28, X+
    1320:	cd bf       	out	0x3d, r28	; 61
    1322:	dd 91       	ld	r29, X+
    1324:	de bf       	out	0x3e, r29	; 62
    1326:	ff 91       	pop	r31
    1328:	ef 91       	pop	r30
    132a:	df 91       	pop	r29
    132c:	cf 91       	pop	r28
    132e:	bf 91       	pop	r27
    1330:	af 91       	pop	r26
    1332:	9f 91       	pop	r25
    1334:	8f 91       	pop	r24
    1336:	7f 91       	pop	r23
    1338:	6f 91       	pop	r22
    133a:	5f 91       	pop	r21
    133c:	4f 91       	pop	r20
    133e:	3f 91       	pop	r19
    1340:	2f 91       	pop	r18
    1342:	1f 91       	pop	r17
    1344:	0f 91       	pop	r16
    1346:	ff 90       	pop	r15
    1348:	ef 90       	pop	r14
    134a:	df 90       	pop	r13
    134c:	cf 90       	pop	r12
    134e:	bf 90       	pop	r11
    1350:	af 90       	pop	r10
    1352:	9f 90       	pop	r9
    1354:	8f 90       	pop	r8
    1356:	7f 90       	pop	r7
    1358:	6f 90       	pop	r6
    135a:	5f 90       	pop	r5
    135c:	4f 90       	pop	r4
    135e:	3f 90       	pop	r3
    1360:	2f 90       	pop	r2
    1362:	1f 90       	pop	r1
    1364:	0f 90       	pop	r0
    1366:	0f be       	out	0x3f, r0	; 63
    1368:	0f 90       	pop	r0

	asm volatile ( "ret" );
    136a:	08 95       	ret

0000136c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    136c:	0f 92       	push	r0
    136e:	0f b6       	in	r0, 0x3f	; 63
    1370:	f8 94       	cli
    1372:	0f 92       	push	r0
    1374:	1f 92       	push	r1
    1376:	11 24       	eor	r1, r1
    1378:	2f 92       	push	r2
    137a:	3f 92       	push	r3
    137c:	4f 92       	push	r4
    137e:	5f 92       	push	r5
    1380:	6f 92       	push	r6
    1382:	7f 92       	push	r7
    1384:	8f 92       	push	r8
    1386:	9f 92       	push	r9
    1388:	af 92       	push	r10
    138a:	bf 92       	push	r11
    138c:	cf 92       	push	r12
    138e:	df 92       	push	r13
    1390:	ef 92       	push	r14
    1392:	ff 92       	push	r15
    1394:	0f 93       	push	r16
    1396:	1f 93       	push	r17
    1398:	2f 93       	push	r18
    139a:	3f 93       	push	r19
    139c:	4f 93       	push	r20
    139e:	5f 93       	push	r21
    13a0:	6f 93       	push	r22
    13a2:	7f 93       	push	r23
    13a4:	8f 93       	push	r24
    13a6:	9f 93       	push	r25
    13a8:	af 93       	push	r26
    13aa:	bf 93       	push	r27
    13ac:	cf 93       	push	r28
    13ae:	df 93       	push	r29
    13b0:	ef 93       	push	r30
    13b2:	ff 93       	push	r31
    13b4:	a0 91 dc 03 	lds	r26, 0x03DC
    13b8:	b0 91 dd 03 	lds	r27, 0x03DD
    13bc:	0d b6       	in	r0, 0x3d	; 61
    13be:	0d 92       	st	X+, r0
    13c0:	0e b6       	in	r0, 0x3e	; 62
    13c2:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    13c4:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <vTaskIncrementTick>
	vTaskSwitchContext();
    13c8:	0e 94 cd 12 	call	0x259a	; 0x259a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    13cc:	a0 91 dc 03 	lds	r26, 0x03DC
    13d0:	b0 91 dd 03 	lds	r27, 0x03DD
    13d4:	cd 91       	ld	r28, X+
    13d6:	cd bf       	out	0x3d, r28	; 61
    13d8:	dd 91       	ld	r29, X+
    13da:	de bf       	out	0x3e, r29	; 62
    13dc:	ff 91       	pop	r31
    13de:	ef 91       	pop	r30
    13e0:	df 91       	pop	r29
    13e2:	cf 91       	pop	r28
    13e4:	bf 91       	pop	r27
    13e6:	af 91       	pop	r26
    13e8:	9f 91       	pop	r25
    13ea:	8f 91       	pop	r24
    13ec:	7f 91       	pop	r23
    13ee:	6f 91       	pop	r22
    13f0:	5f 91       	pop	r21
    13f2:	4f 91       	pop	r20
    13f4:	3f 91       	pop	r19
    13f6:	2f 91       	pop	r18
    13f8:	1f 91       	pop	r17
    13fa:	0f 91       	pop	r16
    13fc:	ff 90       	pop	r15
    13fe:	ef 90       	pop	r14
    1400:	df 90       	pop	r13
    1402:	cf 90       	pop	r12
    1404:	bf 90       	pop	r11
    1406:	af 90       	pop	r10
    1408:	9f 90       	pop	r9
    140a:	8f 90       	pop	r8
    140c:	7f 90       	pop	r7
    140e:	6f 90       	pop	r6
    1410:	5f 90       	pop	r5
    1412:	4f 90       	pop	r4
    1414:	3f 90       	pop	r3
    1416:	2f 90       	pop	r2
    1418:	1f 90       	pop	r1
    141a:	0f 90       	pop	r0
    141c:	0f be       	out	0x3f, r0	; 63
    141e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1420:	08 95       	ret

00001422 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1422:	df 93       	push	r29
    1424:	cf 93       	push	r28
    1426:	00 d0       	rcall	.+0      	; 0x1428 <prvSetupTimerInterrupt+0x6>
    1428:	00 d0       	rcall	.+0      	; 0x142a <prvSetupTimerInterrupt+0x8>
    142a:	00 d0       	rcall	.+0      	; 0x142c <prvSetupTimerInterrupt+0xa>
    142c:	cd b7       	in	r28, 0x3d	; 61
    142e:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1430:	80 e4       	ldi	r24, 0x40	; 64
    1432:	9f e1       	ldi	r25, 0x1F	; 31
    1434:	a0 e0       	ldi	r26, 0x00	; 0
    1436:	b0 e0       	ldi	r27, 0x00	; 0
    1438:	8b 83       	std	Y+3, r24	; 0x03
    143a:	9c 83       	std	Y+4, r25	; 0x04
    143c:	ad 83       	std	Y+5, r26	; 0x05
    143e:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1440:	8b 81       	ldd	r24, Y+3	; 0x03
    1442:	9c 81       	ldd	r25, Y+4	; 0x04
    1444:	ad 81       	ldd	r26, Y+5	; 0x05
    1446:	be 81       	ldd	r27, Y+6	; 0x06
    1448:	68 94       	set
    144a:	15 f8       	bld	r1, 5
    144c:	b6 95       	lsr	r27
    144e:	a7 95       	ror	r26
    1450:	97 95       	ror	r25
    1452:	87 95       	ror	r24
    1454:	16 94       	lsr	r1
    1456:	d1 f7       	brne	.-12     	; 0x144c <prvSetupTimerInterrupt+0x2a>
    1458:	8b 83       	std	Y+3, r24	; 0x03
    145a:	9c 83       	std	Y+4, r25	; 0x04
    145c:	ad 83       	std	Y+5, r26	; 0x05
    145e:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    1460:	8b 81       	ldd	r24, Y+3	; 0x03
    1462:	9c 81       	ldd	r25, Y+4	; 0x04
    1464:	ad 81       	ldd	r26, Y+5	; 0x05
    1466:	be 81       	ldd	r27, Y+6	; 0x06
    1468:	01 97       	sbiw	r24, 0x01	; 1
    146a:	a1 09       	sbc	r26, r1
    146c:	b1 09       	sbc	r27, r1
    146e:	8b 83       	std	Y+3, r24	; 0x03
    1470:	9c 83       	std	Y+4, r25	; 0x04
    1472:	ad 83       	std	Y+5, r26	; 0x05
    1474:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1476:	8b 81       	ldd	r24, Y+3	; 0x03
    1478:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    147a:	8b 81       	ldd	r24, Y+3	; 0x03
    147c:	9c 81       	ldd	r25, Y+4	; 0x04
    147e:	ad 81       	ldd	r26, Y+5	; 0x05
    1480:	be 81       	ldd	r27, Y+6	; 0x06
    1482:	89 2f       	mov	r24, r25
    1484:	9a 2f       	mov	r25, r26
    1486:	ab 2f       	mov	r26, r27
    1488:	bb 27       	eor	r27, r27
    148a:	8b 83       	std	Y+3, r24	; 0x03
    148c:	9c 83       	std	Y+4, r25	; 0x04
    148e:	ad 83       	std	Y+5, r26	; 0x05
    1490:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1492:	8b 81       	ldd	r24, Y+3	; 0x03
    1494:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1496:	eb e4       	ldi	r30, 0x4B	; 75
    1498:	f0 e0       	ldi	r31, 0x00	; 0
    149a:	8a 81       	ldd	r24, Y+2	; 0x02
    149c:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    149e:	ea e4       	ldi	r30, 0x4A	; 74
    14a0:	f0 e0       	ldi	r31, 0x00	; 0
    14a2:	89 81       	ldd	r24, Y+1	; 0x01
    14a4:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    14a6:	8b e0       	ldi	r24, 0x0B	; 11
    14a8:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    14aa:	ee e4       	ldi	r30, 0x4E	; 78
    14ac:	f0 e0       	ldi	r31, 0x00	; 0
    14ae:	89 81       	ldd	r24, Y+1	; 0x01
    14b0:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    14b2:	e9 e5       	ldi	r30, 0x59	; 89
    14b4:	f0 e0       	ldi	r31, 0x00	; 0
    14b6:	80 81       	ld	r24, Z
    14b8:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    14ba:	89 81       	ldd	r24, Y+1	; 0x01
    14bc:	80 61       	ori	r24, 0x10	; 16
    14be:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    14c0:	e9 e5       	ldi	r30, 0x59	; 89
    14c2:	f0 e0       	ldi	r31, 0x00	; 0
    14c4:	89 81       	ldd	r24, Y+1	; 0x01
    14c6:	80 83       	st	Z, r24
}
    14c8:	26 96       	adiw	r28, 0x06	; 6
    14ca:	0f b6       	in	r0, 0x3f	; 63
    14cc:	f8 94       	cli
    14ce:	de bf       	out	0x3e, r29	; 62
    14d0:	0f be       	out	0x3f, r0	; 63
    14d2:	cd bf       	out	0x3d, r28	; 61
    14d4:	cf 91       	pop	r28
    14d6:	df 91       	pop	r29
    14d8:	08 95       	ret

000014da <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    14da:	0e 94 b6 09 	call	0x136c	; 0x136c <vPortYieldFromTick>
		asm volatile ( "reti" );
    14de:	18 95       	reti

000014e0 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    14e0:	df 93       	push	r29
    14e2:	cf 93       	push	r28
    14e4:	cd b7       	in	r28, 0x3d	; 61
    14e6:	de b7       	in	r29, 0x3e	; 62
    14e8:	28 97       	sbiw	r28, 0x08	; 8
    14ea:	0f b6       	in	r0, 0x3f	; 63
    14ec:	f8 94       	cli
    14ee:	de bf       	out	0x3e, r29	; 62
    14f0:	0f be       	out	0x3f, r0	; 63
    14f2:	cd bf       	out	0x3d, r28	; 61
    14f4:	8f 83       	std	Y+7, r24	; 0x07
    14f6:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    14f8:	1a 82       	std	Y+2, r1	; 0x02
    14fa:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    14fc:	8f 81       	ldd	r24, Y+7	; 0x07
    14fe:	88 23       	and	r24, r24
    1500:	09 f4       	brne	.+2      	; 0x1504 <xQueueCreate+0x24>
    1502:	8c c0       	rjmp	.+280    	; 0x161c <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1504:	8f e1       	ldi	r24, 0x1F	; 31
    1506:	90 e0       	ldi	r25, 0x00	; 0
    1508:	0e 94 9d 05 	call	0xb3a	; 0xb3a <pvPortMalloc>
    150c:	9e 83       	std	Y+6, r25	; 0x06
    150e:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1510:	8d 81       	ldd	r24, Y+5	; 0x05
    1512:	9e 81       	ldd	r25, Y+6	; 0x06
    1514:	00 97       	sbiw	r24, 0x00	; 0
    1516:	09 f4       	brne	.+2      	; 0x151a <xQueueCreate+0x3a>
    1518:	81 c0       	rjmp	.+258    	; 0x161c <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    151a:	8f 81       	ldd	r24, Y+7	; 0x07
    151c:	28 2f       	mov	r18, r24
    151e:	30 e0       	ldi	r19, 0x00	; 0
    1520:	88 85       	ldd	r24, Y+8	; 0x08
    1522:	88 2f       	mov	r24, r24
    1524:	90 e0       	ldi	r25, 0x00	; 0
    1526:	ac 01       	movw	r20, r24
    1528:	24 9f       	mul	r18, r20
    152a:	c0 01       	movw	r24, r0
    152c:	25 9f       	mul	r18, r21
    152e:	90 0d       	add	r25, r0
    1530:	34 9f       	mul	r19, r20
    1532:	90 0d       	add	r25, r0
    1534:	11 24       	eor	r1, r1
    1536:	01 96       	adiw	r24, 0x01	; 1
    1538:	9c 83       	std	Y+4, r25	; 0x04
    153a:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    153c:	8b 81       	ldd	r24, Y+3	; 0x03
    153e:	9c 81       	ldd	r25, Y+4	; 0x04
    1540:	0e 94 9d 05 	call	0xb3a	; 0xb3a <pvPortMalloc>
    1544:	ed 81       	ldd	r30, Y+5	; 0x05
    1546:	fe 81       	ldd	r31, Y+6	; 0x06
    1548:	91 83       	std	Z+1, r25	; 0x01
    154a:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    154c:	ed 81       	ldd	r30, Y+5	; 0x05
    154e:	fe 81       	ldd	r31, Y+6	; 0x06
    1550:	80 81       	ld	r24, Z
    1552:	91 81       	ldd	r25, Z+1	; 0x01
    1554:	00 97       	sbiw	r24, 0x00	; 0
    1556:	09 f4       	brne	.+2      	; 0x155a <xQueueCreate+0x7a>
    1558:	5d c0       	rjmp	.+186    	; 0x1614 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    155a:	ed 81       	ldd	r30, Y+5	; 0x05
    155c:	fe 81       	ldd	r31, Y+6	; 0x06
    155e:	40 81       	ld	r20, Z
    1560:	51 81       	ldd	r21, Z+1	; 0x01
    1562:	8f 81       	ldd	r24, Y+7	; 0x07
    1564:	28 2f       	mov	r18, r24
    1566:	30 e0       	ldi	r19, 0x00	; 0
    1568:	88 85       	ldd	r24, Y+8	; 0x08
    156a:	88 2f       	mov	r24, r24
    156c:	90 e0       	ldi	r25, 0x00	; 0
    156e:	bc 01       	movw	r22, r24
    1570:	26 9f       	mul	r18, r22
    1572:	c0 01       	movw	r24, r0
    1574:	27 9f       	mul	r18, r23
    1576:	90 0d       	add	r25, r0
    1578:	36 9f       	mul	r19, r22
    157a:	90 0d       	add	r25, r0
    157c:	11 24       	eor	r1, r1
    157e:	84 0f       	add	r24, r20
    1580:	95 1f       	adc	r25, r21
    1582:	ed 81       	ldd	r30, Y+5	; 0x05
    1584:	fe 81       	ldd	r31, Y+6	; 0x06
    1586:	93 83       	std	Z+3, r25	; 0x03
    1588:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    158a:	ed 81       	ldd	r30, Y+5	; 0x05
    158c:	fe 81       	ldd	r31, Y+6	; 0x06
    158e:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1590:	ed 81       	ldd	r30, Y+5	; 0x05
    1592:	fe 81       	ldd	r31, Y+6	; 0x06
    1594:	80 81       	ld	r24, Z
    1596:	91 81       	ldd	r25, Z+1	; 0x01
    1598:	ed 81       	ldd	r30, Y+5	; 0x05
    159a:	fe 81       	ldd	r31, Y+6	; 0x06
    159c:	95 83       	std	Z+5, r25	; 0x05
    159e:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    15a0:	ed 81       	ldd	r30, Y+5	; 0x05
    15a2:	fe 81       	ldd	r31, Y+6	; 0x06
    15a4:	40 81       	ld	r20, Z
    15a6:	51 81       	ldd	r21, Z+1	; 0x01
    15a8:	8f 81       	ldd	r24, Y+7	; 0x07
    15aa:	88 2f       	mov	r24, r24
    15ac:	90 e0       	ldi	r25, 0x00	; 0
    15ae:	9c 01       	movw	r18, r24
    15b0:	21 50       	subi	r18, 0x01	; 1
    15b2:	30 40       	sbci	r19, 0x00	; 0
    15b4:	88 85       	ldd	r24, Y+8	; 0x08
    15b6:	88 2f       	mov	r24, r24
    15b8:	90 e0       	ldi	r25, 0x00	; 0
    15ba:	bc 01       	movw	r22, r24
    15bc:	26 9f       	mul	r18, r22
    15be:	c0 01       	movw	r24, r0
    15c0:	27 9f       	mul	r18, r23
    15c2:	90 0d       	add	r25, r0
    15c4:	36 9f       	mul	r19, r22
    15c6:	90 0d       	add	r25, r0
    15c8:	11 24       	eor	r1, r1
    15ca:	84 0f       	add	r24, r20
    15cc:	95 1f       	adc	r25, r21
    15ce:	ed 81       	ldd	r30, Y+5	; 0x05
    15d0:	fe 81       	ldd	r31, Y+6	; 0x06
    15d2:	97 83       	std	Z+7, r25	; 0x07
    15d4:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    15d6:	ed 81       	ldd	r30, Y+5	; 0x05
    15d8:	fe 81       	ldd	r31, Y+6	; 0x06
    15da:	8f 81       	ldd	r24, Y+7	; 0x07
    15dc:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    15de:	ed 81       	ldd	r30, Y+5	; 0x05
    15e0:	fe 81       	ldd	r31, Y+6	; 0x06
    15e2:	88 85       	ldd	r24, Y+8	; 0x08
    15e4:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    15e6:	ed 81       	ldd	r30, Y+5	; 0x05
    15e8:	fe 81       	ldd	r31, Y+6	; 0x06
    15ea:	8f ef       	ldi	r24, 0xFF	; 255
    15ec:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    15ee:	ed 81       	ldd	r30, Y+5	; 0x05
    15f0:	fe 81       	ldd	r31, Y+6	; 0x06
    15f2:	8f ef       	ldi	r24, 0xFF	; 255
    15f4:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    15f6:	8d 81       	ldd	r24, Y+5	; 0x05
    15f8:	9e 81       	ldd	r25, Y+6	; 0x06
    15fa:	08 96       	adiw	r24, 0x08	; 8
    15fc:	0e 94 09 06 	call	0xc12	; 0xc12 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1600:	8d 81       	ldd	r24, Y+5	; 0x05
    1602:	9e 81       	ldd	r25, Y+6	; 0x06
    1604:	41 96       	adiw	r24, 0x11	; 17
    1606:	0e 94 09 06 	call	0xc12	; 0xc12 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    160a:	8d 81       	ldd	r24, Y+5	; 0x05
    160c:	9e 81       	ldd	r25, Y+6	; 0x06
    160e:	9a 83       	std	Y+2, r25	; 0x02
    1610:	89 83       	std	Y+1, r24	; 0x01
    1612:	04 c0       	rjmp	.+8      	; 0x161c <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1614:	8d 81       	ldd	r24, Y+5	; 0x05
    1616:	9e 81       	ldd	r25, Y+6	; 0x06
    1618:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    161c:	89 81       	ldd	r24, Y+1	; 0x01
    161e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1620:	28 96       	adiw	r28, 0x08	; 8
    1622:	0f b6       	in	r0, 0x3f	; 63
    1624:	f8 94       	cli
    1626:	de bf       	out	0x3e, r29	; 62
    1628:	0f be       	out	0x3f, r0	; 63
    162a:	cd bf       	out	0x3d, r28	; 61
    162c:	cf 91       	pop	r28
    162e:	df 91       	pop	r29
    1630:	08 95       	ret

00001632 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1632:	df 93       	push	r29
    1634:	cf 93       	push	r28
    1636:	cd b7       	in	r28, 0x3d	; 61
    1638:	de b7       	in	r29, 0x3e	; 62
    163a:	2c 97       	sbiw	r28, 0x0c	; 12
    163c:	0f b6       	in	r0, 0x3f	; 63
    163e:	f8 94       	cli
    1640:	de bf       	out	0x3e, r29	; 62
    1642:	0f be       	out	0x3f, r0	; 63
    1644:	cd bf       	out	0x3d, r28	; 61
    1646:	9e 83       	std	Y+6, r25	; 0x06
    1648:	8d 83       	std	Y+5, r24	; 0x05
    164a:	78 87       	std	Y+8, r23	; 0x08
    164c:	6f 83       	std	Y+7, r22	; 0x07
    164e:	5a 87       	std	Y+10, r21	; 0x0a
    1650:	49 87       	std	Y+9, r20	; 0x09
    1652:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1654:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1656:	0f b6       	in	r0, 0x3f	; 63
    1658:	f8 94       	cli
    165a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    165c:	ed 81       	ldd	r30, Y+5	; 0x05
    165e:	fe 81       	ldd	r31, Y+6	; 0x06
    1660:	92 8d       	ldd	r25, Z+26	; 0x1a
    1662:	ed 81       	ldd	r30, Y+5	; 0x05
    1664:	fe 81       	ldd	r31, Y+6	; 0x06
    1666:	83 8d       	ldd	r24, Z+27	; 0x1b
    1668:	98 17       	cp	r25, r24
    166a:	d8 f4       	brcc	.+54     	; 0x16a2 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    166c:	8d 81       	ldd	r24, Y+5	; 0x05
    166e:	9e 81       	ldd	r25, Y+6	; 0x06
    1670:	2f 81       	ldd	r18, Y+7	; 0x07
    1672:	38 85       	ldd	r19, Y+8	; 0x08
    1674:	b9 01       	movw	r22, r18
    1676:	4b 85       	ldd	r20, Y+11	; 0x0b
    1678:	0e 94 54 0d 	call	0x1aa8	; 0x1aa8 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    167c:	ed 81       	ldd	r30, Y+5	; 0x05
    167e:	fe 81       	ldd	r31, Y+6	; 0x06
    1680:	81 89       	ldd	r24, Z+17	; 0x11
    1682:	88 23       	and	r24, r24
    1684:	49 f0       	breq	.+18     	; 0x1698 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1686:	8d 81       	ldd	r24, Y+5	; 0x05
    1688:	9e 81       	ldd	r25, Y+6	; 0x06
    168a:	41 96       	adiw	r24, 0x11	; 17
    168c:	0e 94 69 13 	call	0x26d2	; 0x26d2 <xTaskRemoveFromEventList>
    1690:	81 30       	cpi	r24, 0x01	; 1
    1692:	11 f4       	brne	.+4      	; 0x1698 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1694:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1698:	0f 90       	pop	r0
    169a:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    169c:	81 e0       	ldi	r24, 0x01	; 1
    169e:	8c 87       	std	Y+12, r24	; 0x0c
    16a0:	5c c0       	rjmp	.+184    	; 0x175a <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    16a2:	89 85       	ldd	r24, Y+9	; 0x09
    16a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    16a6:	00 97       	sbiw	r24, 0x00	; 0
    16a8:	21 f4       	brne	.+8      	; 0x16b2 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    16aa:	0f 90       	pop	r0
    16ac:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    16ae:	1c 86       	std	Y+12, r1	; 0x0c
    16b0:	54 c0       	rjmp	.+168    	; 0x175a <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    16b2:	89 81       	ldd	r24, Y+1	; 0x01
    16b4:	88 23       	and	r24, r24
    16b6:	31 f4       	brne	.+12     	; 0x16c4 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    16b8:	ce 01       	movw	r24, r28
    16ba:	02 96       	adiw	r24, 0x02	; 2
    16bc:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    16c0:	81 e0       	ldi	r24, 0x01	; 1
    16c2:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    16c4:	0f 90       	pop	r0
    16c6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    16c8:	0e 94 2d 11 	call	0x225a	; 0x225a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    16cc:	0f b6       	in	r0, 0x3f	; 63
    16ce:	f8 94       	cli
    16d0:	0f 92       	push	r0
    16d2:	ed 81       	ldd	r30, Y+5	; 0x05
    16d4:	fe 81       	ldd	r31, Y+6	; 0x06
    16d6:	85 8d       	ldd	r24, Z+29	; 0x1d
    16d8:	8f 3f       	cpi	r24, 0xFF	; 255
    16da:	19 f4       	brne	.+6      	; 0x16e2 <xQueueGenericSend+0xb0>
    16dc:	ed 81       	ldd	r30, Y+5	; 0x05
    16de:	fe 81       	ldd	r31, Y+6	; 0x06
    16e0:	15 8e       	std	Z+29, r1	; 0x1d
    16e2:	ed 81       	ldd	r30, Y+5	; 0x05
    16e4:	fe 81       	ldd	r31, Y+6	; 0x06
    16e6:	86 8d       	ldd	r24, Z+30	; 0x1e
    16e8:	8f 3f       	cpi	r24, 0xFF	; 255
    16ea:	19 f4       	brne	.+6      	; 0x16f2 <xQueueGenericSend+0xc0>
    16ec:	ed 81       	ldd	r30, Y+5	; 0x05
    16ee:	fe 81       	ldd	r31, Y+6	; 0x06
    16f0:	16 8e       	std	Z+30, r1	; 0x1e
    16f2:	0f 90       	pop	r0
    16f4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    16f6:	ce 01       	movw	r24, r28
    16f8:	02 96       	adiw	r24, 0x02	; 2
    16fa:	9e 01       	movw	r18, r28
    16fc:	27 5f       	subi	r18, 0xF7	; 247
    16fe:	3f 4f       	sbci	r19, 0xFF	; 255
    1700:	b9 01       	movw	r22, r18
    1702:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <xTaskCheckForTimeOut>
    1706:	88 23       	and	r24, r24
    1708:	09 f5       	brne	.+66     	; 0x174c <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    170a:	8d 81       	ldd	r24, Y+5	; 0x05
    170c:	9e 81       	ldd	r25, Y+6	; 0x06
    170e:	0e 94 b8 0e 	call	0x1d70	; 0x1d70 <prvIsQueueFull>
    1712:	88 23       	and	r24, r24
    1714:	a1 f0       	breq	.+40     	; 0x173e <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1716:	8d 81       	ldd	r24, Y+5	; 0x05
    1718:	9e 81       	ldd	r25, Y+6	; 0x06
    171a:	08 96       	adiw	r24, 0x08	; 8
    171c:	29 85       	ldd	r18, Y+9	; 0x09
    171e:	3a 85       	ldd	r19, Y+10	; 0x0a
    1720:	b9 01       	movw	r22, r18
    1722:	0e 94 33 13 	call	0x2666	; 0x2666 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1726:	8d 81       	ldd	r24, Y+5	; 0x05
    1728:	9e 81       	ldd	r25, Y+6	; 0x06
    172a:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    172e:	0e 94 39 11 	call	0x2272	; 0x2272 <xTaskResumeAll>
    1732:	88 23       	and	r24, r24
    1734:	09 f0       	breq	.+2      	; 0x1738 <xQueueGenericSend+0x106>
    1736:	8f cf       	rjmp	.-226    	; 0x1656 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1738:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vPortYield>
    173c:	8c cf       	rjmp	.-232    	; 0x1656 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    173e:	8d 81       	ldd	r24, Y+5	; 0x05
    1740:	9e 81       	ldd	r25, Y+6	; 0x06
    1742:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1746:	0e 94 39 11 	call	0x2272	; 0x2272 <xTaskResumeAll>
    174a:	85 cf       	rjmp	.-246    	; 0x1656 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    174c:	8d 81       	ldd	r24, Y+5	; 0x05
    174e:	9e 81       	ldd	r25, Y+6	; 0x06
    1750:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1754:	0e 94 39 11 	call	0x2272	; 0x2272 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1758:	1c 86       	std	Y+12, r1	; 0x0c
    175a:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    175c:	2c 96       	adiw	r28, 0x0c	; 12
    175e:	0f b6       	in	r0, 0x3f	; 63
    1760:	f8 94       	cli
    1762:	de bf       	out	0x3e, r29	; 62
    1764:	0f be       	out	0x3f, r0	; 63
    1766:	cd bf       	out	0x3d, r28	; 61
    1768:	cf 91       	pop	r28
    176a:	df 91       	pop	r29
    176c:	08 95       	ret

0000176e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    176e:	df 93       	push	r29
    1770:	cf 93       	push	r28
    1772:	cd b7       	in	r28, 0x3d	; 61
    1774:	de b7       	in	r29, 0x3e	; 62
    1776:	29 97       	sbiw	r28, 0x09	; 9
    1778:	0f b6       	in	r0, 0x3f	; 63
    177a:	f8 94       	cli
    177c:	de bf       	out	0x3e, r29	; 62
    177e:	0f be       	out	0x3f, r0	; 63
    1780:	cd bf       	out	0x3d, r28	; 61
    1782:	9c 83       	std	Y+4, r25	; 0x04
    1784:	8b 83       	std	Y+3, r24	; 0x03
    1786:	7e 83       	std	Y+6, r23	; 0x06
    1788:	6d 83       	std	Y+5, r22	; 0x05
    178a:	58 87       	std	Y+8, r21	; 0x08
    178c:	4f 83       	std	Y+7, r20	; 0x07
    178e:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1790:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1792:	eb 81       	ldd	r30, Y+3	; 0x03
    1794:	fc 81       	ldd	r31, Y+4	; 0x04
    1796:	92 8d       	ldd	r25, Z+26	; 0x1a
    1798:	eb 81       	ldd	r30, Y+3	; 0x03
    179a:	fc 81       	ldd	r31, Y+4	; 0x04
    179c:	83 8d       	ldd	r24, Z+27	; 0x1b
    179e:	98 17       	cp	r25, r24
    17a0:	40 f5       	brcc	.+80     	; 0x17f2 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    17a2:	8b 81       	ldd	r24, Y+3	; 0x03
    17a4:	9c 81       	ldd	r25, Y+4	; 0x04
    17a6:	2d 81       	ldd	r18, Y+5	; 0x05
    17a8:	3e 81       	ldd	r19, Y+6	; 0x06
    17aa:	b9 01       	movw	r22, r18
    17ac:	49 85       	ldd	r20, Y+9	; 0x09
    17ae:	0e 94 54 0d 	call	0x1aa8	; 0x1aa8 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    17b2:	eb 81       	ldd	r30, Y+3	; 0x03
    17b4:	fc 81       	ldd	r31, Y+4	; 0x04
    17b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    17b8:	8f 3f       	cpi	r24, 0xFF	; 255
    17ba:	89 f4       	brne	.+34     	; 0x17de <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17bc:	eb 81       	ldd	r30, Y+3	; 0x03
    17be:	fc 81       	ldd	r31, Y+4	; 0x04
    17c0:	81 89       	ldd	r24, Z+17	; 0x11
    17c2:	88 23       	and	r24, r24
    17c4:	99 f0       	breq	.+38     	; 0x17ec <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    17c6:	8b 81       	ldd	r24, Y+3	; 0x03
    17c8:	9c 81       	ldd	r25, Y+4	; 0x04
    17ca:	41 96       	adiw	r24, 0x11	; 17
    17cc:	0e 94 69 13 	call	0x26d2	; 0x26d2 <xTaskRemoveFromEventList>
    17d0:	88 23       	and	r24, r24
    17d2:	61 f0       	breq	.+24     	; 0x17ec <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    17d4:	ef 81       	ldd	r30, Y+7	; 0x07
    17d6:	f8 85       	ldd	r31, Y+8	; 0x08
    17d8:	81 e0       	ldi	r24, 0x01	; 1
    17da:	80 83       	st	Z, r24
    17dc:	07 c0       	rjmp	.+14     	; 0x17ec <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    17de:	eb 81       	ldd	r30, Y+3	; 0x03
    17e0:	fc 81       	ldd	r31, Y+4	; 0x04
    17e2:	86 8d       	ldd	r24, Z+30	; 0x1e
    17e4:	8f 5f       	subi	r24, 0xFF	; 255
    17e6:	eb 81       	ldd	r30, Y+3	; 0x03
    17e8:	fc 81       	ldd	r31, Y+4	; 0x04
    17ea:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    17ec:	81 e0       	ldi	r24, 0x01	; 1
    17ee:	8a 83       	std	Y+2, r24	; 0x02
    17f0:	01 c0       	rjmp	.+2      	; 0x17f4 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    17f2:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    17f4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    17f6:	29 96       	adiw	r28, 0x09	; 9
    17f8:	0f b6       	in	r0, 0x3f	; 63
    17fa:	f8 94       	cli
    17fc:	de bf       	out	0x3e, r29	; 62
    17fe:	0f be       	out	0x3f, r0	; 63
    1800:	cd bf       	out	0x3d, r28	; 61
    1802:	cf 91       	pop	r28
    1804:	df 91       	pop	r29
    1806:	08 95       	ret

00001808 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1808:	df 93       	push	r29
    180a:	cf 93       	push	r28
    180c:	cd b7       	in	r28, 0x3d	; 61
    180e:	de b7       	in	r29, 0x3e	; 62
    1810:	2e 97       	sbiw	r28, 0x0e	; 14
    1812:	0f b6       	in	r0, 0x3f	; 63
    1814:	f8 94       	cli
    1816:	de bf       	out	0x3e, r29	; 62
    1818:	0f be       	out	0x3f, r0	; 63
    181a:	cd bf       	out	0x3d, r28	; 61
    181c:	98 87       	std	Y+8, r25	; 0x08
    181e:	8f 83       	std	Y+7, r24	; 0x07
    1820:	7a 87       	std	Y+10, r23	; 0x0a
    1822:	69 87       	std	Y+9, r22	; 0x09
    1824:	5c 87       	std	Y+12, r21	; 0x0c
    1826:	4b 87       	std	Y+11, r20	; 0x0b
    1828:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    182a:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    182c:	0f b6       	in	r0, 0x3f	; 63
    182e:	f8 94       	cli
    1830:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1832:	ef 81       	ldd	r30, Y+7	; 0x07
    1834:	f8 85       	ldd	r31, Y+8	; 0x08
    1836:	82 8d       	ldd	r24, Z+26	; 0x1a
    1838:	88 23       	and	r24, r24
    183a:	09 f4       	brne	.+2      	; 0x183e <xQueueGenericReceive+0x36>
    183c:	3f c0       	rjmp	.+126    	; 0x18bc <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    183e:	ef 81       	ldd	r30, Y+7	; 0x07
    1840:	f8 85       	ldd	r31, Y+8	; 0x08
    1842:	86 81       	ldd	r24, Z+6	; 0x06
    1844:	97 81       	ldd	r25, Z+7	; 0x07
    1846:	9a 83       	std	Y+2, r25	; 0x02
    1848:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    184a:	8f 81       	ldd	r24, Y+7	; 0x07
    184c:	98 85       	ldd	r25, Y+8	; 0x08
    184e:	29 85       	ldd	r18, Y+9	; 0x09
    1850:	3a 85       	ldd	r19, Y+10	; 0x0a
    1852:	b9 01       	movw	r22, r18
    1854:	0e 94 e9 0d 	call	0x1bd2	; 0x1bd2 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1858:	8d 85       	ldd	r24, Y+13	; 0x0d
    185a:	88 23       	and	r24, r24
    185c:	b1 f4       	brne	.+44     	; 0x188a <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    185e:	ef 81       	ldd	r30, Y+7	; 0x07
    1860:	f8 85       	ldd	r31, Y+8	; 0x08
    1862:	82 8d       	ldd	r24, Z+26	; 0x1a
    1864:	81 50       	subi	r24, 0x01	; 1
    1866:	ef 81       	ldd	r30, Y+7	; 0x07
    1868:	f8 85       	ldd	r31, Y+8	; 0x08
    186a:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    186c:	ef 81       	ldd	r30, Y+7	; 0x07
    186e:	f8 85       	ldd	r31, Y+8	; 0x08
    1870:	80 85       	ldd	r24, Z+8	; 0x08
    1872:	88 23       	and	r24, r24
    1874:	f1 f0       	breq	.+60     	; 0x18b2 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1876:	8f 81       	ldd	r24, Y+7	; 0x07
    1878:	98 85       	ldd	r25, Y+8	; 0x08
    187a:	08 96       	adiw	r24, 0x08	; 8
    187c:	0e 94 69 13 	call	0x26d2	; 0x26d2 <xTaskRemoveFromEventList>
    1880:	81 30       	cpi	r24, 0x01	; 1
    1882:	b9 f4       	brne	.+46     	; 0x18b2 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    1884:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vPortYield>
    1888:	14 c0       	rjmp	.+40     	; 0x18b2 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    188a:	ef 81       	ldd	r30, Y+7	; 0x07
    188c:	f8 85       	ldd	r31, Y+8	; 0x08
    188e:	89 81       	ldd	r24, Y+1	; 0x01
    1890:	9a 81       	ldd	r25, Y+2	; 0x02
    1892:	97 83       	std	Z+7, r25	; 0x07
    1894:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1896:	ef 81       	ldd	r30, Y+7	; 0x07
    1898:	f8 85       	ldd	r31, Y+8	; 0x08
    189a:	81 89       	ldd	r24, Z+17	; 0x11
    189c:	88 23       	and	r24, r24
    189e:	49 f0       	breq	.+18     	; 0x18b2 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    18a0:	8f 81       	ldd	r24, Y+7	; 0x07
    18a2:	98 85       	ldd	r25, Y+8	; 0x08
    18a4:	41 96       	adiw	r24, 0x11	; 17
    18a6:	0e 94 69 13 	call	0x26d2	; 0x26d2 <xTaskRemoveFromEventList>
    18aa:	88 23       	and	r24, r24
    18ac:	11 f0       	breq	.+4      	; 0x18b2 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    18ae:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    18b2:	0f 90       	pop	r0
    18b4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    18b6:	81 e0       	ldi	r24, 0x01	; 1
    18b8:	8e 87       	std	Y+14, r24	; 0x0e
    18ba:	5c c0       	rjmp	.+184    	; 0x1974 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    18bc:	8b 85       	ldd	r24, Y+11	; 0x0b
    18be:	9c 85       	ldd	r25, Y+12	; 0x0c
    18c0:	00 97       	sbiw	r24, 0x00	; 0
    18c2:	21 f4       	brne	.+8      	; 0x18cc <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    18c4:	0f 90       	pop	r0
    18c6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    18c8:	1e 86       	std	Y+14, r1	; 0x0e
    18ca:	54 c0       	rjmp	.+168    	; 0x1974 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    18cc:	8b 81       	ldd	r24, Y+3	; 0x03
    18ce:	88 23       	and	r24, r24
    18d0:	31 f4       	brne	.+12     	; 0x18de <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    18d2:	ce 01       	movw	r24, r28
    18d4:	04 96       	adiw	r24, 0x04	; 4
    18d6:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    18da:	81 e0       	ldi	r24, 0x01	; 1
    18dc:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    18de:	0f 90       	pop	r0
    18e0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    18e2:	0e 94 2d 11 	call	0x225a	; 0x225a <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    18e6:	0f b6       	in	r0, 0x3f	; 63
    18e8:	f8 94       	cli
    18ea:	0f 92       	push	r0
    18ec:	ef 81       	ldd	r30, Y+7	; 0x07
    18ee:	f8 85       	ldd	r31, Y+8	; 0x08
    18f0:	85 8d       	ldd	r24, Z+29	; 0x1d
    18f2:	8f 3f       	cpi	r24, 0xFF	; 255
    18f4:	19 f4       	brne	.+6      	; 0x18fc <xQueueGenericReceive+0xf4>
    18f6:	ef 81       	ldd	r30, Y+7	; 0x07
    18f8:	f8 85       	ldd	r31, Y+8	; 0x08
    18fa:	15 8e       	std	Z+29, r1	; 0x1d
    18fc:	ef 81       	ldd	r30, Y+7	; 0x07
    18fe:	f8 85       	ldd	r31, Y+8	; 0x08
    1900:	86 8d       	ldd	r24, Z+30	; 0x1e
    1902:	8f 3f       	cpi	r24, 0xFF	; 255
    1904:	19 f4       	brne	.+6      	; 0x190c <xQueueGenericReceive+0x104>
    1906:	ef 81       	ldd	r30, Y+7	; 0x07
    1908:	f8 85       	ldd	r31, Y+8	; 0x08
    190a:	16 8e       	std	Z+30, r1	; 0x1e
    190c:	0f 90       	pop	r0
    190e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1910:	ce 01       	movw	r24, r28
    1912:	04 96       	adiw	r24, 0x04	; 4
    1914:	9e 01       	movw	r18, r28
    1916:	25 5f       	subi	r18, 0xF5	; 245
    1918:	3f 4f       	sbci	r19, 0xFF	; 255
    191a:	b9 01       	movw	r22, r18
    191c:	0e 94 ea 13 	call	0x27d4	; 0x27d4 <xTaskCheckForTimeOut>
    1920:	88 23       	and	r24, r24
    1922:	09 f5       	brne	.+66     	; 0x1966 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1924:	8f 81       	ldd	r24, Y+7	; 0x07
    1926:	98 85       	ldd	r25, Y+8	; 0x08
    1928:	0e 94 85 0e 	call	0x1d0a	; 0x1d0a <prvIsQueueEmpty>
    192c:	88 23       	and	r24, r24
    192e:	a1 f0       	breq	.+40     	; 0x1958 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1930:	8f 81       	ldd	r24, Y+7	; 0x07
    1932:	98 85       	ldd	r25, Y+8	; 0x08
    1934:	41 96       	adiw	r24, 0x11	; 17
    1936:	2b 85       	ldd	r18, Y+11	; 0x0b
    1938:	3c 85       	ldd	r19, Y+12	; 0x0c
    193a:	b9 01       	movw	r22, r18
    193c:	0e 94 33 13 	call	0x2666	; 0x2666 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1940:	8f 81       	ldd	r24, Y+7	; 0x07
    1942:	98 85       	ldd	r25, Y+8	; 0x08
    1944:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1948:	0e 94 39 11 	call	0x2272	; 0x2272 <xTaskResumeAll>
    194c:	88 23       	and	r24, r24
    194e:	09 f0       	breq	.+2      	; 0x1952 <xQueueGenericReceive+0x14a>
    1950:	6d cf       	rjmp	.-294    	; 0x182c <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    1952:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vPortYield>
    1956:	6a cf       	rjmp	.-300    	; 0x182c <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1958:	8f 81       	ldd	r24, Y+7	; 0x07
    195a:	98 85       	ldd	r25, Y+8	; 0x08
    195c:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1960:	0e 94 39 11 	call	0x2272	; 0x2272 <xTaskResumeAll>
    1964:	63 cf       	rjmp	.-314    	; 0x182c <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1966:	8f 81       	ldd	r24, Y+7	; 0x07
    1968:	98 85       	ldd	r25, Y+8	; 0x08
    196a:	0e 94 31 0e 	call	0x1c62	; 0x1c62 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    196e:	0e 94 39 11 	call	0x2272	; 0x2272 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1972:	1e 86       	std	Y+14, r1	; 0x0e
    1974:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    1976:	2e 96       	adiw	r28, 0x0e	; 14
    1978:	0f b6       	in	r0, 0x3f	; 63
    197a:	f8 94       	cli
    197c:	de bf       	out	0x3e, r29	; 62
    197e:	0f be       	out	0x3f, r0	; 63
    1980:	cd bf       	out	0x3d, r28	; 61
    1982:	cf 91       	pop	r28
    1984:	df 91       	pop	r29
    1986:	08 95       	ret

00001988 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    1988:	df 93       	push	r29
    198a:	cf 93       	push	r28
    198c:	cd b7       	in	r28, 0x3d	; 61
    198e:	de b7       	in	r29, 0x3e	; 62
    1990:	28 97       	sbiw	r28, 0x08	; 8
    1992:	0f b6       	in	r0, 0x3f	; 63
    1994:	f8 94       	cli
    1996:	de bf       	out	0x3e, r29	; 62
    1998:	0f be       	out	0x3f, r0	; 63
    199a:	cd bf       	out	0x3d, r28	; 61
    199c:	9c 83       	std	Y+4, r25	; 0x04
    199e:	8b 83       	std	Y+3, r24	; 0x03
    19a0:	7e 83       	std	Y+6, r23	; 0x06
    19a2:	6d 83       	std	Y+5, r22	; 0x05
    19a4:	58 87       	std	Y+8, r21	; 0x08
    19a6:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    19a8:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    19aa:	eb 81       	ldd	r30, Y+3	; 0x03
    19ac:	fc 81       	ldd	r31, Y+4	; 0x04
    19ae:	82 8d       	ldd	r24, Z+26	; 0x1a
    19b0:	88 23       	and	r24, r24
    19b2:	71 f1       	breq	.+92     	; 0x1a10 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    19b4:	8b 81       	ldd	r24, Y+3	; 0x03
    19b6:	9c 81       	ldd	r25, Y+4	; 0x04
    19b8:	2d 81       	ldd	r18, Y+5	; 0x05
    19ba:	3e 81       	ldd	r19, Y+6	; 0x06
    19bc:	b9 01       	movw	r22, r18
    19be:	0e 94 e9 0d 	call	0x1bd2	; 0x1bd2 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    19c2:	eb 81       	ldd	r30, Y+3	; 0x03
    19c4:	fc 81       	ldd	r31, Y+4	; 0x04
    19c6:	82 8d       	ldd	r24, Z+26	; 0x1a
    19c8:	81 50       	subi	r24, 0x01	; 1
    19ca:	eb 81       	ldd	r30, Y+3	; 0x03
    19cc:	fc 81       	ldd	r31, Y+4	; 0x04
    19ce:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    19d0:	eb 81       	ldd	r30, Y+3	; 0x03
    19d2:	fc 81       	ldd	r31, Y+4	; 0x04
    19d4:	85 8d       	ldd	r24, Z+29	; 0x1d
    19d6:	8f 3f       	cpi	r24, 0xFF	; 255
    19d8:	89 f4       	brne	.+34     	; 0x19fc <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    19da:	eb 81       	ldd	r30, Y+3	; 0x03
    19dc:	fc 81       	ldd	r31, Y+4	; 0x04
    19de:	80 85       	ldd	r24, Z+8	; 0x08
    19e0:	88 23       	and	r24, r24
    19e2:	99 f0       	breq	.+38     	; 0x1a0a <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    19e4:	8b 81       	ldd	r24, Y+3	; 0x03
    19e6:	9c 81       	ldd	r25, Y+4	; 0x04
    19e8:	08 96       	adiw	r24, 0x08	; 8
    19ea:	0e 94 69 13 	call	0x26d2	; 0x26d2 <xTaskRemoveFromEventList>
    19ee:	88 23       	and	r24, r24
    19f0:	61 f0       	breq	.+24     	; 0x1a0a <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    19f2:	ef 81       	ldd	r30, Y+7	; 0x07
    19f4:	f8 85       	ldd	r31, Y+8	; 0x08
    19f6:	81 e0       	ldi	r24, 0x01	; 1
    19f8:	80 83       	st	Z, r24
    19fa:	07 c0       	rjmp	.+14     	; 0x1a0a <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    19fc:	eb 81       	ldd	r30, Y+3	; 0x03
    19fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1a00:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a02:	8f 5f       	subi	r24, 0xFF	; 255
    1a04:	eb 81       	ldd	r30, Y+3	; 0x03
    1a06:	fc 81       	ldd	r31, Y+4	; 0x04
    1a08:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1a0a:	81 e0       	ldi	r24, 0x01	; 1
    1a0c:	8a 83       	std	Y+2, r24	; 0x02
    1a0e:	01 c0       	rjmp	.+2      	; 0x1a12 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    1a10:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1a12:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1a14:	28 96       	adiw	r28, 0x08	; 8
    1a16:	0f b6       	in	r0, 0x3f	; 63
    1a18:	f8 94       	cli
    1a1a:	de bf       	out	0x3e, r29	; 62
    1a1c:	0f be       	out	0x3f, r0	; 63
    1a1e:	cd bf       	out	0x3d, r28	; 61
    1a20:	cf 91       	pop	r28
    1a22:	df 91       	pop	r29
    1a24:	08 95       	ret

00001a26 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    1a26:	df 93       	push	r29
    1a28:	cf 93       	push	r28
    1a2a:	00 d0       	rcall	.+0      	; 0x1a2c <uxQueueMessagesWaiting+0x6>
    1a2c:	0f 92       	push	r0
    1a2e:	cd b7       	in	r28, 0x3d	; 61
    1a30:	de b7       	in	r29, 0x3e	; 62
    1a32:	9b 83       	std	Y+3, r25	; 0x03
    1a34:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1a36:	0f b6       	in	r0, 0x3f	; 63
    1a38:	f8 94       	cli
    1a3a:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    1a3c:	ea 81       	ldd	r30, Y+2	; 0x02
    1a3e:	fb 81       	ldd	r31, Y+3	; 0x03
    1a40:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a42:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1a44:	0f 90       	pop	r0
    1a46:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1a48:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a4a:	0f 90       	pop	r0
    1a4c:	0f 90       	pop	r0
    1a4e:	0f 90       	pop	r0
    1a50:	cf 91       	pop	r28
    1a52:	df 91       	pop	r29
    1a54:	08 95       	ret

00001a56 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    1a56:	df 93       	push	r29
    1a58:	cf 93       	push	r28
    1a5a:	00 d0       	rcall	.+0      	; 0x1a5c <uxQueueMessagesWaitingFromISR+0x6>
    1a5c:	0f 92       	push	r0
    1a5e:	cd b7       	in	r28, 0x3d	; 61
    1a60:	de b7       	in	r29, 0x3e	; 62
    1a62:	9b 83       	std	Y+3, r25	; 0x03
    1a64:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    1a66:	ea 81       	ldd	r30, Y+2	; 0x02
    1a68:	fb 81       	ldd	r31, Y+3	; 0x03
    1a6a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a6c:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    1a6e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a70:	0f 90       	pop	r0
    1a72:	0f 90       	pop	r0
    1a74:	0f 90       	pop	r0
    1a76:	cf 91       	pop	r28
    1a78:	df 91       	pop	r29
    1a7a:	08 95       	ret

00001a7c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    1a7c:	df 93       	push	r29
    1a7e:	cf 93       	push	r28
    1a80:	00 d0       	rcall	.+0      	; 0x1a82 <vQueueDelete+0x6>
    1a82:	cd b7       	in	r28, 0x3d	; 61
    1a84:	de b7       	in	r29, 0x3e	; 62
    1a86:	9a 83       	std	Y+2, r25	; 0x02
    1a88:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    1a8a:	e9 81       	ldd	r30, Y+1	; 0x01
    1a8c:	fa 81       	ldd	r31, Y+2	; 0x02
    1a8e:	80 81       	ld	r24, Z
    1a90:	91 81       	ldd	r25, Z+1	; 0x01
    1a92:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <vPortFree>
	vPortFree( pxQueue );
    1a96:	89 81       	ldd	r24, Y+1	; 0x01
    1a98:	9a 81       	ldd	r25, Y+2	; 0x02
    1a9a:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <vPortFree>
}
    1a9e:	0f 90       	pop	r0
    1aa0:	0f 90       	pop	r0
    1aa2:	cf 91       	pop	r28
    1aa4:	df 91       	pop	r29
    1aa6:	08 95       	ret

00001aa8 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1aa8:	df 93       	push	r29
    1aaa:	cf 93       	push	r28
    1aac:	00 d0       	rcall	.+0      	; 0x1aae <prvCopyDataToQueue+0x6>
    1aae:	00 d0       	rcall	.+0      	; 0x1ab0 <prvCopyDataToQueue+0x8>
    1ab0:	0f 92       	push	r0
    1ab2:	cd b7       	in	r28, 0x3d	; 61
    1ab4:	de b7       	in	r29, 0x3e	; 62
    1ab6:	9a 83       	std	Y+2, r25	; 0x02
    1ab8:	89 83       	std	Y+1, r24	; 0x01
    1aba:	7c 83       	std	Y+4, r23	; 0x04
    1abc:	6b 83       	std	Y+3, r22	; 0x03
    1abe:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1ac0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ac2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ac4:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ac6:	88 23       	and	r24, r24
    1ac8:	09 f4       	brne	.+2      	; 0x1acc <prvCopyDataToQueue+0x24>
    1aca:	74 c0       	rjmp	.+232    	; 0x1bb4 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1acc:	8d 81       	ldd	r24, Y+5	; 0x05
    1ace:	88 23       	and	r24, r24
    1ad0:	99 f5       	brne	.+102    	; 0x1b38 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1ad2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ad4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ad6:	64 81       	ldd	r22, Z+4	; 0x04
    1ad8:	75 81       	ldd	r23, Z+5	; 0x05
    1ada:	e9 81       	ldd	r30, Y+1	; 0x01
    1adc:	fa 81       	ldd	r31, Y+2	; 0x02
    1ade:	84 8d       	ldd	r24, Z+28	; 0x1c
    1ae0:	48 2f       	mov	r20, r24
    1ae2:	50 e0       	ldi	r21, 0x00	; 0
    1ae4:	2b 81       	ldd	r18, Y+3	; 0x03
    1ae6:	3c 81       	ldd	r19, Y+4	; 0x04
    1ae8:	cb 01       	movw	r24, r22
    1aea:	b9 01       	movw	r22, r18
    1aec:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1af0:	e9 81       	ldd	r30, Y+1	; 0x01
    1af2:	fa 81       	ldd	r31, Y+2	; 0x02
    1af4:	24 81       	ldd	r18, Z+4	; 0x04
    1af6:	35 81       	ldd	r19, Z+5	; 0x05
    1af8:	e9 81       	ldd	r30, Y+1	; 0x01
    1afa:	fa 81       	ldd	r31, Y+2	; 0x02
    1afc:	84 8d       	ldd	r24, Z+28	; 0x1c
    1afe:	88 2f       	mov	r24, r24
    1b00:	90 e0       	ldi	r25, 0x00	; 0
    1b02:	82 0f       	add	r24, r18
    1b04:	93 1f       	adc	r25, r19
    1b06:	e9 81       	ldd	r30, Y+1	; 0x01
    1b08:	fa 81       	ldd	r31, Y+2	; 0x02
    1b0a:	95 83       	std	Z+5, r25	; 0x05
    1b0c:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1b0e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b10:	fa 81       	ldd	r31, Y+2	; 0x02
    1b12:	24 81       	ldd	r18, Z+4	; 0x04
    1b14:	35 81       	ldd	r19, Z+5	; 0x05
    1b16:	e9 81       	ldd	r30, Y+1	; 0x01
    1b18:	fa 81       	ldd	r31, Y+2	; 0x02
    1b1a:	82 81       	ldd	r24, Z+2	; 0x02
    1b1c:	93 81       	ldd	r25, Z+3	; 0x03
    1b1e:	28 17       	cp	r18, r24
    1b20:	39 07       	cpc	r19, r25
    1b22:	08 f4       	brcc	.+2      	; 0x1b26 <prvCopyDataToQueue+0x7e>
    1b24:	47 c0       	rjmp	.+142    	; 0x1bb4 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1b26:	e9 81       	ldd	r30, Y+1	; 0x01
    1b28:	fa 81       	ldd	r31, Y+2	; 0x02
    1b2a:	80 81       	ld	r24, Z
    1b2c:	91 81       	ldd	r25, Z+1	; 0x01
    1b2e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b30:	fa 81       	ldd	r31, Y+2	; 0x02
    1b32:	95 83       	std	Z+5, r25	; 0x05
    1b34:	84 83       	std	Z+4, r24	; 0x04
    1b36:	3e c0       	rjmp	.+124    	; 0x1bb4 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1b38:	e9 81       	ldd	r30, Y+1	; 0x01
    1b3a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b3c:	66 81       	ldd	r22, Z+6	; 0x06
    1b3e:	77 81       	ldd	r23, Z+7	; 0x07
    1b40:	e9 81       	ldd	r30, Y+1	; 0x01
    1b42:	fa 81       	ldd	r31, Y+2	; 0x02
    1b44:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b46:	48 2f       	mov	r20, r24
    1b48:	50 e0       	ldi	r21, 0x00	; 0
    1b4a:	2b 81       	ldd	r18, Y+3	; 0x03
    1b4c:	3c 81       	ldd	r19, Y+4	; 0x04
    1b4e:	cb 01       	movw	r24, r22
    1b50:	b9 01       	movw	r22, r18
    1b52:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1b56:	e9 81       	ldd	r30, Y+1	; 0x01
    1b58:	fa 81       	ldd	r31, Y+2	; 0x02
    1b5a:	26 81       	ldd	r18, Z+6	; 0x06
    1b5c:	37 81       	ldd	r19, Z+7	; 0x07
    1b5e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b60:	fa 81       	ldd	r31, Y+2	; 0x02
    1b62:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b64:	88 2f       	mov	r24, r24
    1b66:	90 e0       	ldi	r25, 0x00	; 0
    1b68:	90 95       	com	r25
    1b6a:	81 95       	neg	r24
    1b6c:	9f 4f       	sbci	r25, 0xFF	; 255
    1b6e:	82 0f       	add	r24, r18
    1b70:	93 1f       	adc	r25, r19
    1b72:	e9 81       	ldd	r30, Y+1	; 0x01
    1b74:	fa 81       	ldd	r31, Y+2	; 0x02
    1b76:	97 83       	std	Z+7, r25	; 0x07
    1b78:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1b7a:	e9 81       	ldd	r30, Y+1	; 0x01
    1b7c:	fa 81       	ldd	r31, Y+2	; 0x02
    1b7e:	26 81       	ldd	r18, Z+6	; 0x06
    1b80:	37 81       	ldd	r19, Z+7	; 0x07
    1b82:	e9 81       	ldd	r30, Y+1	; 0x01
    1b84:	fa 81       	ldd	r31, Y+2	; 0x02
    1b86:	80 81       	ld	r24, Z
    1b88:	91 81       	ldd	r25, Z+1	; 0x01
    1b8a:	28 17       	cp	r18, r24
    1b8c:	39 07       	cpc	r19, r25
    1b8e:	90 f4       	brcc	.+36     	; 0x1bb4 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1b90:	e9 81       	ldd	r30, Y+1	; 0x01
    1b92:	fa 81       	ldd	r31, Y+2	; 0x02
    1b94:	22 81       	ldd	r18, Z+2	; 0x02
    1b96:	33 81       	ldd	r19, Z+3	; 0x03
    1b98:	e9 81       	ldd	r30, Y+1	; 0x01
    1b9a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b9c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1b9e:	88 2f       	mov	r24, r24
    1ba0:	90 e0       	ldi	r25, 0x00	; 0
    1ba2:	90 95       	com	r25
    1ba4:	81 95       	neg	r24
    1ba6:	9f 4f       	sbci	r25, 0xFF	; 255
    1ba8:	82 0f       	add	r24, r18
    1baa:	93 1f       	adc	r25, r19
    1bac:	e9 81       	ldd	r30, Y+1	; 0x01
    1bae:	fa 81       	ldd	r31, Y+2	; 0x02
    1bb0:	97 83       	std	Z+7, r25	; 0x07
    1bb2:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1bb4:	e9 81       	ldd	r30, Y+1	; 0x01
    1bb6:	fa 81       	ldd	r31, Y+2	; 0x02
    1bb8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bba:	8f 5f       	subi	r24, 0xFF	; 255
    1bbc:	e9 81       	ldd	r30, Y+1	; 0x01
    1bbe:	fa 81       	ldd	r31, Y+2	; 0x02
    1bc0:	82 8f       	std	Z+26, r24	; 0x1a
}
    1bc2:	0f 90       	pop	r0
    1bc4:	0f 90       	pop	r0
    1bc6:	0f 90       	pop	r0
    1bc8:	0f 90       	pop	r0
    1bca:	0f 90       	pop	r0
    1bcc:	cf 91       	pop	r28
    1bce:	df 91       	pop	r29
    1bd0:	08 95       	ret

00001bd2 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1bd2:	df 93       	push	r29
    1bd4:	cf 93       	push	r28
    1bd6:	00 d0       	rcall	.+0      	; 0x1bd8 <prvCopyDataFromQueue+0x6>
    1bd8:	00 d0       	rcall	.+0      	; 0x1bda <prvCopyDataFromQueue+0x8>
    1bda:	cd b7       	in	r28, 0x3d	; 61
    1bdc:	de b7       	in	r29, 0x3e	; 62
    1bde:	9a 83       	std	Y+2, r25	; 0x02
    1be0:	89 83       	std	Y+1, r24	; 0x01
    1be2:	7c 83       	std	Y+4, r23	; 0x04
    1be4:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1be6:	e9 81       	ldd	r30, Y+1	; 0x01
    1be8:	fa 81       	ldd	r31, Y+2	; 0x02
    1bea:	80 81       	ld	r24, Z
    1bec:	91 81       	ldd	r25, Z+1	; 0x01
    1bee:	00 97       	sbiw	r24, 0x00	; 0
    1bf0:	89 f1       	breq	.+98     	; 0x1c54 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1bf2:	e9 81       	ldd	r30, Y+1	; 0x01
    1bf4:	fa 81       	ldd	r31, Y+2	; 0x02
    1bf6:	26 81       	ldd	r18, Z+6	; 0x06
    1bf8:	37 81       	ldd	r19, Z+7	; 0x07
    1bfa:	e9 81       	ldd	r30, Y+1	; 0x01
    1bfc:	fa 81       	ldd	r31, Y+2	; 0x02
    1bfe:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c00:	88 2f       	mov	r24, r24
    1c02:	90 e0       	ldi	r25, 0x00	; 0
    1c04:	82 0f       	add	r24, r18
    1c06:	93 1f       	adc	r25, r19
    1c08:	e9 81       	ldd	r30, Y+1	; 0x01
    1c0a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c0c:	97 83       	std	Z+7, r25	; 0x07
    1c0e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1c10:	e9 81       	ldd	r30, Y+1	; 0x01
    1c12:	fa 81       	ldd	r31, Y+2	; 0x02
    1c14:	26 81       	ldd	r18, Z+6	; 0x06
    1c16:	37 81       	ldd	r19, Z+7	; 0x07
    1c18:	e9 81       	ldd	r30, Y+1	; 0x01
    1c1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c1c:	82 81       	ldd	r24, Z+2	; 0x02
    1c1e:	93 81       	ldd	r25, Z+3	; 0x03
    1c20:	28 17       	cp	r18, r24
    1c22:	39 07       	cpc	r19, r25
    1c24:	40 f0       	brcs	.+16     	; 0x1c36 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1c26:	e9 81       	ldd	r30, Y+1	; 0x01
    1c28:	fa 81       	ldd	r31, Y+2	; 0x02
    1c2a:	80 81       	ld	r24, Z
    1c2c:	91 81       	ldd	r25, Z+1	; 0x01
    1c2e:	e9 81       	ldd	r30, Y+1	; 0x01
    1c30:	fa 81       	ldd	r31, Y+2	; 0x02
    1c32:	97 83       	std	Z+7, r25	; 0x07
    1c34:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1c36:	e9 81       	ldd	r30, Y+1	; 0x01
    1c38:	fa 81       	ldd	r31, Y+2	; 0x02
    1c3a:	46 81       	ldd	r20, Z+6	; 0x06
    1c3c:	57 81       	ldd	r21, Z+7	; 0x07
    1c3e:	e9 81       	ldd	r30, Y+1	; 0x01
    1c40:	fa 81       	ldd	r31, Y+2	; 0x02
    1c42:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c44:	28 2f       	mov	r18, r24
    1c46:	30 e0       	ldi	r19, 0x00	; 0
    1c48:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c4c:	ba 01       	movw	r22, r20
    1c4e:	a9 01       	movw	r20, r18
    1c50:	0e 94 dc 15 	call	0x2bb8	; 0x2bb8 <memcpy>
	}
}
    1c54:	0f 90       	pop	r0
    1c56:	0f 90       	pop	r0
    1c58:	0f 90       	pop	r0
    1c5a:	0f 90       	pop	r0
    1c5c:	cf 91       	pop	r28
    1c5e:	df 91       	pop	r29
    1c60:	08 95       	ret

00001c62 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    1c62:	df 93       	push	r29
    1c64:	cf 93       	push	r28
    1c66:	00 d0       	rcall	.+0      	; 0x1c68 <prvUnlockQueue+0x6>
    1c68:	cd b7       	in	r28, 0x3d	; 61
    1c6a:	de b7       	in	r29, 0x3e	; 62
    1c6c:	9a 83       	std	Y+2, r25	; 0x02
    1c6e:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1c70:	0f b6       	in	r0, 0x3f	; 63
    1c72:	f8 94       	cli
    1c74:	0f 92       	push	r0
    1c76:	15 c0       	rjmp	.+42     	; 0x1ca2 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1c78:	e9 81       	ldd	r30, Y+1	; 0x01
    1c7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1c7c:	81 89       	ldd	r24, Z+17	; 0x11
    1c7e:	88 23       	and	r24, r24
    1c80:	a9 f0       	breq	.+42     	; 0x1cac <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1c82:	89 81       	ldd	r24, Y+1	; 0x01
    1c84:	9a 81       	ldd	r25, Y+2	; 0x02
    1c86:	41 96       	adiw	r24, 0x11	; 17
    1c88:	0e 94 69 13 	call	0x26d2	; 0x26d2 <xTaskRemoveFromEventList>
    1c8c:	88 23       	and	r24, r24
    1c8e:	11 f0       	breq	.+4      	; 0x1c94 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    1c90:	0e 94 47 14 	call	0x288e	; 0x288e <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    1c94:	e9 81       	ldd	r30, Y+1	; 0x01
    1c96:	fa 81       	ldd	r31, Y+2	; 0x02
    1c98:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c9a:	81 50       	subi	r24, 0x01	; 1
    1c9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1c9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1ca0:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1ca2:	e9 81       	ldd	r30, Y+1	; 0x01
    1ca4:	fa 81       	ldd	r31, Y+2	; 0x02
    1ca6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ca8:	18 16       	cp	r1, r24
    1caa:	34 f3       	brlt	.-52     	; 0x1c78 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1cac:	e9 81       	ldd	r30, Y+1	; 0x01
    1cae:	fa 81       	ldd	r31, Y+2	; 0x02
    1cb0:	8f ef       	ldi	r24, 0xFF	; 255
    1cb2:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1cb4:	0f 90       	pop	r0
    1cb6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1cb8:	0f b6       	in	r0, 0x3f	; 63
    1cba:	f8 94       	cli
    1cbc:	0f 92       	push	r0
    1cbe:	15 c0       	rjmp	.+42     	; 0x1cea <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1cc0:	e9 81       	ldd	r30, Y+1	; 0x01
    1cc2:	fa 81       	ldd	r31, Y+2	; 0x02
    1cc4:	80 85       	ldd	r24, Z+8	; 0x08
    1cc6:	88 23       	and	r24, r24
    1cc8:	a9 f0       	breq	.+42     	; 0x1cf4 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1cca:	89 81       	ldd	r24, Y+1	; 0x01
    1ccc:	9a 81       	ldd	r25, Y+2	; 0x02
    1cce:	08 96       	adiw	r24, 0x08	; 8
    1cd0:	0e 94 69 13 	call	0x26d2	; 0x26d2 <xTaskRemoveFromEventList>
    1cd4:	88 23       	and	r24, r24
    1cd6:	11 f0       	breq	.+4      	; 0x1cdc <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    1cd8:	0e 94 47 14 	call	0x288e	; 0x288e <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1cdc:	e9 81       	ldd	r30, Y+1	; 0x01
    1cde:	fa 81       	ldd	r31, Y+2	; 0x02
    1ce0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ce2:	81 50       	subi	r24, 0x01	; 1
    1ce4:	e9 81       	ldd	r30, Y+1	; 0x01
    1ce6:	fa 81       	ldd	r31, Y+2	; 0x02
    1ce8:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1cea:	e9 81       	ldd	r30, Y+1	; 0x01
    1cec:	fa 81       	ldd	r31, Y+2	; 0x02
    1cee:	85 8d       	ldd	r24, Z+29	; 0x1d
    1cf0:	18 16       	cp	r1, r24
    1cf2:	34 f3       	brlt	.-52     	; 0x1cc0 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1cf4:	e9 81       	ldd	r30, Y+1	; 0x01
    1cf6:	fa 81       	ldd	r31, Y+2	; 0x02
    1cf8:	8f ef       	ldi	r24, 0xFF	; 255
    1cfa:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1cfc:	0f 90       	pop	r0
    1cfe:	0f be       	out	0x3f, r0	; 63
}
    1d00:	0f 90       	pop	r0
    1d02:	0f 90       	pop	r0
    1d04:	cf 91       	pop	r28
    1d06:	df 91       	pop	r29
    1d08:	08 95       	ret

00001d0a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    1d0a:	df 93       	push	r29
    1d0c:	cf 93       	push	r28
    1d0e:	00 d0       	rcall	.+0      	; 0x1d10 <prvIsQueueEmpty+0x6>
    1d10:	0f 92       	push	r0
    1d12:	cd b7       	in	r28, 0x3d	; 61
    1d14:	de b7       	in	r29, 0x3e	; 62
    1d16:	9b 83       	std	Y+3, r25	; 0x03
    1d18:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1d1a:	0f b6       	in	r0, 0x3f	; 63
    1d1c:	f8 94       	cli
    1d1e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1d20:	ea 81       	ldd	r30, Y+2	; 0x02
    1d22:	fb 81       	ldd	r31, Y+3	; 0x03
    1d24:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d26:	19 82       	std	Y+1, r1	; 0x01
    1d28:	88 23       	and	r24, r24
    1d2a:	11 f4       	brne	.+4      	; 0x1d30 <prvIsQueueEmpty+0x26>
    1d2c:	81 e0       	ldi	r24, 0x01	; 1
    1d2e:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1d30:	0f 90       	pop	r0
    1d32:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1d34:	89 81       	ldd	r24, Y+1	; 0x01
}
    1d36:	0f 90       	pop	r0
    1d38:	0f 90       	pop	r0
    1d3a:	0f 90       	pop	r0
    1d3c:	cf 91       	pop	r28
    1d3e:	df 91       	pop	r29
    1d40:	08 95       	ret

00001d42 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    1d42:	df 93       	push	r29
    1d44:	cf 93       	push	r28
    1d46:	00 d0       	rcall	.+0      	; 0x1d48 <xQueueIsQueueEmptyFromISR+0x6>
    1d48:	0f 92       	push	r0
    1d4a:	cd b7       	in	r28, 0x3d	; 61
    1d4c:	de b7       	in	r29, 0x3e	; 62
    1d4e:	9b 83       	std	Y+3, r25	; 0x03
    1d50:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    1d52:	ea 81       	ldd	r30, Y+2	; 0x02
    1d54:	fb 81       	ldd	r31, Y+3	; 0x03
    1d56:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d58:	19 82       	std	Y+1, r1	; 0x01
    1d5a:	88 23       	and	r24, r24
    1d5c:	11 f4       	brne	.+4      	; 0x1d62 <xQueueIsQueueEmptyFromISR+0x20>
    1d5e:	81 e0       	ldi	r24, 0x01	; 1
    1d60:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1d62:	89 81       	ldd	r24, Y+1	; 0x01
}
    1d64:	0f 90       	pop	r0
    1d66:	0f 90       	pop	r0
    1d68:	0f 90       	pop	r0
    1d6a:	cf 91       	pop	r28
    1d6c:	df 91       	pop	r29
    1d6e:	08 95       	ret

00001d70 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    1d70:	df 93       	push	r29
    1d72:	cf 93       	push	r28
    1d74:	00 d0       	rcall	.+0      	; 0x1d76 <prvIsQueueFull+0x6>
    1d76:	0f 92       	push	r0
    1d78:	cd b7       	in	r28, 0x3d	; 61
    1d7a:	de b7       	in	r29, 0x3e	; 62
    1d7c:	9b 83       	std	Y+3, r25	; 0x03
    1d7e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1d80:	0f b6       	in	r0, 0x3f	; 63
    1d82:	f8 94       	cli
    1d84:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1d86:	ea 81       	ldd	r30, Y+2	; 0x02
    1d88:	fb 81       	ldd	r31, Y+3	; 0x03
    1d8a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1d8c:	ea 81       	ldd	r30, Y+2	; 0x02
    1d8e:	fb 81       	ldd	r31, Y+3	; 0x03
    1d90:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d92:	19 82       	std	Y+1, r1	; 0x01
    1d94:	98 17       	cp	r25, r24
    1d96:	11 f4       	brne	.+4      	; 0x1d9c <prvIsQueueFull+0x2c>
    1d98:	81 e0       	ldi	r24, 0x01	; 1
    1d9a:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    1d9c:	0f 90       	pop	r0
    1d9e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1da0:	89 81       	ldd	r24, Y+1	; 0x01
}
    1da2:	0f 90       	pop	r0
    1da4:	0f 90       	pop	r0
    1da6:	0f 90       	pop	r0
    1da8:	cf 91       	pop	r28
    1daa:	df 91       	pop	r29
    1dac:	08 95       	ret

00001dae <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    1dae:	df 93       	push	r29
    1db0:	cf 93       	push	r28
    1db2:	00 d0       	rcall	.+0      	; 0x1db4 <xQueueIsQueueFullFromISR+0x6>
    1db4:	0f 92       	push	r0
    1db6:	cd b7       	in	r28, 0x3d	; 61
    1db8:	de b7       	in	r29, 0x3e	; 62
    1dba:	9b 83       	std	Y+3, r25	; 0x03
    1dbc:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    1dbe:	ea 81       	ldd	r30, Y+2	; 0x02
    1dc0:	fb 81       	ldd	r31, Y+3	; 0x03
    1dc2:	92 8d       	ldd	r25, Z+26	; 0x1a
    1dc4:	ea 81       	ldd	r30, Y+2	; 0x02
    1dc6:	fb 81       	ldd	r31, Y+3	; 0x03
    1dc8:	83 8d       	ldd	r24, Z+27	; 0x1b
    1dca:	19 82       	std	Y+1, r1	; 0x01
    1dcc:	98 17       	cp	r25, r24
    1dce:	11 f4       	brne	.+4      	; 0x1dd4 <xQueueIsQueueFullFromISR+0x26>
    1dd0:	81 e0       	ldi	r24, 0x01	; 1
    1dd2:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    1dd4:	89 81       	ldd	r24, Y+1	; 0x01
}
    1dd6:	0f 90       	pop	r0
    1dd8:	0f 90       	pop	r0
    1dda:	0f 90       	pop	r0
    1ddc:	cf 91       	pop	r28
    1dde:	df 91       	pop	r29
    1de0:	08 95       	ret

00001de2 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1de2:	af 92       	push	r10
    1de4:	bf 92       	push	r11
    1de6:	cf 92       	push	r12
    1de8:	df 92       	push	r13
    1dea:	ef 92       	push	r14
    1dec:	ff 92       	push	r15
    1dee:	0f 93       	push	r16
    1df0:	1f 93       	push	r17
    1df2:	df 93       	push	r29
    1df4:	cf 93       	push	r28
    1df6:	cd b7       	in	r28, 0x3d	; 61
    1df8:	de b7       	in	r29, 0x3e	; 62
    1dfa:	64 97       	sbiw	r28, 0x14	; 20
    1dfc:	0f b6       	in	r0, 0x3f	; 63
    1dfe:	f8 94       	cli
    1e00:	de bf       	out	0x3e, r29	; 62
    1e02:	0f be       	out	0x3f, r0	; 63
    1e04:	cd bf       	out	0x3d, r28	; 61
    1e06:	9f 83       	std	Y+7, r25	; 0x07
    1e08:	8e 83       	std	Y+6, r24	; 0x06
    1e0a:	79 87       	std	Y+9, r23	; 0x09
    1e0c:	68 87       	std	Y+8, r22	; 0x08
    1e0e:	5b 87       	std	Y+11, r21	; 0x0b
    1e10:	4a 87       	std	Y+10, r20	; 0x0a
    1e12:	3d 87       	std	Y+13, r19	; 0x0d
    1e14:	2c 87       	std	Y+12, r18	; 0x0c
    1e16:	0e 87       	std	Y+14, r16	; 0x0e
    1e18:	f8 8a       	std	Y+16, r15	; 0x10
    1e1a:	ef 86       	std	Y+15, r14	; 0x0f
    1e1c:	da 8a       	std	Y+18, r13	; 0x12
    1e1e:	c9 8a       	std	Y+17, r12	; 0x11
    1e20:	bc 8a       	std	Y+20, r11	; 0x14
    1e22:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    1e24:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e26:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e28:	29 89       	ldd	r18, Y+17	; 0x11
    1e2a:	3a 89       	ldd	r19, Y+18	; 0x12
    1e2c:	b9 01       	movw	r22, r18
    1e2e:	0e 94 76 15 	call	0x2aec	; 0x2aec <prvAllocateTCBAndStack>
    1e32:	9c 83       	std	Y+4, r25	; 0x04
    1e34:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    1e36:	8b 81       	ldd	r24, Y+3	; 0x03
    1e38:	9c 81       	ldd	r25, Y+4	; 0x04
    1e3a:	00 97       	sbiw	r24, 0x00	; 0
    1e3c:	09 f4       	brne	.+2      	; 0x1e40 <xTaskGenericCreate+0x5e>
    1e3e:	99 c0       	rjmp	.+306    	; 0x1f72 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1e40:	eb 81       	ldd	r30, Y+3	; 0x03
    1e42:	fc 81       	ldd	r31, Y+4	; 0x04
    1e44:	27 89       	ldd	r18, Z+23	; 0x17
    1e46:	30 8d       	ldd	r19, Z+24	; 0x18
    1e48:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e4a:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e4c:	01 97       	sbiw	r24, 0x01	; 1
    1e4e:	82 0f       	add	r24, r18
    1e50:	93 1f       	adc	r25, r19
    1e52:	9a 83       	std	Y+2, r25	; 0x02
    1e54:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    1e56:	8b 81       	ldd	r24, Y+3	; 0x03
    1e58:	9c 81       	ldd	r25, Y+4	; 0x04
    1e5a:	28 85       	ldd	r18, Y+8	; 0x08
    1e5c:	39 85       	ldd	r19, Y+9	; 0x09
    1e5e:	eb 89       	ldd	r30, Y+19	; 0x13
    1e60:	fc 89       	ldd	r31, Y+20	; 0x14
    1e62:	aa 85       	ldd	r26, Y+10	; 0x0a
    1e64:	bb 85       	ldd	r27, Y+11	; 0x0b
    1e66:	b9 01       	movw	r22, r18
    1e68:	4e 85       	ldd	r20, Y+14	; 0x0e
    1e6a:	9f 01       	movw	r18, r30
    1e6c:	8d 01       	movw	r16, r26
    1e6e:	0e 94 5b 14 	call	0x28b6	; 0x28b6 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1e72:	89 81       	ldd	r24, Y+1	; 0x01
    1e74:	9a 81       	ldd	r25, Y+2	; 0x02
    1e76:	2e 81       	ldd	r18, Y+6	; 0x06
    1e78:	3f 81       	ldd	r19, Y+7	; 0x07
    1e7a:	4c 85       	ldd	r20, Y+12	; 0x0c
    1e7c:	5d 85       	ldd	r21, Y+13	; 0x0d
    1e7e:	b9 01       	movw	r22, r18
    1e80:	0e 94 9e 07 	call	0xf3c	; 0xf3c <pxPortInitialiseStack>
    1e84:	eb 81       	ldd	r30, Y+3	; 0x03
    1e86:	fc 81       	ldd	r31, Y+4	; 0x04
    1e88:	91 83       	std	Z+1, r25	; 0x01
    1e8a:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1e8c:	8f 85       	ldd	r24, Y+15	; 0x0f
    1e8e:	98 89       	ldd	r25, Y+16	; 0x10
    1e90:	00 97       	sbiw	r24, 0x00	; 0
    1e92:	31 f0       	breq	.+12     	; 0x1ea0 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1e94:	ef 85       	ldd	r30, Y+15	; 0x0f
    1e96:	f8 89       	ldd	r31, Y+16	; 0x10
    1e98:	8b 81       	ldd	r24, Y+3	; 0x03
    1e9a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e9c:	91 83       	std	Z+1, r25	; 0x01
    1e9e:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1ea0:	0f b6       	in	r0, 0x3f	; 63
    1ea2:	f8 94       	cli
    1ea4:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1ea6:	80 91 df 03 	lds	r24, 0x03DF
    1eaa:	8f 5f       	subi	r24, 0xFF	; 255
    1eac:	80 93 df 03 	sts	0x03DF, r24
			if( pxCurrentTCB == NULL )
    1eb0:	80 91 dc 03 	lds	r24, 0x03DC
    1eb4:	90 91 dd 03 	lds	r25, 0x03DD
    1eb8:	00 97       	sbiw	r24, 0x00	; 0
    1eba:	69 f4       	brne	.+26     	; 0x1ed6 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1ebc:	8b 81       	ldd	r24, Y+3	; 0x03
    1ebe:	9c 81       	ldd	r25, Y+4	; 0x04
    1ec0:	90 93 dd 03 	sts	0x03DD, r25
    1ec4:	80 93 dc 03 	sts	0x03DC, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1ec8:	80 91 df 03 	lds	r24, 0x03DF
    1ecc:	81 30       	cpi	r24, 0x01	; 1
    1ece:	a9 f4       	brne	.+42     	; 0x1efa <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    1ed0:	0e 94 b2 14 	call	0x2964	; 0x2964 <prvInitialiseTaskLists>
    1ed4:	12 c0       	rjmp	.+36     	; 0x1efa <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1ed6:	80 91 e4 03 	lds	r24, 0x03E4
    1eda:	88 23       	and	r24, r24
    1edc:	71 f4       	brne	.+28     	; 0x1efa <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1ede:	e0 91 dc 03 	lds	r30, 0x03DC
    1ee2:	f0 91 dd 03 	lds	r31, 0x03DD
    1ee6:	96 89       	ldd	r25, Z+22	; 0x16
    1ee8:	8e 85       	ldd	r24, Y+14	; 0x0e
    1eea:	89 17       	cp	r24, r25
    1eec:	30 f0       	brcs	.+12     	; 0x1efa <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    1eee:	8b 81       	ldd	r24, Y+3	; 0x03
    1ef0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ef2:	90 93 dd 03 	sts	0x03DD, r25
    1ef6:	80 93 dc 03 	sts	0x03DC, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1efa:	eb 81       	ldd	r30, Y+3	; 0x03
    1efc:	fc 81       	ldd	r31, Y+4	; 0x04
    1efe:	96 89       	ldd	r25, Z+22	; 0x16
    1f00:	80 91 e2 03 	lds	r24, 0x03E2
    1f04:	89 17       	cp	r24, r25
    1f06:	28 f4       	brcc	.+10     	; 0x1f12 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1f08:	eb 81       	ldd	r30, Y+3	; 0x03
    1f0a:	fc 81       	ldd	r31, Y+4	; 0x04
    1f0c:	86 89       	ldd	r24, Z+22	; 0x16
    1f0e:	80 93 e2 03 	sts	0x03E2, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    1f12:	80 91 e9 03 	lds	r24, 0x03E9
    1f16:	8f 5f       	subi	r24, 0xFF	; 255
    1f18:	80 93 e9 03 	sts	0x03E9, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    1f1c:	eb 81       	ldd	r30, Y+3	; 0x03
    1f1e:	fc 81       	ldd	r31, Y+4	; 0x04
    1f20:	96 89       	ldd	r25, Z+22	; 0x16
    1f22:	80 91 e3 03 	lds	r24, 0x03E3
    1f26:	89 17       	cp	r24, r25
    1f28:	28 f4       	brcc	.+10     	; 0x1f34 <xTaskGenericCreate+0x152>
    1f2a:	eb 81       	ldd	r30, Y+3	; 0x03
    1f2c:	fc 81       	ldd	r31, Y+4	; 0x04
    1f2e:	86 89       	ldd	r24, Z+22	; 0x16
    1f30:	80 93 e3 03 	sts	0x03E3, r24
    1f34:	eb 81       	ldd	r30, Y+3	; 0x03
    1f36:	fc 81       	ldd	r31, Y+4	; 0x04
    1f38:	86 89       	ldd	r24, Z+22	; 0x16
    1f3a:	28 2f       	mov	r18, r24
    1f3c:	30 e0       	ldi	r19, 0x00	; 0
    1f3e:	c9 01       	movw	r24, r18
    1f40:	88 0f       	add	r24, r24
    1f42:	99 1f       	adc	r25, r25
    1f44:	88 0f       	add	r24, r24
    1f46:	99 1f       	adc	r25, r25
    1f48:	88 0f       	add	r24, r24
    1f4a:	99 1f       	adc	r25, r25
    1f4c:	82 0f       	add	r24, r18
    1f4e:	93 1f       	adc	r25, r19
    1f50:	ac 01       	movw	r20, r24
    1f52:	46 51       	subi	r20, 0x16	; 22
    1f54:	5c 4f       	sbci	r21, 0xFC	; 252
    1f56:	8b 81       	ldd	r24, Y+3	; 0x03
    1f58:	9c 81       	ldd	r25, Y+4	; 0x04
    1f5a:	9c 01       	movw	r18, r24
    1f5c:	2e 5f       	subi	r18, 0xFE	; 254
    1f5e:	3f 4f       	sbci	r19, 0xFF	; 255
    1f60:	ca 01       	movw	r24, r20
    1f62:	b9 01       	movw	r22, r18
    1f64:	0e 94 43 06 	call	0xc86	; 0xc86 <vListInsertEnd>

			xReturn = pdPASS;
    1f68:	81 e0       	ldi	r24, 0x01	; 1
    1f6a:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1f6c:	0f 90       	pop	r0
    1f6e:	0f be       	out	0x3f, r0	; 63
    1f70:	02 c0       	rjmp	.+4      	; 0x1f76 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1f72:	8f ef       	ldi	r24, 0xFF	; 255
    1f74:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    1f76:	8d 81       	ldd	r24, Y+5	; 0x05
    1f78:	81 30       	cpi	r24, 0x01	; 1
    1f7a:	71 f4       	brne	.+28     	; 0x1f98 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    1f7c:	80 91 e4 03 	lds	r24, 0x03E4
    1f80:	88 23       	and	r24, r24
    1f82:	51 f0       	breq	.+20     	; 0x1f98 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1f84:	e0 91 dc 03 	lds	r30, 0x03DC
    1f88:	f0 91 dd 03 	lds	r31, 0x03DD
    1f8c:	96 89       	ldd	r25, Z+22	; 0x16
    1f8e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f90:	98 17       	cp	r25, r24
    1f92:	10 f4       	brcc	.+4      	; 0x1f98 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    1f94:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vPortYield>
			}
		}
	}

	return xReturn;
    1f98:	8d 81       	ldd	r24, Y+5	; 0x05
}
    1f9a:	64 96       	adiw	r28, 0x14	; 20
    1f9c:	0f b6       	in	r0, 0x3f	; 63
    1f9e:	f8 94       	cli
    1fa0:	de bf       	out	0x3e, r29	; 62
    1fa2:	0f be       	out	0x3f, r0	; 63
    1fa4:	cd bf       	out	0x3d, r28	; 61
    1fa6:	cf 91       	pop	r28
    1fa8:	df 91       	pop	r29
    1faa:	1f 91       	pop	r17
    1fac:	0f 91       	pop	r16
    1fae:	ff 90       	pop	r15
    1fb0:	ef 90       	pop	r14
    1fb2:	df 90       	pop	r13
    1fb4:	cf 90       	pop	r12
    1fb6:	bf 90       	pop	r11
    1fb8:	af 90       	pop	r10
    1fba:	08 95       	ret

00001fbc <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    1fbc:	df 93       	push	r29
    1fbe:	cf 93       	push	r28
    1fc0:	00 d0       	rcall	.+0      	; 0x1fc2 <vTaskDelete+0x6>
    1fc2:	00 d0       	rcall	.+0      	; 0x1fc4 <vTaskDelete+0x8>
    1fc4:	00 d0       	rcall	.+0      	; 0x1fc6 <vTaskDelete+0xa>
    1fc6:	cd b7       	in	r28, 0x3d	; 61
    1fc8:	de b7       	in	r29, 0x3e	; 62
    1fca:	9c 83       	std	Y+4, r25	; 0x04
    1fcc:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1fce:	0f b6       	in	r0, 0x3f	; 63
    1fd0:	f8 94       	cli
    1fd2:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    1fd4:	20 91 dc 03 	lds	r18, 0x03DC
    1fd8:	30 91 dd 03 	lds	r19, 0x03DD
    1fdc:	8b 81       	ldd	r24, Y+3	; 0x03
    1fde:	9c 81       	ldd	r25, Y+4	; 0x04
    1fe0:	82 17       	cp	r24, r18
    1fe2:	93 07       	cpc	r25, r19
    1fe4:	11 f4       	brne	.+4      	; 0x1fea <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    1fe6:	1c 82       	std	Y+4, r1	; 0x04
    1fe8:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    1fea:	8b 81       	ldd	r24, Y+3	; 0x03
    1fec:	9c 81       	ldd	r25, Y+4	; 0x04
    1fee:	00 97       	sbiw	r24, 0x00	; 0
    1ff0:	39 f4       	brne	.+14     	; 0x2000 <vTaskDelete+0x44>
    1ff2:	80 91 dc 03 	lds	r24, 0x03DC
    1ff6:	90 91 dd 03 	lds	r25, 0x03DD
    1ffa:	9e 83       	std	Y+6, r25	; 0x06
    1ffc:	8d 83       	std	Y+5, r24	; 0x05
    1ffe:	04 c0       	rjmp	.+8      	; 0x2008 <vTaskDelete+0x4c>
    2000:	8b 81       	ldd	r24, Y+3	; 0x03
    2002:	9c 81       	ldd	r25, Y+4	; 0x04
    2004:	9e 83       	std	Y+6, r25	; 0x06
    2006:	8d 83       	std	Y+5, r24	; 0x05
    2008:	8d 81       	ldd	r24, Y+5	; 0x05
    200a:	9e 81       	ldd	r25, Y+6	; 0x06
    200c:	9a 83       	std	Y+2, r25	; 0x02
    200e:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2010:	89 81       	ldd	r24, Y+1	; 0x01
    2012:	9a 81       	ldd	r25, Y+2	; 0x02
    2014:	02 96       	adiw	r24, 0x02	; 2
    2016:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    201a:	e9 81       	ldd	r30, Y+1	; 0x01
    201c:	fa 81       	ldd	r31, Y+2	; 0x02
    201e:	84 89       	ldd	r24, Z+20	; 0x14
    2020:	95 89       	ldd	r25, Z+21	; 0x15
    2022:	00 97       	sbiw	r24, 0x00	; 0
    2024:	29 f0       	breq	.+10     	; 0x2030 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    2026:	89 81       	ldd	r24, Y+1	; 0x01
    2028:	9a 81       	ldd	r25, Y+2	; 0x02
    202a:	0c 96       	adiw	r24, 0x0c	; 12
    202c:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2030:	89 81       	ldd	r24, Y+1	; 0x01
    2032:	9a 81       	ldd	r25, Y+2	; 0x02
    2034:	9c 01       	movw	r18, r24
    2036:	2e 5f       	subi	r18, 0xFE	; 254
    2038:	3f 4f       	sbci	r19, 0xFF	; 255
    203a:	8d e2       	ldi	r24, 0x2D	; 45
    203c:	94 e0       	ldi	r25, 0x04	; 4
    203e:	b9 01       	movw	r22, r18
    2040:	0e 94 43 06 	call	0xc86	; 0xc86 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    2044:	80 91 de 03 	lds	r24, 0x03DE
    2048:	8f 5f       	subi	r24, 0xFF	; 255
    204a:	80 93 de 03 	sts	0x03DE, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    204e:	80 91 e9 03 	lds	r24, 0x03E9
    2052:	8f 5f       	subi	r24, 0xFF	; 255
    2054:	80 93 e9 03 	sts	0x03E9, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    2058:	0f 90       	pop	r0
    205a:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    205c:	80 91 e4 03 	lds	r24, 0x03E4
    2060:	88 23       	and	r24, r24
    2062:	31 f0       	breq	.+12     	; 0x2070 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    2064:	8b 81       	ldd	r24, Y+3	; 0x03
    2066:	9c 81       	ldd	r25, Y+4	; 0x04
    2068:	00 97       	sbiw	r24, 0x00	; 0
    206a:	11 f4       	brne	.+4      	; 0x2070 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    206c:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vPortYield>
			}
		}
	}
    2070:	26 96       	adiw	r28, 0x06	; 6
    2072:	0f b6       	in	r0, 0x3f	; 63
    2074:	f8 94       	cli
    2076:	de bf       	out	0x3e, r29	; 62
    2078:	0f be       	out	0x3f, r0	; 63
    207a:	cd bf       	out	0x3d, r28	; 61
    207c:	cf 91       	pop	r28
    207e:	df 91       	pop	r29
    2080:	08 95       	ret

00002082 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2082:	df 93       	push	r29
    2084:	cf 93       	push	r28
    2086:	cd b7       	in	r28, 0x3d	; 61
    2088:	de b7       	in	r29, 0x3e	; 62
    208a:	28 97       	sbiw	r28, 0x08	; 8
    208c:	0f b6       	in	r0, 0x3f	; 63
    208e:	f8 94       	cli
    2090:	de bf       	out	0x3e, r29	; 62
    2092:	0f be       	out	0x3f, r0	; 63
    2094:	cd bf       	out	0x3d, r28	; 61
    2096:	9e 83       	std	Y+6, r25	; 0x06
    2098:	8d 83       	std	Y+5, r24	; 0x05
    209a:	78 87       	std	Y+8, r23	; 0x08
    209c:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    209e:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    20a0:	0e 94 2d 11 	call	0x225a	; 0x225a <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    20a4:	ed 81       	ldd	r30, Y+5	; 0x05
    20a6:	fe 81       	ldd	r31, Y+6	; 0x06
    20a8:	20 81       	ld	r18, Z
    20aa:	31 81       	ldd	r19, Z+1	; 0x01
    20ac:	8f 81       	ldd	r24, Y+7	; 0x07
    20ae:	98 85       	ldd	r25, Y+8	; 0x08
    20b0:	82 0f       	add	r24, r18
    20b2:	93 1f       	adc	r25, r19
    20b4:	9c 83       	std	Y+4, r25	; 0x04
    20b6:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    20b8:	ed 81       	ldd	r30, Y+5	; 0x05
    20ba:	fe 81       	ldd	r31, Y+6	; 0x06
    20bc:	20 81       	ld	r18, Z
    20be:	31 81       	ldd	r19, Z+1	; 0x01
    20c0:	80 91 e0 03 	lds	r24, 0x03E0
    20c4:	90 91 e1 03 	lds	r25, 0x03E1
    20c8:	82 17       	cp	r24, r18
    20ca:	93 07       	cpc	r25, r19
    20cc:	a8 f4       	brcc	.+42     	; 0x20f8 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    20ce:	ed 81       	ldd	r30, Y+5	; 0x05
    20d0:	fe 81       	ldd	r31, Y+6	; 0x06
    20d2:	20 81       	ld	r18, Z
    20d4:	31 81       	ldd	r19, Z+1	; 0x01
    20d6:	8b 81       	ldd	r24, Y+3	; 0x03
    20d8:	9c 81       	ldd	r25, Y+4	; 0x04
    20da:	82 17       	cp	r24, r18
    20dc:	93 07       	cpc	r25, r19
    20de:	00 f5       	brcc	.+64     	; 0x2120 <vTaskDelayUntil+0x9e>
    20e0:	20 91 e0 03 	lds	r18, 0x03E0
    20e4:	30 91 e1 03 	lds	r19, 0x03E1
    20e8:	8b 81       	ldd	r24, Y+3	; 0x03
    20ea:	9c 81       	ldd	r25, Y+4	; 0x04
    20ec:	28 17       	cp	r18, r24
    20ee:	39 07       	cpc	r19, r25
    20f0:	b8 f4       	brcc	.+46     	; 0x2120 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    20f2:	81 e0       	ldi	r24, 0x01	; 1
    20f4:	89 83       	std	Y+1, r24	; 0x01
    20f6:	14 c0       	rjmp	.+40     	; 0x2120 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    20f8:	ed 81       	ldd	r30, Y+5	; 0x05
    20fa:	fe 81       	ldd	r31, Y+6	; 0x06
    20fc:	20 81       	ld	r18, Z
    20fe:	31 81       	ldd	r19, Z+1	; 0x01
    2100:	8b 81       	ldd	r24, Y+3	; 0x03
    2102:	9c 81       	ldd	r25, Y+4	; 0x04
    2104:	82 17       	cp	r24, r18
    2106:	93 07       	cpc	r25, r19
    2108:	48 f0       	brcs	.+18     	; 0x211c <vTaskDelayUntil+0x9a>
    210a:	20 91 e0 03 	lds	r18, 0x03E0
    210e:	30 91 e1 03 	lds	r19, 0x03E1
    2112:	8b 81       	ldd	r24, Y+3	; 0x03
    2114:	9c 81       	ldd	r25, Y+4	; 0x04
    2116:	28 17       	cp	r18, r24
    2118:	39 07       	cpc	r19, r25
    211a:	10 f4       	brcc	.+4      	; 0x2120 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    211c:	81 e0       	ldi	r24, 0x01	; 1
    211e:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2120:	ed 81       	ldd	r30, Y+5	; 0x05
    2122:	fe 81       	ldd	r31, Y+6	; 0x06
    2124:	8b 81       	ldd	r24, Y+3	; 0x03
    2126:	9c 81       	ldd	r25, Y+4	; 0x04
    2128:	91 83       	std	Z+1, r25	; 0x01
    212a:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    212c:	89 81       	ldd	r24, Y+1	; 0x01
    212e:	88 23       	and	r24, r24
    2130:	59 f0       	breq	.+22     	; 0x2148 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2132:	80 91 dc 03 	lds	r24, 0x03DC
    2136:	90 91 dd 03 	lds	r25, 0x03DD
    213a:	02 96       	adiw	r24, 0x02	; 2
    213c:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2140:	8b 81       	ldd	r24, Y+3	; 0x03
    2142:	9c 81       	ldd	r25, Y+4	; 0x04
    2144:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2148:	0e 94 39 11 	call	0x2272	; 0x2272 <xTaskResumeAll>
    214c:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    214e:	8a 81       	ldd	r24, Y+2	; 0x02
    2150:	88 23       	and	r24, r24
    2152:	11 f4       	brne	.+4      	; 0x2158 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    2154:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vPortYield>
		}
	}
    2158:	28 96       	adiw	r28, 0x08	; 8
    215a:	0f b6       	in	r0, 0x3f	; 63
    215c:	f8 94       	cli
    215e:	de bf       	out	0x3e, r29	; 62
    2160:	0f be       	out	0x3f, r0	; 63
    2162:	cd bf       	out	0x3d, r28	; 61
    2164:	cf 91       	pop	r28
    2166:	df 91       	pop	r29
    2168:	08 95       	ret

0000216a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    216a:	df 93       	push	r29
    216c:	cf 93       	push	r28
    216e:	00 d0       	rcall	.+0      	; 0x2170 <vTaskDelay+0x6>
    2170:	00 d0       	rcall	.+0      	; 0x2172 <vTaskDelay+0x8>
    2172:	0f 92       	push	r0
    2174:	cd b7       	in	r28, 0x3d	; 61
    2176:	de b7       	in	r29, 0x3e	; 62
    2178:	9d 83       	std	Y+5, r25	; 0x05
    217a:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    217c:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    217e:	8c 81       	ldd	r24, Y+4	; 0x04
    2180:	9d 81       	ldd	r25, Y+5	; 0x05
    2182:	00 97       	sbiw	r24, 0x00	; 0
    2184:	d1 f0       	breq	.+52     	; 0x21ba <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    2186:	0e 94 2d 11 	call	0x225a	; 0x225a <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    218a:	20 91 e0 03 	lds	r18, 0x03E0
    218e:	30 91 e1 03 	lds	r19, 0x03E1
    2192:	8c 81       	ldd	r24, Y+4	; 0x04
    2194:	9d 81       	ldd	r25, Y+5	; 0x05
    2196:	82 0f       	add	r24, r18
    2198:	93 1f       	adc	r25, r19
    219a:	9b 83       	std	Y+3, r25	; 0x03
    219c:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    219e:	80 91 dc 03 	lds	r24, 0x03DC
    21a2:	90 91 dd 03 	lds	r25, 0x03DD
    21a6:	02 96       	adiw	r24, 0x02	; 2
    21a8:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    21ac:	8a 81       	ldd	r24, Y+2	; 0x02
    21ae:	9b 81       	ldd	r25, Y+3	; 0x03
    21b0:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    21b4:	0e 94 39 11 	call	0x2272	; 0x2272 <xTaskResumeAll>
    21b8:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    21ba:	89 81       	ldd	r24, Y+1	; 0x01
    21bc:	88 23       	and	r24, r24
    21be:	11 f4       	brne	.+4      	; 0x21c4 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    21c0:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vPortYield>
		}
	}
    21c4:	0f 90       	pop	r0
    21c6:	0f 90       	pop	r0
    21c8:	0f 90       	pop	r0
    21ca:	0f 90       	pop	r0
    21cc:	0f 90       	pop	r0
    21ce:	cf 91       	pop	r28
    21d0:	df 91       	pop	r29
    21d2:	08 95       	ret

000021d4 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    21d4:	af 92       	push	r10
    21d6:	bf 92       	push	r11
    21d8:	cf 92       	push	r12
    21da:	df 92       	push	r13
    21dc:	ef 92       	push	r14
    21de:	ff 92       	push	r15
    21e0:	0f 93       	push	r16
    21e2:	df 93       	push	r29
    21e4:	cf 93       	push	r28
    21e6:	0f 92       	push	r0
    21e8:	cd b7       	in	r28, 0x3d	; 61
    21ea:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    21ec:	20 e6       	ldi	r18, 0x60	; 96
    21ee:	30 e0       	ldi	r19, 0x00	; 0
    21f0:	81 e5       	ldi	r24, 0x51	; 81
    21f2:	94 e1       	ldi	r25, 0x14	; 20
    21f4:	b9 01       	movw	r22, r18
    21f6:	4a ef       	ldi	r20, 0xFA	; 250
    21f8:	50 e0       	ldi	r21, 0x00	; 0
    21fa:	20 e0       	ldi	r18, 0x00	; 0
    21fc:	30 e0       	ldi	r19, 0x00	; 0
    21fe:	00 e0       	ldi	r16, 0x00	; 0
    2200:	ee 24       	eor	r14, r14
    2202:	ff 24       	eor	r15, r15
    2204:	cc 24       	eor	r12, r12
    2206:	dd 24       	eor	r13, r13
    2208:	aa 24       	eor	r10, r10
    220a:	bb 24       	eor	r11, r11
    220c:	0e 94 f1 0e 	call	0x1de2	; 0x1de2 <xTaskGenericCreate>
    2210:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2212:	89 81       	ldd	r24, Y+1	; 0x01
    2214:	81 30       	cpi	r24, 0x01	; 1
    2216:	51 f4       	brne	.+20     	; 0x222c <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2218:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    221a:	81 e0       	ldi	r24, 0x01	; 1
    221c:	80 93 e4 03 	sts	0x03E4, r24
		xTickCount = ( portTickType ) 0U;
    2220:	10 92 e1 03 	sts	0x03E1, r1
    2224:	10 92 e0 03 	sts	0x03E0, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2228:	0e 94 21 09 	call	0x1242	; 0x1242 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    222c:	0f 90       	pop	r0
    222e:	cf 91       	pop	r28
    2230:	df 91       	pop	r29
    2232:	0f 91       	pop	r16
    2234:	ff 90       	pop	r15
    2236:	ef 90       	pop	r14
    2238:	df 90       	pop	r13
    223a:	cf 90       	pop	r12
    223c:	bf 90       	pop	r11
    223e:	af 90       	pop	r10
    2240:	08 95       	ret

00002242 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2242:	df 93       	push	r29
    2244:	cf 93       	push	r28
    2246:	cd b7       	in	r28, 0x3d	; 61
    2248:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    224a:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    224c:	10 92 e4 03 	sts	0x03E4, r1
	vPortEndScheduler();
    2250:	0e 94 56 09 	call	0x12ac	; 0x12ac <vPortEndScheduler>
}
    2254:	cf 91       	pop	r28
    2256:	df 91       	pop	r29
    2258:	08 95       	ret

0000225a <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    225a:	df 93       	push	r29
    225c:	cf 93       	push	r28
    225e:	cd b7       	in	r28, 0x3d	; 61
    2260:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2262:	80 91 e5 03 	lds	r24, 0x03E5
    2266:	8f 5f       	subi	r24, 0xFF	; 255
    2268:	80 93 e5 03 	sts	0x03E5, r24
}
    226c:	cf 91       	pop	r28
    226e:	df 91       	pop	r29
    2270:	08 95       	ret

00002272 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2272:	df 93       	push	r29
    2274:	cf 93       	push	r28
    2276:	00 d0       	rcall	.+0      	; 0x2278 <xTaskResumeAll+0x6>
    2278:	00 d0       	rcall	.+0      	; 0x227a <xTaskResumeAll+0x8>
    227a:	cd b7       	in	r28, 0x3d	; 61
    227c:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    227e:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2280:	0f b6       	in	r0, 0x3f	; 63
    2282:	f8 94       	cli
    2284:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2286:	80 91 e5 03 	lds	r24, 0x03E5
    228a:	81 50       	subi	r24, 0x01	; 1
    228c:	80 93 e5 03 	sts	0x03E5, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2290:	80 91 e5 03 	lds	r24, 0x03E5
    2294:	88 23       	and	r24, r24
    2296:	09 f0       	breq	.+2      	; 0x229a <xTaskResumeAll+0x28>
    2298:	6c c0       	rjmp	.+216    	; 0x2372 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    229a:	80 91 df 03 	lds	r24, 0x03DF
    229e:	88 23       	and	r24, r24
    22a0:	09 f4       	brne	.+2      	; 0x22a4 <xTaskResumeAll+0x32>
    22a2:	67 c0       	rjmp	.+206    	; 0x2372 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    22a4:	19 82       	std	Y+1, r1	; 0x01
    22a6:	41 c0       	rjmp	.+130    	; 0x232a <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    22a8:	e0 91 29 04 	lds	r30, 0x0429
    22ac:	f0 91 2a 04 	lds	r31, 0x042A
    22b0:	86 81       	ldd	r24, Z+6	; 0x06
    22b2:	97 81       	ldd	r25, Z+7	; 0x07
    22b4:	9c 83       	std	Y+4, r25	; 0x04
    22b6:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    22b8:	8b 81       	ldd	r24, Y+3	; 0x03
    22ba:	9c 81       	ldd	r25, Y+4	; 0x04
    22bc:	0c 96       	adiw	r24, 0x0c	; 12
    22be:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    22c2:	8b 81       	ldd	r24, Y+3	; 0x03
    22c4:	9c 81       	ldd	r25, Y+4	; 0x04
    22c6:	02 96       	adiw	r24, 0x02	; 2
    22c8:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    22cc:	eb 81       	ldd	r30, Y+3	; 0x03
    22ce:	fc 81       	ldd	r31, Y+4	; 0x04
    22d0:	96 89       	ldd	r25, Z+22	; 0x16
    22d2:	80 91 e3 03 	lds	r24, 0x03E3
    22d6:	89 17       	cp	r24, r25
    22d8:	28 f4       	brcc	.+10     	; 0x22e4 <xTaskResumeAll+0x72>
    22da:	eb 81       	ldd	r30, Y+3	; 0x03
    22dc:	fc 81       	ldd	r31, Y+4	; 0x04
    22de:	86 89       	ldd	r24, Z+22	; 0x16
    22e0:	80 93 e3 03 	sts	0x03E3, r24
    22e4:	eb 81       	ldd	r30, Y+3	; 0x03
    22e6:	fc 81       	ldd	r31, Y+4	; 0x04
    22e8:	86 89       	ldd	r24, Z+22	; 0x16
    22ea:	28 2f       	mov	r18, r24
    22ec:	30 e0       	ldi	r19, 0x00	; 0
    22ee:	c9 01       	movw	r24, r18
    22f0:	88 0f       	add	r24, r24
    22f2:	99 1f       	adc	r25, r25
    22f4:	88 0f       	add	r24, r24
    22f6:	99 1f       	adc	r25, r25
    22f8:	88 0f       	add	r24, r24
    22fa:	99 1f       	adc	r25, r25
    22fc:	82 0f       	add	r24, r18
    22fe:	93 1f       	adc	r25, r19
    2300:	86 51       	subi	r24, 0x16	; 22
    2302:	9c 4f       	sbci	r25, 0xFC	; 252
    2304:	2b 81       	ldd	r18, Y+3	; 0x03
    2306:	3c 81       	ldd	r19, Y+4	; 0x04
    2308:	2e 5f       	subi	r18, 0xFE	; 254
    230a:	3f 4f       	sbci	r19, 0xFF	; 255
    230c:	b9 01       	movw	r22, r18
    230e:	0e 94 43 06 	call	0xc86	; 0xc86 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2312:	eb 81       	ldd	r30, Y+3	; 0x03
    2314:	fc 81       	ldd	r31, Y+4	; 0x04
    2316:	96 89       	ldd	r25, Z+22	; 0x16
    2318:	e0 91 dc 03 	lds	r30, 0x03DC
    231c:	f0 91 dd 03 	lds	r31, 0x03DD
    2320:	86 89       	ldd	r24, Z+22	; 0x16
    2322:	98 17       	cp	r25, r24
    2324:	10 f0       	brcs	.+4      	; 0x232a <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    2326:	81 e0       	ldi	r24, 0x01	; 1
    2328:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    232a:	80 91 24 04 	lds	r24, 0x0424
    232e:	88 23       	and	r24, r24
    2330:	09 f0       	breq	.+2      	; 0x2334 <xTaskResumeAll+0xc2>
    2332:	ba cf       	rjmp	.-140    	; 0x22a8 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2334:	80 91 e6 03 	lds	r24, 0x03E6
    2338:	88 23       	and	r24, r24
    233a:	71 f0       	breq	.+28     	; 0x2358 <xTaskResumeAll+0xe6>
    233c:	07 c0       	rjmp	.+14     	; 0x234c <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    233e:	0e 94 f8 11 	call	0x23f0	; 0x23f0 <vTaskIncrementTick>
						--uxMissedTicks;
    2342:	80 91 e6 03 	lds	r24, 0x03E6
    2346:	81 50       	subi	r24, 0x01	; 1
    2348:	80 93 e6 03 	sts	0x03E6, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    234c:	80 91 e6 03 	lds	r24, 0x03E6
    2350:	88 23       	and	r24, r24
    2352:	a9 f7       	brne	.-22     	; 0x233e <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    2354:	81 e0       	ldi	r24, 0x01	; 1
    2356:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2358:	89 81       	ldd	r24, Y+1	; 0x01
    235a:	81 30       	cpi	r24, 0x01	; 1
    235c:	21 f0       	breq	.+8      	; 0x2366 <xTaskResumeAll+0xf4>
    235e:	80 91 e7 03 	lds	r24, 0x03E7
    2362:	81 30       	cpi	r24, 0x01	; 1
    2364:	31 f4       	brne	.+12     	; 0x2372 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    2366:	81 e0       	ldi	r24, 0x01	; 1
    2368:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    236a:	10 92 e7 03 	sts	0x03E7, r1
					portYIELD_WITHIN_API();
    236e:	0e 94 5d 09 	call	0x12ba	; 0x12ba <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2372:	0f 90       	pop	r0
    2374:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2376:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2378:	0f 90       	pop	r0
    237a:	0f 90       	pop	r0
    237c:	0f 90       	pop	r0
    237e:	0f 90       	pop	r0
    2380:	cf 91       	pop	r28
    2382:	df 91       	pop	r29
    2384:	08 95       	ret

00002386 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    2386:	df 93       	push	r29
    2388:	cf 93       	push	r28
    238a:	00 d0       	rcall	.+0      	; 0x238c <xTaskGetTickCount+0x6>
    238c:	cd b7       	in	r28, 0x3d	; 61
    238e:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2390:	0f b6       	in	r0, 0x3f	; 63
    2392:	f8 94       	cli
    2394:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2396:	80 91 e0 03 	lds	r24, 0x03E0
    239a:	90 91 e1 03 	lds	r25, 0x03E1
    239e:	9a 83       	std	Y+2, r25	; 0x02
    23a0:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    23a2:	0f 90       	pop	r0
    23a4:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    23a6:	89 81       	ldd	r24, Y+1	; 0x01
    23a8:	9a 81       	ldd	r25, Y+2	; 0x02
}
    23aa:	0f 90       	pop	r0
    23ac:	0f 90       	pop	r0
    23ae:	cf 91       	pop	r28
    23b0:	df 91       	pop	r29
    23b2:	08 95       	ret

000023b4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    23b4:	df 93       	push	r29
    23b6:	cf 93       	push	r28
    23b8:	00 d0       	rcall	.+0      	; 0x23ba <xTaskGetTickCountFromISR+0x6>
    23ba:	0f 92       	push	r0
    23bc:	cd b7       	in	r28, 0x3d	; 61
    23be:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    23c0:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    23c2:	80 91 e0 03 	lds	r24, 0x03E0
    23c6:	90 91 e1 03 	lds	r25, 0x03E1
    23ca:	9b 83       	std	Y+3, r25	; 0x03
    23cc:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    23ce:	8a 81       	ldd	r24, Y+2	; 0x02
    23d0:	9b 81       	ldd	r25, Y+3	; 0x03
}
    23d2:	0f 90       	pop	r0
    23d4:	0f 90       	pop	r0
    23d6:	0f 90       	pop	r0
    23d8:	cf 91       	pop	r28
    23da:	df 91       	pop	r29
    23dc:	08 95       	ret

000023de <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    23de:	df 93       	push	r29
    23e0:	cf 93       	push	r28
    23e2:	cd b7       	in	r28, 0x3d	; 61
    23e4:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    23e6:	80 91 df 03 	lds	r24, 0x03DF
}
    23ea:	cf 91       	pop	r28
    23ec:	df 91       	pop	r29
    23ee:	08 95       	ret

000023f0 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    23f0:	df 93       	push	r29
    23f2:	cf 93       	push	r28
    23f4:	00 d0       	rcall	.+0      	; 0x23f6 <vTaskIncrementTick+0x6>
    23f6:	00 d0       	rcall	.+0      	; 0x23f8 <vTaskIncrementTick+0x8>
    23f8:	00 d0       	rcall	.+0      	; 0x23fa <vTaskIncrementTick+0xa>
    23fa:	cd b7       	in	r28, 0x3d	; 61
    23fc:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    23fe:	80 91 e5 03 	lds	r24, 0x03E5
    2402:	88 23       	and	r24, r24
    2404:	09 f0       	breq	.+2      	; 0x2408 <vTaskIncrementTick+0x18>
    2406:	bb c0       	rjmp	.+374    	; 0x257e <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    2408:	80 91 e0 03 	lds	r24, 0x03E0
    240c:	90 91 e1 03 	lds	r25, 0x03E1
    2410:	01 96       	adiw	r24, 0x01	; 1
    2412:	90 93 e1 03 	sts	0x03E1, r25
    2416:	80 93 e0 03 	sts	0x03E0, r24
		if( xTickCount == ( portTickType ) 0U )
    241a:	80 91 e0 03 	lds	r24, 0x03E0
    241e:	90 91 e1 03 	lds	r25, 0x03E1
    2422:	00 97       	sbiw	r24, 0x00	; 0
    2424:	d1 f5       	brne	.+116    	; 0x249a <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    2426:	80 91 20 04 	lds	r24, 0x0420
    242a:	90 91 21 04 	lds	r25, 0x0421
    242e:	9c 83       	std	Y+4, r25	; 0x04
    2430:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2432:	80 91 22 04 	lds	r24, 0x0422
    2436:	90 91 23 04 	lds	r25, 0x0423
    243a:	90 93 21 04 	sts	0x0421, r25
    243e:	80 93 20 04 	sts	0x0420, r24
			pxOverflowDelayedTaskList = pxTemp;
    2442:	8b 81       	ldd	r24, Y+3	; 0x03
    2444:	9c 81       	ldd	r25, Y+4	; 0x04
    2446:	90 93 23 04 	sts	0x0423, r25
    244a:	80 93 22 04 	sts	0x0422, r24
			xNumOfOverflows++;
    244e:	80 91 e8 03 	lds	r24, 0x03E8
    2452:	8f 5f       	subi	r24, 0xFF	; 255
    2454:	80 93 e8 03 	sts	0x03E8, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2458:	e0 91 20 04 	lds	r30, 0x0420
    245c:	f0 91 21 04 	lds	r31, 0x0421
    2460:	80 81       	ld	r24, Z
    2462:	88 23       	and	r24, r24
    2464:	39 f4       	brne	.+14     	; 0x2474 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2466:	8f ef       	ldi	r24, 0xFF	; 255
    2468:	9f ef       	ldi	r25, 0xFF	; 255
    246a:	90 93 7e 00 	sts	0x007E, r25
    246e:	80 93 7d 00 	sts	0x007D, r24
    2472:	13 c0       	rjmp	.+38     	; 0x249a <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2474:	e0 91 20 04 	lds	r30, 0x0420
    2478:	f0 91 21 04 	lds	r31, 0x0421
    247c:	05 80       	ldd	r0, Z+5	; 0x05
    247e:	f6 81       	ldd	r31, Z+6	; 0x06
    2480:	e0 2d       	mov	r30, r0
    2482:	86 81       	ldd	r24, Z+6	; 0x06
    2484:	97 81       	ldd	r25, Z+7	; 0x07
    2486:	9e 83       	std	Y+6, r25	; 0x06
    2488:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    248a:	ed 81       	ldd	r30, Y+5	; 0x05
    248c:	fe 81       	ldd	r31, Y+6	; 0x06
    248e:	82 81       	ldd	r24, Z+2	; 0x02
    2490:	93 81       	ldd	r25, Z+3	; 0x03
    2492:	90 93 7e 00 	sts	0x007E, r25
    2496:	80 93 7d 00 	sts	0x007D, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    249a:	20 91 e0 03 	lds	r18, 0x03E0
    249e:	30 91 e1 03 	lds	r19, 0x03E1
    24a2:	80 91 7d 00 	lds	r24, 0x007D
    24a6:	90 91 7e 00 	lds	r25, 0x007E
    24aa:	28 17       	cp	r18, r24
    24ac:	39 07       	cpc	r19, r25
    24ae:	08 f4       	brcc	.+2      	; 0x24b2 <vTaskIncrementTick+0xc2>
    24b0:	6b c0       	rjmp	.+214    	; 0x2588 <vTaskIncrementTick+0x198>
    24b2:	e0 91 20 04 	lds	r30, 0x0420
    24b6:	f0 91 21 04 	lds	r31, 0x0421
    24ba:	80 81       	ld	r24, Z
    24bc:	88 23       	and	r24, r24
    24be:	39 f4       	brne	.+14     	; 0x24ce <vTaskIncrementTick+0xde>
    24c0:	8f ef       	ldi	r24, 0xFF	; 255
    24c2:	9f ef       	ldi	r25, 0xFF	; 255
    24c4:	90 93 7e 00 	sts	0x007E, r25
    24c8:	80 93 7d 00 	sts	0x007D, r24
    24cc:	5d c0       	rjmp	.+186    	; 0x2588 <vTaskIncrementTick+0x198>
    24ce:	e0 91 20 04 	lds	r30, 0x0420
    24d2:	f0 91 21 04 	lds	r31, 0x0421
    24d6:	05 80       	ldd	r0, Z+5	; 0x05
    24d8:	f6 81       	ldd	r31, Z+6	; 0x06
    24da:	e0 2d       	mov	r30, r0
    24dc:	86 81       	ldd	r24, Z+6	; 0x06
    24de:	97 81       	ldd	r25, Z+7	; 0x07
    24e0:	9e 83       	std	Y+6, r25	; 0x06
    24e2:	8d 83       	std	Y+5, r24	; 0x05
    24e4:	ed 81       	ldd	r30, Y+5	; 0x05
    24e6:	fe 81       	ldd	r31, Y+6	; 0x06
    24e8:	82 81       	ldd	r24, Z+2	; 0x02
    24ea:	93 81       	ldd	r25, Z+3	; 0x03
    24ec:	9a 83       	std	Y+2, r25	; 0x02
    24ee:	89 83       	std	Y+1, r24	; 0x01
    24f0:	20 91 e0 03 	lds	r18, 0x03E0
    24f4:	30 91 e1 03 	lds	r19, 0x03E1
    24f8:	89 81       	ldd	r24, Y+1	; 0x01
    24fa:	9a 81       	ldd	r25, Y+2	; 0x02
    24fc:	28 17       	cp	r18, r24
    24fe:	39 07       	cpc	r19, r25
    2500:	38 f4       	brcc	.+14     	; 0x2510 <vTaskIncrementTick+0x120>
    2502:	89 81       	ldd	r24, Y+1	; 0x01
    2504:	9a 81       	ldd	r25, Y+2	; 0x02
    2506:	90 93 7e 00 	sts	0x007E, r25
    250a:	80 93 7d 00 	sts	0x007D, r24
    250e:	3c c0       	rjmp	.+120    	; 0x2588 <vTaskIncrementTick+0x198>
    2510:	8d 81       	ldd	r24, Y+5	; 0x05
    2512:	9e 81       	ldd	r25, Y+6	; 0x06
    2514:	02 96       	adiw	r24, 0x02	; 2
    2516:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>
    251a:	ed 81       	ldd	r30, Y+5	; 0x05
    251c:	fe 81       	ldd	r31, Y+6	; 0x06
    251e:	84 89       	ldd	r24, Z+20	; 0x14
    2520:	95 89       	ldd	r25, Z+21	; 0x15
    2522:	00 97       	sbiw	r24, 0x00	; 0
    2524:	29 f0       	breq	.+10     	; 0x2530 <vTaskIncrementTick+0x140>
    2526:	8d 81       	ldd	r24, Y+5	; 0x05
    2528:	9e 81       	ldd	r25, Y+6	; 0x06
    252a:	0c 96       	adiw	r24, 0x0c	; 12
    252c:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>
    2530:	ed 81       	ldd	r30, Y+5	; 0x05
    2532:	fe 81       	ldd	r31, Y+6	; 0x06
    2534:	96 89       	ldd	r25, Z+22	; 0x16
    2536:	80 91 e3 03 	lds	r24, 0x03E3
    253a:	89 17       	cp	r24, r25
    253c:	28 f4       	brcc	.+10     	; 0x2548 <vTaskIncrementTick+0x158>
    253e:	ed 81       	ldd	r30, Y+5	; 0x05
    2540:	fe 81       	ldd	r31, Y+6	; 0x06
    2542:	86 89       	ldd	r24, Z+22	; 0x16
    2544:	80 93 e3 03 	sts	0x03E3, r24
    2548:	ed 81       	ldd	r30, Y+5	; 0x05
    254a:	fe 81       	ldd	r31, Y+6	; 0x06
    254c:	86 89       	ldd	r24, Z+22	; 0x16
    254e:	28 2f       	mov	r18, r24
    2550:	30 e0       	ldi	r19, 0x00	; 0
    2552:	c9 01       	movw	r24, r18
    2554:	88 0f       	add	r24, r24
    2556:	99 1f       	adc	r25, r25
    2558:	88 0f       	add	r24, r24
    255a:	99 1f       	adc	r25, r25
    255c:	88 0f       	add	r24, r24
    255e:	99 1f       	adc	r25, r25
    2560:	82 0f       	add	r24, r18
    2562:	93 1f       	adc	r25, r19
    2564:	ac 01       	movw	r20, r24
    2566:	46 51       	subi	r20, 0x16	; 22
    2568:	5c 4f       	sbci	r21, 0xFC	; 252
    256a:	8d 81       	ldd	r24, Y+5	; 0x05
    256c:	9e 81       	ldd	r25, Y+6	; 0x06
    256e:	9c 01       	movw	r18, r24
    2570:	2e 5f       	subi	r18, 0xFE	; 254
    2572:	3f 4f       	sbci	r19, 0xFF	; 255
    2574:	ca 01       	movw	r24, r20
    2576:	b9 01       	movw	r22, r18
    2578:	0e 94 43 06 	call	0xc86	; 0xc86 <vListInsertEnd>
    257c:	9a cf       	rjmp	.-204    	; 0x24b2 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    257e:	80 91 e6 03 	lds	r24, 0x03E6
    2582:	8f 5f       	subi	r24, 0xFF	; 255
    2584:	80 93 e6 03 	sts	0x03E6, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    2588:	26 96       	adiw	r28, 0x06	; 6
    258a:	0f b6       	in	r0, 0x3f	; 63
    258c:	f8 94       	cli
    258e:	de bf       	out	0x3e, r29	; 62
    2590:	0f be       	out	0x3f, r0	; 63
    2592:	cd bf       	out	0x3d, r28	; 61
    2594:	cf 91       	pop	r28
    2596:	df 91       	pop	r29
    2598:	08 95       	ret

0000259a <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    259a:	df 93       	push	r29
    259c:	cf 93       	push	r28
    259e:	00 d0       	rcall	.+0      	; 0x25a0 <vTaskSwitchContext+0x6>
    25a0:	cd b7       	in	r28, 0x3d	; 61
    25a2:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    25a4:	80 91 e5 03 	lds	r24, 0x03E5
    25a8:	88 23       	and	r24, r24
    25aa:	49 f0       	breq	.+18     	; 0x25be <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    25ac:	81 e0       	ldi	r24, 0x01	; 1
    25ae:	80 93 e7 03 	sts	0x03E7, r24
    25b2:	54 c0       	rjmp	.+168    	; 0x265c <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    25b4:	80 91 e3 03 	lds	r24, 0x03E3
    25b8:	81 50       	subi	r24, 0x01	; 1
    25ba:	80 93 e3 03 	sts	0x03E3, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    25be:	80 91 e3 03 	lds	r24, 0x03E3
    25c2:	28 2f       	mov	r18, r24
    25c4:	30 e0       	ldi	r19, 0x00	; 0
    25c6:	c9 01       	movw	r24, r18
    25c8:	88 0f       	add	r24, r24
    25ca:	99 1f       	adc	r25, r25
    25cc:	88 0f       	add	r24, r24
    25ce:	99 1f       	adc	r25, r25
    25d0:	88 0f       	add	r24, r24
    25d2:	99 1f       	adc	r25, r25
    25d4:	82 0f       	add	r24, r18
    25d6:	93 1f       	adc	r25, r19
    25d8:	fc 01       	movw	r30, r24
    25da:	e6 51       	subi	r30, 0x16	; 22
    25dc:	fc 4f       	sbci	r31, 0xFC	; 252
    25de:	80 81       	ld	r24, Z
    25e0:	88 23       	and	r24, r24
    25e2:	41 f3       	breq	.-48     	; 0x25b4 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    25e4:	80 91 e3 03 	lds	r24, 0x03E3
    25e8:	28 2f       	mov	r18, r24
    25ea:	30 e0       	ldi	r19, 0x00	; 0
    25ec:	c9 01       	movw	r24, r18
    25ee:	88 0f       	add	r24, r24
    25f0:	99 1f       	adc	r25, r25
    25f2:	88 0f       	add	r24, r24
    25f4:	99 1f       	adc	r25, r25
    25f6:	88 0f       	add	r24, r24
    25f8:	99 1f       	adc	r25, r25
    25fa:	82 0f       	add	r24, r18
    25fc:	93 1f       	adc	r25, r19
    25fe:	86 51       	subi	r24, 0x16	; 22
    2600:	9c 4f       	sbci	r25, 0xFC	; 252
    2602:	9a 83       	std	Y+2, r25	; 0x02
    2604:	89 83       	std	Y+1, r24	; 0x01
    2606:	e9 81       	ldd	r30, Y+1	; 0x01
    2608:	fa 81       	ldd	r31, Y+2	; 0x02
    260a:	01 80       	ldd	r0, Z+1	; 0x01
    260c:	f2 81       	ldd	r31, Z+2	; 0x02
    260e:	e0 2d       	mov	r30, r0
    2610:	82 81       	ldd	r24, Z+2	; 0x02
    2612:	93 81       	ldd	r25, Z+3	; 0x03
    2614:	e9 81       	ldd	r30, Y+1	; 0x01
    2616:	fa 81       	ldd	r31, Y+2	; 0x02
    2618:	92 83       	std	Z+2, r25	; 0x02
    261a:	81 83       	std	Z+1, r24	; 0x01
    261c:	e9 81       	ldd	r30, Y+1	; 0x01
    261e:	fa 81       	ldd	r31, Y+2	; 0x02
    2620:	21 81       	ldd	r18, Z+1	; 0x01
    2622:	32 81       	ldd	r19, Z+2	; 0x02
    2624:	89 81       	ldd	r24, Y+1	; 0x01
    2626:	9a 81       	ldd	r25, Y+2	; 0x02
    2628:	03 96       	adiw	r24, 0x03	; 3
    262a:	28 17       	cp	r18, r24
    262c:	39 07       	cpc	r19, r25
    262e:	59 f4       	brne	.+22     	; 0x2646 <vTaskSwitchContext+0xac>
    2630:	e9 81       	ldd	r30, Y+1	; 0x01
    2632:	fa 81       	ldd	r31, Y+2	; 0x02
    2634:	01 80       	ldd	r0, Z+1	; 0x01
    2636:	f2 81       	ldd	r31, Z+2	; 0x02
    2638:	e0 2d       	mov	r30, r0
    263a:	82 81       	ldd	r24, Z+2	; 0x02
    263c:	93 81       	ldd	r25, Z+3	; 0x03
    263e:	e9 81       	ldd	r30, Y+1	; 0x01
    2640:	fa 81       	ldd	r31, Y+2	; 0x02
    2642:	92 83       	std	Z+2, r25	; 0x02
    2644:	81 83       	std	Z+1, r24	; 0x01
    2646:	e9 81       	ldd	r30, Y+1	; 0x01
    2648:	fa 81       	ldd	r31, Y+2	; 0x02
    264a:	01 80       	ldd	r0, Z+1	; 0x01
    264c:	f2 81       	ldd	r31, Z+2	; 0x02
    264e:	e0 2d       	mov	r30, r0
    2650:	86 81       	ldd	r24, Z+6	; 0x06
    2652:	97 81       	ldd	r25, Z+7	; 0x07
    2654:	90 93 dd 03 	sts	0x03DD, r25
    2658:	80 93 dc 03 	sts	0x03DC, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    265c:	0f 90       	pop	r0
    265e:	0f 90       	pop	r0
    2660:	cf 91       	pop	r28
    2662:	df 91       	pop	r29
    2664:	08 95       	ret

00002666 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    2666:	df 93       	push	r29
    2668:	cf 93       	push	r28
    266a:	00 d0       	rcall	.+0      	; 0x266c <vTaskPlaceOnEventList+0x6>
    266c:	00 d0       	rcall	.+0      	; 0x266e <vTaskPlaceOnEventList+0x8>
    266e:	00 d0       	rcall	.+0      	; 0x2670 <vTaskPlaceOnEventList+0xa>
    2670:	cd b7       	in	r28, 0x3d	; 61
    2672:	de b7       	in	r29, 0x3e	; 62
    2674:	9c 83       	std	Y+4, r25	; 0x04
    2676:	8b 83       	std	Y+3, r24	; 0x03
    2678:	7e 83       	std	Y+6, r23	; 0x06
    267a:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    267c:	4b 81       	ldd	r20, Y+3	; 0x03
    267e:	5c 81       	ldd	r21, Y+4	; 0x04
    2680:	80 91 dc 03 	lds	r24, 0x03DC
    2684:	90 91 dd 03 	lds	r25, 0x03DD
    2688:	9c 01       	movw	r18, r24
    268a:	24 5f       	subi	r18, 0xF4	; 244
    268c:	3f 4f       	sbci	r19, 0xFF	; 255
    268e:	ca 01       	movw	r24, r20
    2690:	b9 01       	movw	r22, r18
    2692:	0e 94 8f 06 	call	0xd1e	; 0xd1e <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2696:	80 91 dc 03 	lds	r24, 0x03DC
    269a:	90 91 dd 03 	lds	r25, 0x03DD
    269e:	02 96       	adiw	r24, 0x02	; 2
    26a0:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    26a4:	20 91 e0 03 	lds	r18, 0x03E0
    26a8:	30 91 e1 03 	lds	r19, 0x03E1
    26ac:	8d 81       	ldd	r24, Y+5	; 0x05
    26ae:	9e 81       	ldd	r25, Y+6	; 0x06
    26b0:	82 0f       	add	r24, r18
    26b2:	93 1f       	adc	r25, r19
    26b4:	9a 83       	std	Y+2, r25	; 0x02
    26b6:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    26b8:	89 81       	ldd	r24, Y+1	; 0x01
    26ba:	9a 81       	ldd	r25, Y+2	; 0x02
    26bc:	0e 94 2d 15 	call	0x2a5a	; 0x2a5a <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    26c0:	26 96       	adiw	r28, 0x06	; 6
    26c2:	0f b6       	in	r0, 0x3f	; 63
    26c4:	f8 94       	cli
    26c6:	de bf       	out	0x3e, r29	; 62
    26c8:	0f be       	out	0x3f, r0	; 63
    26ca:	cd bf       	out	0x3d, r28	; 61
    26cc:	cf 91       	pop	r28
    26ce:	df 91       	pop	r29
    26d0:	08 95       	ret

000026d2 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    26d2:	df 93       	push	r29
    26d4:	cf 93       	push	r28
    26d6:	00 d0       	rcall	.+0      	; 0x26d8 <xTaskRemoveFromEventList+0x6>
    26d8:	00 d0       	rcall	.+0      	; 0x26da <xTaskRemoveFromEventList+0x8>
    26da:	0f 92       	push	r0
    26dc:	cd b7       	in	r28, 0x3d	; 61
    26de:	de b7       	in	r29, 0x3e	; 62
    26e0:	9d 83       	std	Y+5, r25	; 0x05
    26e2:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    26e4:	ec 81       	ldd	r30, Y+4	; 0x04
    26e6:	fd 81       	ldd	r31, Y+5	; 0x05
    26e8:	05 80       	ldd	r0, Z+5	; 0x05
    26ea:	f6 81       	ldd	r31, Z+6	; 0x06
    26ec:	e0 2d       	mov	r30, r0
    26ee:	86 81       	ldd	r24, Z+6	; 0x06
    26f0:	97 81       	ldd	r25, Z+7	; 0x07
    26f2:	9b 83       	std	Y+3, r25	; 0x03
    26f4:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    26f6:	8a 81       	ldd	r24, Y+2	; 0x02
    26f8:	9b 81       	ldd	r25, Y+3	; 0x03
    26fa:	0c 96       	adiw	r24, 0x0c	; 12
    26fc:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2700:	80 91 e5 03 	lds	r24, 0x03E5
    2704:	88 23       	and	r24, r24
    2706:	61 f5       	brne	.+88     	; 0x2760 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2708:	8a 81       	ldd	r24, Y+2	; 0x02
    270a:	9b 81       	ldd	r25, Y+3	; 0x03
    270c:	02 96       	adiw	r24, 0x02	; 2
    270e:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2712:	ea 81       	ldd	r30, Y+2	; 0x02
    2714:	fb 81       	ldd	r31, Y+3	; 0x03
    2716:	96 89       	ldd	r25, Z+22	; 0x16
    2718:	80 91 e3 03 	lds	r24, 0x03E3
    271c:	89 17       	cp	r24, r25
    271e:	28 f4       	brcc	.+10     	; 0x272a <xTaskRemoveFromEventList+0x58>
    2720:	ea 81       	ldd	r30, Y+2	; 0x02
    2722:	fb 81       	ldd	r31, Y+3	; 0x03
    2724:	86 89       	ldd	r24, Z+22	; 0x16
    2726:	80 93 e3 03 	sts	0x03E3, r24
    272a:	ea 81       	ldd	r30, Y+2	; 0x02
    272c:	fb 81       	ldd	r31, Y+3	; 0x03
    272e:	86 89       	ldd	r24, Z+22	; 0x16
    2730:	28 2f       	mov	r18, r24
    2732:	30 e0       	ldi	r19, 0x00	; 0
    2734:	c9 01       	movw	r24, r18
    2736:	88 0f       	add	r24, r24
    2738:	99 1f       	adc	r25, r25
    273a:	88 0f       	add	r24, r24
    273c:	99 1f       	adc	r25, r25
    273e:	88 0f       	add	r24, r24
    2740:	99 1f       	adc	r25, r25
    2742:	82 0f       	add	r24, r18
    2744:	93 1f       	adc	r25, r19
    2746:	ac 01       	movw	r20, r24
    2748:	46 51       	subi	r20, 0x16	; 22
    274a:	5c 4f       	sbci	r21, 0xFC	; 252
    274c:	8a 81       	ldd	r24, Y+2	; 0x02
    274e:	9b 81       	ldd	r25, Y+3	; 0x03
    2750:	9c 01       	movw	r18, r24
    2752:	2e 5f       	subi	r18, 0xFE	; 254
    2754:	3f 4f       	sbci	r19, 0xFF	; 255
    2756:	ca 01       	movw	r24, r20
    2758:	b9 01       	movw	r22, r18
    275a:	0e 94 43 06 	call	0xc86	; 0xc86 <vListInsertEnd>
    275e:	0a c0       	rjmp	.+20     	; 0x2774 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2760:	8a 81       	ldd	r24, Y+2	; 0x02
    2762:	9b 81       	ldd	r25, Y+3	; 0x03
    2764:	9c 01       	movw	r18, r24
    2766:	24 5f       	subi	r18, 0xF4	; 244
    2768:	3f 4f       	sbci	r19, 0xFF	; 255
    276a:	84 e2       	ldi	r24, 0x24	; 36
    276c:	94 e0       	ldi	r25, 0x04	; 4
    276e:	b9 01       	movw	r22, r18
    2770:	0e 94 43 06 	call	0xc86	; 0xc86 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2774:	ea 81       	ldd	r30, Y+2	; 0x02
    2776:	fb 81       	ldd	r31, Y+3	; 0x03
    2778:	96 89       	ldd	r25, Z+22	; 0x16
    277a:	e0 91 dc 03 	lds	r30, 0x03DC
    277e:	f0 91 dd 03 	lds	r31, 0x03DD
    2782:	86 89       	ldd	r24, Z+22	; 0x16
    2784:	98 17       	cp	r25, r24
    2786:	18 f0       	brcs	.+6      	; 0x278e <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    2788:	81 e0       	ldi	r24, 0x01	; 1
    278a:	89 83       	std	Y+1, r24	; 0x01
    278c:	01 c0       	rjmp	.+2      	; 0x2790 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    278e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2790:	89 81       	ldd	r24, Y+1	; 0x01
}
    2792:	0f 90       	pop	r0
    2794:	0f 90       	pop	r0
    2796:	0f 90       	pop	r0
    2798:	0f 90       	pop	r0
    279a:	0f 90       	pop	r0
    279c:	cf 91       	pop	r28
    279e:	df 91       	pop	r29
    27a0:	08 95       	ret

000027a2 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    27a2:	df 93       	push	r29
    27a4:	cf 93       	push	r28
    27a6:	00 d0       	rcall	.+0      	; 0x27a8 <vTaskSetTimeOutState+0x6>
    27a8:	cd b7       	in	r28, 0x3d	; 61
    27aa:	de b7       	in	r29, 0x3e	; 62
    27ac:	9a 83       	std	Y+2, r25	; 0x02
    27ae:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    27b0:	80 91 e8 03 	lds	r24, 0x03E8
    27b4:	e9 81       	ldd	r30, Y+1	; 0x01
    27b6:	fa 81       	ldd	r31, Y+2	; 0x02
    27b8:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    27ba:	80 91 e0 03 	lds	r24, 0x03E0
    27be:	90 91 e1 03 	lds	r25, 0x03E1
    27c2:	e9 81       	ldd	r30, Y+1	; 0x01
    27c4:	fa 81       	ldd	r31, Y+2	; 0x02
    27c6:	92 83       	std	Z+2, r25	; 0x02
    27c8:	81 83       	std	Z+1, r24	; 0x01
}
    27ca:	0f 90       	pop	r0
    27cc:	0f 90       	pop	r0
    27ce:	cf 91       	pop	r28
    27d0:	df 91       	pop	r29
    27d2:	08 95       	ret

000027d4 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    27d4:	df 93       	push	r29
    27d6:	cf 93       	push	r28
    27d8:	00 d0       	rcall	.+0      	; 0x27da <xTaskCheckForTimeOut+0x6>
    27da:	00 d0       	rcall	.+0      	; 0x27dc <xTaskCheckForTimeOut+0x8>
    27dc:	0f 92       	push	r0
    27de:	cd b7       	in	r28, 0x3d	; 61
    27e0:	de b7       	in	r29, 0x3e	; 62
    27e2:	9b 83       	std	Y+3, r25	; 0x03
    27e4:	8a 83       	std	Y+2, r24	; 0x02
    27e6:	7d 83       	std	Y+5, r23	; 0x05
    27e8:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    27ea:	0f b6       	in	r0, 0x3f	; 63
    27ec:	f8 94       	cli
    27ee:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    27f0:	ea 81       	ldd	r30, Y+2	; 0x02
    27f2:	fb 81       	ldd	r31, Y+3	; 0x03
    27f4:	90 81       	ld	r25, Z
    27f6:	80 91 e8 03 	lds	r24, 0x03E8
    27fa:	98 17       	cp	r25, r24
    27fc:	71 f0       	breq	.+28     	; 0x281a <xTaskCheckForTimeOut+0x46>
    27fe:	ea 81       	ldd	r30, Y+2	; 0x02
    2800:	fb 81       	ldd	r31, Y+3	; 0x03
    2802:	21 81       	ldd	r18, Z+1	; 0x01
    2804:	32 81       	ldd	r19, Z+2	; 0x02
    2806:	80 91 e0 03 	lds	r24, 0x03E0
    280a:	90 91 e1 03 	lds	r25, 0x03E1
    280e:	82 17       	cp	r24, r18
    2810:	93 07       	cpc	r25, r19
    2812:	18 f0       	brcs	.+6      	; 0x281a <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2814:	81 e0       	ldi	r24, 0x01	; 1
    2816:	89 83       	std	Y+1, r24	; 0x01
    2818:	2f c0       	rjmp	.+94     	; 0x2878 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    281a:	20 91 e0 03 	lds	r18, 0x03E0
    281e:	30 91 e1 03 	lds	r19, 0x03E1
    2822:	ea 81       	ldd	r30, Y+2	; 0x02
    2824:	fb 81       	ldd	r31, Y+3	; 0x03
    2826:	81 81       	ldd	r24, Z+1	; 0x01
    2828:	92 81       	ldd	r25, Z+2	; 0x02
    282a:	28 1b       	sub	r18, r24
    282c:	39 0b       	sbc	r19, r25
    282e:	ec 81       	ldd	r30, Y+4	; 0x04
    2830:	fd 81       	ldd	r31, Y+5	; 0x05
    2832:	80 81       	ld	r24, Z
    2834:	91 81       	ldd	r25, Z+1	; 0x01
    2836:	28 17       	cp	r18, r24
    2838:	39 07       	cpc	r19, r25
    283a:	e0 f4       	brcc	.+56     	; 0x2874 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    283c:	ec 81       	ldd	r30, Y+4	; 0x04
    283e:	fd 81       	ldd	r31, Y+5	; 0x05
    2840:	40 81       	ld	r20, Z
    2842:	51 81       	ldd	r21, Z+1	; 0x01
    2844:	ea 81       	ldd	r30, Y+2	; 0x02
    2846:	fb 81       	ldd	r31, Y+3	; 0x03
    2848:	21 81       	ldd	r18, Z+1	; 0x01
    284a:	32 81       	ldd	r19, Z+2	; 0x02
    284c:	80 91 e0 03 	lds	r24, 0x03E0
    2850:	90 91 e1 03 	lds	r25, 0x03E1
    2854:	b9 01       	movw	r22, r18
    2856:	68 1b       	sub	r22, r24
    2858:	79 0b       	sbc	r23, r25
    285a:	cb 01       	movw	r24, r22
    285c:	84 0f       	add	r24, r20
    285e:	95 1f       	adc	r25, r21
    2860:	ec 81       	ldd	r30, Y+4	; 0x04
    2862:	fd 81       	ldd	r31, Y+5	; 0x05
    2864:	91 83       	std	Z+1, r25	; 0x01
    2866:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    2868:	8a 81       	ldd	r24, Y+2	; 0x02
    286a:	9b 81       	ldd	r25, Y+3	; 0x03
    286c:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2870:	19 82       	std	Y+1, r1	; 0x01
    2872:	02 c0       	rjmp	.+4      	; 0x2878 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    2874:	81 e0       	ldi	r24, 0x01	; 1
    2876:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2878:	0f 90       	pop	r0
    287a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    287c:	89 81       	ldd	r24, Y+1	; 0x01
}
    287e:	0f 90       	pop	r0
    2880:	0f 90       	pop	r0
    2882:	0f 90       	pop	r0
    2884:	0f 90       	pop	r0
    2886:	0f 90       	pop	r0
    2888:	cf 91       	pop	r28
    288a:	df 91       	pop	r29
    288c:	08 95       	ret

0000288e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    288e:	df 93       	push	r29
    2890:	cf 93       	push	r28
    2892:	cd b7       	in	r28, 0x3d	; 61
    2894:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    2896:	81 e0       	ldi	r24, 0x01	; 1
    2898:	80 93 e7 03 	sts	0x03E7, r24
}
    289c:	cf 91       	pop	r28
    289e:	df 91       	pop	r29
    28a0:	08 95       	ret

000028a2 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    28a2:	df 93       	push	r29
    28a4:	cf 93       	push	r28
    28a6:	00 d0       	rcall	.+0      	; 0x28a8 <prvIdleTask+0x6>
    28a8:	cd b7       	in	r28, 0x3d	; 61
    28aa:	de b7       	in	r29, 0x3e	; 62
    28ac:	9a 83       	std	Y+2, r25	; 0x02
    28ae:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    28b0:	0e 94 ef 14 	call	0x29de	; 0x29de <prvCheckTasksWaitingTermination>
    28b4:	fd cf       	rjmp	.-6      	; 0x28b0 <prvIdleTask+0xe>

000028b6 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    28b6:	0f 93       	push	r16
    28b8:	1f 93       	push	r17
    28ba:	df 93       	push	r29
    28bc:	cf 93       	push	r28
    28be:	cd b7       	in	r28, 0x3d	; 61
    28c0:	de b7       	in	r29, 0x3e	; 62
    28c2:	29 97       	sbiw	r28, 0x09	; 9
    28c4:	0f b6       	in	r0, 0x3f	; 63
    28c6:	f8 94       	cli
    28c8:	de bf       	out	0x3e, r29	; 62
    28ca:	0f be       	out	0x3f, r0	; 63
    28cc:	cd bf       	out	0x3d, r28	; 61
    28ce:	9a 83       	std	Y+2, r25	; 0x02
    28d0:	89 83       	std	Y+1, r24	; 0x01
    28d2:	7c 83       	std	Y+4, r23	; 0x04
    28d4:	6b 83       	std	Y+3, r22	; 0x03
    28d6:	4d 83       	std	Y+5, r20	; 0x05
    28d8:	3f 83       	std	Y+7, r19	; 0x07
    28da:	2e 83       	std	Y+6, r18	; 0x06
    28dc:	19 87       	std	Y+9, r17	; 0x09
    28de:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    28e0:	89 81       	ldd	r24, Y+1	; 0x01
    28e2:	9a 81       	ldd	r25, Y+2	; 0x02
    28e4:	49 96       	adiw	r24, 0x19	; 25
    28e6:	2b 81       	ldd	r18, Y+3	; 0x03
    28e8:	3c 81       	ldd	r19, Y+4	; 0x04
    28ea:	b9 01       	movw	r22, r18
    28ec:	48 e0       	ldi	r20, 0x08	; 8
    28ee:	50 e0       	ldi	r21, 0x00	; 0
    28f0:	0e 94 ec 15 	call	0x2bd8	; 0x2bd8 <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    28f4:	e9 81       	ldd	r30, Y+1	; 0x01
    28f6:	fa 81       	ldd	r31, Y+2	; 0x02
    28f8:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    28fa:	8d 81       	ldd	r24, Y+5	; 0x05
    28fc:	84 30       	cpi	r24, 0x04	; 4
    28fe:	10 f0       	brcs	.+4      	; 0x2904 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    2900:	83 e0       	ldi	r24, 0x03	; 3
    2902:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    2904:	e9 81       	ldd	r30, Y+1	; 0x01
    2906:	fa 81       	ldd	r31, Y+2	; 0x02
    2908:	8d 81       	ldd	r24, Y+5	; 0x05
    290a:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    290c:	89 81       	ldd	r24, Y+1	; 0x01
    290e:	9a 81       	ldd	r25, Y+2	; 0x02
    2910:	02 96       	adiw	r24, 0x02	; 2
    2912:	0e 94 33 06 	call	0xc66	; 0xc66 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2916:	89 81       	ldd	r24, Y+1	; 0x01
    2918:	9a 81       	ldd	r25, Y+2	; 0x02
    291a:	0c 96       	adiw	r24, 0x0c	; 12
    291c:	0e 94 33 06 	call	0xc66	; 0xc66 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2920:	e9 81       	ldd	r30, Y+1	; 0x01
    2922:	fa 81       	ldd	r31, Y+2	; 0x02
    2924:	89 81       	ldd	r24, Y+1	; 0x01
    2926:	9a 81       	ldd	r25, Y+2	; 0x02
    2928:	91 87       	std	Z+9, r25	; 0x09
    292a:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    292c:	8d 81       	ldd	r24, Y+5	; 0x05
    292e:	28 2f       	mov	r18, r24
    2930:	30 e0       	ldi	r19, 0x00	; 0
    2932:	84 e0       	ldi	r24, 0x04	; 4
    2934:	90 e0       	ldi	r25, 0x00	; 0
    2936:	82 1b       	sub	r24, r18
    2938:	93 0b       	sbc	r25, r19
    293a:	e9 81       	ldd	r30, Y+1	; 0x01
    293c:	fa 81       	ldd	r31, Y+2	; 0x02
    293e:	95 87       	std	Z+13, r25	; 0x0d
    2940:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2942:	e9 81       	ldd	r30, Y+1	; 0x01
    2944:	fa 81       	ldd	r31, Y+2	; 0x02
    2946:	89 81       	ldd	r24, Y+1	; 0x01
    2948:	9a 81       	ldd	r25, Y+2	; 0x02
    294a:	93 8b       	std	Z+19, r25	; 0x13
    294c:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    294e:	29 96       	adiw	r28, 0x09	; 9
    2950:	0f b6       	in	r0, 0x3f	; 63
    2952:	f8 94       	cli
    2954:	de bf       	out	0x3e, r29	; 62
    2956:	0f be       	out	0x3f, r0	; 63
    2958:	cd bf       	out	0x3d, r28	; 61
    295a:	cf 91       	pop	r28
    295c:	df 91       	pop	r29
    295e:	1f 91       	pop	r17
    2960:	0f 91       	pop	r16
    2962:	08 95       	ret

00002964 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    2964:	df 93       	push	r29
    2966:	cf 93       	push	r28
    2968:	0f 92       	push	r0
    296a:	cd b7       	in	r28, 0x3d	; 61
    296c:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    296e:	19 82       	std	Y+1, r1	; 0x01
    2970:	13 c0       	rjmp	.+38     	; 0x2998 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2972:	89 81       	ldd	r24, Y+1	; 0x01
    2974:	28 2f       	mov	r18, r24
    2976:	30 e0       	ldi	r19, 0x00	; 0
    2978:	c9 01       	movw	r24, r18
    297a:	88 0f       	add	r24, r24
    297c:	99 1f       	adc	r25, r25
    297e:	88 0f       	add	r24, r24
    2980:	99 1f       	adc	r25, r25
    2982:	88 0f       	add	r24, r24
    2984:	99 1f       	adc	r25, r25
    2986:	82 0f       	add	r24, r18
    2988:	93 1f       	adc	r25, r19
    298a:	86 51       	subi	r24, 0x16	; 22
    298c:	9c 4f       	sbci	r25, 0xFC	; 252
    298e:	0e 94 09 06 	call	0xc12	; 0xc12 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2992:	89 81       	ldd	r24, Y+1	; 0x01
    2994:	8f 5f       	subi	r24, 0xFF	; 255
    2996:	89 83       	std	Y+1, r24	; 0x01
    2998:	89 81       	ldd	r24, Y+1	; 0x01
    299a:	84 30       	cpi	r24, 0x04	; 4
    299c:	50 f3       	brcs	.-44     	; 0x2972 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    299e:	8e e0       	ldi	r24, 0x0E	; 14
    29a0:	94 e0       	ldi	r25, 0x04	; 4
    29a2:	0e 94 09 06 	call	0xc12	; 0xc12 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    29a6:	87 e1       	ldi	r24, 0x17	; 23
    29a8:	94 e0       	ldi	r25, 0x04	; 4
    29aa:	0e 94 09 06 	call	0xc12	; 0xc12 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    29ae:	84 e2       	ldi	r24, 0x24	; 36
    29b0:	94 e0       	ldi	r25, 0x04	; 4
    29b2:	0e 94 09 06 	call	0xc12	; 0xc12 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    29b6:	8d e2       	ldi	r24, 0x2D	; 45
    29b8:	94 e0       	ldi	r25, 0x04	; 4
    29ba:	0e 94 09 06 	call	0xc12	; 0xc12 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    29be:	8e e0       	ldi	r24, 0x0E	; 14
    29c0:	94 e0       	ldi	r25, 0x04	; 4
    29c2:	90 93 21 04 	sts	0x0421, r25
    29c6:	80 93 20 04 	sts	0x0420, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    29ca:	87 e1       	ldi	r24, 0x17	; 23
    29cc:	94 e0       	ldi	r25, 0x04	; 4
    29ce:	90 93 23 04 	sts	0x0423, r25
    29d2:	80 93 22 04 	sts	0x0422, r24
}
    29d6:	0f 90       	pop	r0
    29d8:	cf 91       	pop	r28
    29da:	df 91       	pop	r29
    29dc:	08 95       	ret

000029de <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    29de:	df 93       	push	r29
    29e0:	cf 93       	push	r28
    29e2:	00 d0       	rcall	.+0      	; 0x29e4 <prvCheckTasksWaitingTermination+0x6>
    29e4:	0f 92       	push	r0
    29e6:	cd b7       	in	r28, 0x3d	; 61
    29e8:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    29ea:	80 91 de 03 	lds	r24, 0x03DE
    29ee:	88 23       	and	r24, r24
    29f0:	71 f1       	breq	.+92     	; 0x2a4e <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    29f2:	0e 94 2d 11 	call	0x225a	; 0x225a <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    29f6:	80 91 2d 04 	lds	r24, 0x042D
    29fa:	1b 82       	std	Y+3, r1	; 0x03
    29fc:	88 23       	and	r24, r24
    29fe:	11 f4       	brne	.+4      	; 0x2a04 <prvCheckTasksWaitingTermination+0x26>
    2a00:	81 e0       	ldi	r24, 0x01	; 1
    2a02:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    2a04:	0e 94 39 11 	call	0x2272	; 0x2272 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    2a08:	8b 81       	ldd	r24, Y+3	; 0x03
    2a0a:	88 23       	and	r24, r24
    2a0c:	01 f5       	brne	.+64     	; 0x2a4e <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    2a0e:	0f b6       	in	r0, 0x3f	; 63
    2a10:	f8 94       	cli
    2a12:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2a14:	e0 91 32 04 	lds	r30, 0x0432
    2a18:	f0 91 33 04 	lds	r31, 0x0433
    2a1c:	86 81       	ldd	r24, Z+6	; 0x06
    2a1e:	97 81       	ldd	r25, Z+7	; 0x07
    2a20:	9a 83       	std	Y+2, r25	; 0x02
    2a22:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    2a24:	89 81       	ldd	r24, Y+1	; 0x01
    2a26:	9a 81       	ldd	r25, Y+2	; 0x02
    2a28:	02 96       	adiw	r24, 0x02	; 2
    2a2a:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <vListRemove>
					--uxCurrentNumberOfTasks;
    2a2e:	80 91 df 03 	lds	r24, 0x03DF
    2a32:	81 50       	subi	r24, 0x01	; 1
    2a34:	80 93 df 03 	sts	0x03DF, r24
					--uxTasksDeleted;
    2a38:	80 91 de 03 	lds	r24, 0x03DE
    2a3c:	81 50       	subi	r24, 0x01	; 1
    2a3e:	80 93 de 03 	sts	0x03DE, r24
				}
				taskEXIT_CRITICAL();
    2a42:	0f 90       	pop	r0
    2a44:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    2a46:	89 81       	ldd	r24, Y+1	; 0x01
    2a48:	9a 81       	ldd	r25, Y+2	; 0x02
    2a4a:	0e 94 c6 15 	call	0x2b8c	; 0x2b8c <prvDeleteTCB>
			}
		}
	}
	#endif
}
    2a4e:	0f 90       	pop	r0
    2a50:	0f 90       	pop	r0
    2a52:	0f 90       	pop	r0
    2a54:	cf 91       	pop	r28
    2a56:	df 91       	pop	r29
    2a58:	08 95       	ret

00002a5a <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2a5a:	df 93       	push	r29
    2a5c:	cf 93       	push	r28
    2a5e:	00 d0       	rcall	.+0      	; 0x2a60 <prvAddCurrentTaskToDelayedList+0x6>
    2a60:	cd b7       	in	r28, 0x3d	; 61
    2a62:	de b7       	in	r29, 0x3e	; 62
    2a64:	9a 83       	std	Y+2, r25	; 0x02
    2a66:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2a68:	e0 91 dc 03 	lds	r30, 0x03DC
    2a6c:	f0 91 dd 03 	lds	r31, 0x03DD
    2a70:	89 81       	ldd	r24, Y+1	; 0x01
    2a72:	9a 81       	ldd	r25, Y+2	; 0x02
    2a74:	93 83       	std	Z+3, r25	; 0x03
    2a76:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    2a78:	20 91 e0 03 	lds	r18, 0x03E0
    2a7c:	30 91 e1 03 	lds	r19, 0x03E1
    2a80:	89 81       	ldd	r24, Y+1	; 0x01
    2a82:	9a 81       	ldd	r25, Y+2	; 0x02
    2a84:	82 17       	cp	r24, r18
    2a86:	93 07       	cpc	r25, r19
    2a88:	70 f4       	brcc	.+28     	; 0x2aa6 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2a8a:	80 91 22 04 	lds	r24, 0x0422
    2a8e:	90 91 23 04 	lds	r25, 0x0423
    2a92:	20 91 dc 03 	lds	r18, 0x03DC
    2a96:	30 91 dd 03 	lds	r19, 0x03DD
    2a9a:	2e 5f       	subi	r18, 0xFE	; 254
    2a9c:	3f 4f       	sbci	r19, 0xFF	; 255
    2a9e:	b9 01       	movw	r22, r18
    2aa0:	0e 94 8f 06 	call	0xd1e	; 0xd1e <vListInsert>
    2aa4:	1e c0       	rjmp	.+60     	; 0x2ae2 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2aa6:	40 91 20 04 	lds	r20, 0x0420
    2aaa:	50 91 21 04 	lds	r21, 0x0421
    2aae:	80 91 dc 03 	lds	r24, 0x03DC
    2ab2:	90 91 dd 03 	lds	r25, 0x03DD
    2ab6:	9c 01       	movw	r18, r24
    2ab8:	2e 5f       	subi	r18, 0xFE	; 254
    2aba:	3f 4f       	sbci	r19, 0xFF	; 255
    2abc:	ca 01       	movw	r24, r20
    2abe:	b9 01       	movw	r22, r18
    2ac0:	0e 94 8f 06 	call	0xd1e	; 0xd1e <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2ac4:	20 91 7d 00 	lds	r18, 0x007D
    2ac8:	30 91 7e 00 	lds	r19, 0x007E
    2acc:	89 81       	ldd	r24, Y+1	; 0x01
    2ace:	9a 81       	ldd	r25, Y+2	; 0x02
    2ad0:	82 17       	cp	r24, r18
    2ad2:	93 07       	cpc	r25, r19
    2ad4:	30 f4       	brcc	.+12     	; 0x2ae2 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2ad6:	89 81       	ldd	r24, Y+1	; 0x01
    2ad8:	9a 81       	ldd	r25, Y+2	; 0x02
    2ada:	90 93 7e 00 	sts	0x007E, r25
    2ade:	80 93 7d 00 	sts	0x007D, r24
		}
	}
}
    2ae2:	0f 90       	pop	r0
    2ae4:	0f 90       	pop	r0
    2ae6:	cf 91       	pop	r28
    2ae8:	df 91       	pop	r29
    2aea:	08 95       	ret

00002aec <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    2aec:	df 93       	push	r29
    2aee:	cf 93       	push	r28
    2af0:	cd b7       	in	r28, 0x3d	; 61
    2af2:	de b7       	in	r29, 0x3e	; 62
    2af4:	28 97       	sbiw	r28, 0x08	; 8
    2af6:	0f b6       	in	r0, 0x3f	; 63
    2af8:	f8 94       	cli
    2afa:	de bf       	out	0x3e, r29	; 62
    2afc:	0f be       	out	0x3f, r0	; 63
    2afe:	cd bf       	out	0x3d, r28	; 61
    2b00:	9c 83       	std	Y+4, r25	; 0x04
    2b02:	8b 83       	std	Y+3, r24	; 0x03
    2b04:	7e 83       	std	Y+6, r23	; 0x06
    2b06:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2b08:	81 e2       	ldi	r24, 0x21	; 33
    2b0a:	90 e0       	ldi	r25, 0x00	; 0
    2b0c:	0e 94 9d 05 	call	0xb3a	; 0xb3a <pvPortMalloc>
    2b10:	9a 83       	std	Y+2, r25	; 0x02
    2b12:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    2b14:	89 81       	ldd	r24, Y+1	; 0x01
    2b16:	9a 81       	ldd	r25, Y+2	; 0x02
    2b18:	00 97       	sbiw	r24, 0x00	; 0
    2b1a:	69 f1       	breq	.+90     	; 0x2b76 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2b1c:	8d 81       	ldd	r24, Y+5	; 0x05
    2b1e:	9e 81       	ldd	r25, Y+6	; 0x06
    2b20:	00 97       	sbiw	r24, 0x00	; 0
    2b22:	39 f4       	brne	.+14     	; 0x2b32 <prvAllocateTCBAndStack+0x46>
    2b24:	8b 81       	ldd	r24, Y+3	; 0x03
    2b26:	9c 81       	ldd	r25, Y+4	; 0x04
    2b28:	0e 94 9d 05 	call	0xb3a	; 0xb3a <pvPortMalloc>
    2b2c:	98 87       	std	Y+8, r25	; 0x08
    2b2e:	8f 83       	std	Y+7, r24	; 0x07
    2b30:	04 c0       	rjmp	.+8      	; 0x2b3a <prvAllocateTCBAndStack+0x4e>
    2b32:	8d 81       	ldd	r24, Y+5	; 0x05
    2b34:	9e 81       	ldd	r25, Y+6	; 0x06
    2b36:	98 87       	std	Y+8, r25	; 0x08
    2b38:	8f 83       	std	Y+7, r24	; 0x07
    2b3a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b3c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b3e:	8f 81       	ldd	r24, Y+7	; 0x07
    2b40:	98 85       	ldd	r25, Y+8	; 0x08
    2b42:	90 8f       	std	Z+24, r25	; 0x18
    2b44:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2b46:	e9 81       	ldd	r30, Y+1	; 0x01
    2b48:	fa 81       	ldd	r31, Y+2	; 0x02
    2b4a:	87 89       	ldd	r24, Z+23	; 0x17
    2b4c:	90 8d       	ldd	r25, Z+24	; 0x18
    2b4e:	00 97       	sbiw	r24, 0x00	; 0
    2b50:	39 f4       	brne	.+14     	; 0x2b60 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2b52:	89 81       	ldd	r24, Y+1	; 0x01
    2b54:	9a 81       	ldd	r25, Y+2	; 0x02
    2b56:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <vPortFree>
			pxNewTCB = NULL;
    2b5a:	1a 82       	std	Y+2, r1	; 0x02
    2b5c:	19 82       	std	Y+1, r1	; 0x01
    2b5e:	0b c0       	rjmp	.+22     	; 0x2b76 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2b60:	e9 81       	ldd	r30, Y+1	; 0x01
    2b62:	fa 81       	ldd	r31, Y+2	; 0x02
    2b64:	87 89       	ldd	r24, Z+23	; 0x17
    2b66:	90 8d       	ldd	r25, Z+24	; 0x18
    2b68:	2b 81       	ldd	r18, Y+3	; 0x03
    2b6a:	3c 81       	ldd	r19, Y+4	; 0x04
    2b6c:	65 ea       	ldi	r22, 0xA5	; 165
    2b6e:	70 e0       	ldi	r23, 0x00	; 0
    2b70:	a9 01       	movw	r20, r18
    2b72:	0e 94 e5 15 	call	0x2bca	; 0x2bca <memset>
		}
	}

	return pxNewTCB;
    2b76:	89 81       	ldd	r24, Y+1	; 0x01
    2b78:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2b7a:	28 96       	adiw	r28, 0x08	; 8
    2b7c:	0f b6       	in	r0, 0x3f	; 63
    2b7e:	f8 94       	cli
    2b80:	de bf       	out	0x3e, r29	; 62
    2b82:	0f be       	out	0x3f, r0	; 63
    2b84:	cd bf       	out	0x3d, r28	; 61
    2b86:	cf 91       	pop	r28
    2b88:	df 91       	pop	r29
    2b8a:	08 95       	ret

00002b8c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    2b8c:	df 93       	push	r29
    2b8e:	cf 93       	push	r28
    2b90:	00 d0       	rcall	.+0      	; 0x2b92 <prvDeleteTCB+0x6>
    2b92:	cd b7       	in	r28, 0x3d	; 61
    2b94:	de b7       	in	r29, 0x3e	; 62
    2b96:	9a 83       	std	Y+2, r25	; 0x02
    2b98:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    2b9a:	e9 81       	ldd	r30, Y+1	; 0x01
    2b9c:	fa 81       	ldd	r31, Y+2	; 0x02
    2b9e:	87 89       	ldd	r24, Z+23	; 0x17
    2ba0:	90 8d       	ldd	r25, Z+24	; 0x18
    2ba2:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <vPortFree>
		vPortFree( pxTCB );
    2ba6:	89 81       	ldd	r24, Y+1	; 0x01
    2ba8:	9a 81       	ldd	r25, Y+2	; 0x02
    2baa:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <vPortFree>
	}
    2bae:	0f 90       	pop	r0
    2bb0:	0f 90       	pop	r0
    2bb2:	cf 91       	pop	r28
    2bb4:	df 91       	pop	r29
    2bb6:	08 95       	ret

00002bb8 <memcpy>:
    2bb8:	fb 01       	movw	r30, r22
    2bba:	dc 01       	movw	r26, r24
    2bbc:	02 c0       	rjmp	.+4      	; 0x2bc2 <memcpy+0xa>
    2bbe:	01 90       	ld	r0, Z+
    2bc0:	0d 92       	st	X+, r0
    2bc2:	41 50       	subi	r20, 0x01	; 1
    2bc4:	50 40       	sbci	r21, 0x00	; 0
    2bc6:	d8 f7       	brcc	.-10     	; 0x2bbe <memcpy+0x6>
    2bc8:	08 95       	ret

00002bca <memset>:
    2bca:	dc 01       	movw	r26, r24
    2bcc:	01 c0       	rjmp	.+2      	; 0x2bd0 <memset+0x6>
    2bce:	6d 93       	st	X+, r22
    2bd0:	41 50       	subi	r20, 0x01	; 1
    2bd2:	50 40       	sbci	r21, 0x00	; 0
    2bd4:	e0 f7       	brcc	.-8      	; 0x2bce <memset+0x4>
    2bd6:	08 95       	ret

00002bd8 <strncpy>:
    2bd8:	fb 01       	movw	r30, r22
    2bda:	dc 01       	movw	r26, r24
    2bdc:	41 50       	subi	r20, 0x01	; 1
    2bde:	50 40       	sbci	r21, 0x00	; 0
    2be0:	48 f0       	brcs	.+18     	; 0x2bf4 <strncpy+0x1c>
    2be2:	01 90       	ld	r0, Z+
    2be4:	0d 92       	st	X+, r0
    2be6:	00 20       	and	r0, r0
    2be8:	c9 f7       	brne	.-14     	; 0x2bdc <strncpy+0x4>
    2bea:	01 c0       	rjmp	.+2      	; 0x2bee <strncpy+0x16>
    2bec:	1d 92       	st	X+, r1
    2bee:	41 50       	subi	r20, 0x01	; 1
    2bf0:	50 40       	sbci	r21, 0x00	; 0
    2bf2:	e0 f7       	brcc	.-8      	; 0x2bec <strncpy+0x14>
    2bf4:	08 95       	ret

00002bf6 <_exit>:
    2bf6:	f8 94       	cli

00002bf8 <__stop_program>:
    2bf8:	ff cf       	rjmp	.-2      	; 0x2bf8 <__stop_program>
