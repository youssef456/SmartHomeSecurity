
FreeRtos_btn_led.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007d42  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000130  00800060  00007d42  00007dd6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000463  00800190  00800190  00007f06  2**0
                  ALLOC
  3 .stab         00008550  00000000  00000000  00007f08  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004018  00000000  00000000  00010458  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  00014470  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001f0  00000000  00000000  00014610  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000240c  00000000  00000000  00014800  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001377  00000000  00000000  00016c0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011d8  00000000  00000000  00017f83  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001c0  00000000  00000000  0001915c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002f3  00000000  00000000  0001931c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000009ce  00000000  00000000  0001960f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00019fdd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 d6 2a 	jmp	0x55ac	; 0x55ac <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e4       	ldi	r30, 0x42	; 66
      68:	fd e7       	ldi	r31, 0x7D	; 125
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 39       	cpi	r26, 0x90	; 144
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	a0 e9       	ldi	r26, 0x90	; 144
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 3f       	cpi	r26, 0xF3	; 243
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 bc 27 	call	0x4f78	; 0x4f78 <main>
      8a:	0c 94 9f 3e 	jmp	0x7d3e	; 0x7d3e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 b3 04 	call	0x966	; 0x966 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 b3 04 	call	0x966	; 0x966 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 5f 3e 	jmp	0x7cbe	; 0x7cbe <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a0 e7       	ldi	r26, 0x70	; 112
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 7b 3e 	jmp	0x7cf6	; 0x7cf6 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 6b 3e 	jmp	0x7cd6	; 0x7cd6 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 2b 06 	call	0xc56	; 0xc56 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 2b 06 	call	0xc56	; 0xc56 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 56 05 	call	0xaac	; 0xaac <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 87 3e 	jmp	0x7d0e	; 0x7d0e <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 6b 3e 	jmp	0x7cd6	; 0x7cd6 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 2b 06 	call	0xc56	; 0xc56 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 2b 06 	call	0xc56	; 0xc56 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 56 05 	call	0xaac	; 0xaac <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 87 3e 	jmp	0x7d0e	; 0x7d0e <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 5f 3e 	jmp	0x7cbe	; 0x7cbe <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 2b 06 	call	0xc56	; 0xc56 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 2b 06 	call	0xc56	; 0xc56 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	80 e7       	ldi	r24, 0x70	; 112
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 56 05 	call	0xaac	; 0xaac <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 7b 3e 	jmp	0x7cf6	; 0x7cf6 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 67 3e 	jmp	0x7cce	; 0x7cce <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 2b 06 	call	0xc56	; 0xc56 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 2b 06 	call	0xc56	; 0xc56 <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	60 e7       	ldi	r22, 0x70	; 112
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 56 05 	call	0xaac	; 0xaac <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 83 3e 	jmp	0x7d06	; 0x7d06 <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 6b 3e 	jmp	0x7cd6	; 0x7cd6 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 2b 06 	call	0xc56	; 0xc56 <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 2b 06 	call	0xc56	; 0xc56 <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 a3 06 	call	0xd46	; 0xd46 <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 87 3e 	jmp	0x7d0e	; 0x7d0e <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 6b 3e 	jmp	0x7cd6	; 0x7cd6 <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 2b 06 	call	0xc56	; 0xc56 <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 2b 06 	call	0xc56	; 0xc56 <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 a3 06 	call	0xd46	; 0xd46 <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 87 3e 	jmp	0x7d0e	; 0x7d0e <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 6b 3e 	jmp	0x7cd6	; 0x7cd6 <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 2b 06 	call	0xc56	; 0xc56 <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 2b 06 	call	0xc56	; 0xc56 <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 a3 06 	call	0xd46	; 0xd46 <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 87 3e 	jmp	0x7d0e	; 0x7d0e <__epilogue_restores__+0x18>

000008aa <__floatsisf>:
     8aa:	a8 e0       	ldi	r26, 0x08	; 8
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 68 3e 	jmp	0x7cd0	; 0x7cd0 <__prologue_saves__+0x12>
     8b6:	9b 01       	movw	r18, r22
     8b8:	ac 01       	movw	r20, r24
     8ba:	83 e0       	ldi	r24, 0x03	; 3
     8bc:	89 83       	std	Y+1, r24	; 0x01
     8be:	da 01       	movw	r26, r20
     8c0:	c9 01       	movw	r24, r18
     8c2:	88 27       	eor	r24, r24
     8c4:	b7 fd       	sbrc	r27, 7
     8c6:	83 95       	inc	r24
     8c8:	99 27       	eor	r25, r25
     8ca:	aa 27       	eor	r26, r26
     8cc:	bb 27       	eor	r27, r27
     8ce:	b8 2e       	mov	r11, r24
     8d0:	21 15       	cp	r18, r1
     8d2:	31 05       	cpc	r19, r1
     8d4:	41 05       	cpc	r20, r1
     8d6:	51 05       	cpc	r21, r1
     8d8:	19 f4       	brne	.+6      	; 0x8e0 <__floatsisf+0x36>
     8da:	82 e0       	ldi	r24, 0x02	; 2
     8dc:	89 83       	std	Y+1, r24	; 0x01
     8de:	3a c0       	rjmp	.+116    	; 0x954 <__floatsisf+0xaa>
     8e0:	88 23       	and	r24, r24
     8e2:	a9 f0       	breq	.+42     	; 0x90e <__floatsisf+0x64>
     8e4:	20 30       	cpi	r18, 0x00	; 0
     8e6:	80 e0       	ldi	r24, 0x00	; 0
     8e8:	38 07       	cpc	r19, r24
     8ea:	80 e0       	ldi	r24, 0x00	; 0
     8ec:	48 07       	cpc	r20, r24
     8ee:	80 e8       	ldi	r24, 0x80	; 128
     8f0:	58 07       	cpc	r21, r24
     8f2:	29 f4       	brne	.+10     	; 0x8fe <__floatsisf+0x54>
     8f4:	60 e0       	ldi	r22, 0x00	; 0
     8f6:	70 e0       	ldi	r23, 0x00	; 0
     8f8:	80 e0       	ldi	r24, 0x00	; 0
     8fa:	9f ec       	ldi	r25, 0xCF	; 207
     8fc:	30 c0       	rjmp	.+96     	; 0x95e <__floatsisf+0xb4>
     8fe:	ee 24       	eor	r14, r14
     900:	ff 24       	eor	r15, r15
     902:	87 01       	movw	r16, r14
     904:	e2 1a       	sub	r14, r18
     906:	f3 0a       	sbc	r15, r19
     908:	04 0b       	sbc	r16, r20
     90a:	15 0b       	sbc	r17, r21
     90c:	02 c0       	rjmp	.+4      	; 0x912 <__floatsisf+0x68>
     90e:	79 01       	movw	r14, r18
     910:	8a 01       	movw	r16, r20
     912:	8e e1       	ldi	r24, 0x1E	; 30
     914:	c8 2e       	mov	r12, r24
     916:	d1 2c       	mov	r13, r1
     918:	dc 82       	std	Y+4, r13	; 0x04
     91a:	cb 82       	std	Y+3, r12	; 0x03
     91c:	ed 82       	std	Y+5, r14	; 0x05
     91e:	fe 82       	std	Y+6, r15	; 0x06
     920:	0f 83       	std	Y+7, r16	; 0x07
     922:	18 87       	std	Y+8, r17	; 0x08
     924:	c8 01       	movw	r24, r16
     926:	b7 01       	movw	r22, r14
     928:	0e 94 07 05 	call	0xa0e	; 0xa0e <__clzsi2>
     92c:	01 97       	sbiw	r24, 0x01	; 1
     92e:	18 16       	cp	r1, r24
     930:	19 06       	cpc	r1, r25
     932:	84 f4       	brge	.+32     	; 0x954 <__floatsisf+0xaa>
     934:	08 2e       	mov	r0, r24
     936:	04 c0       	rjmp	.+8      	; 0x940 <__floatsisf+0x96>
     938:	ee 0c       	add	r14, r14
     93a:	ff 1c       	adc	r15, r15
     93c:	00 1f       	adc	r16, r16
     93e:	11 1f       	adc	r17, r17
     940:	0a 94       	dec	r0
     942:	d2 f7       	brpl	.-12     	; 0x938 <__floatsisf+0x8e>
     944:	ed 82       	std	Y+5, r14	; 0x05
     946:	fe 82       	std	Y+6, r15	; 0x06
     948:	0f 83       	std	Y+7, r16	; 0x07
     94a:	18 87       	std	Y+8, r17	; 0x08
     94c:	c8 1a       	sub	r12, r24
     94e:	d9 0a       	sbc	r13, r25
     950:	dc 82       	std	Y+4, r13	; 0x04
     952:	cb 82       	std	Y+3, r12	; 0x03
     954:	ba 82       	std	Y+2, r11	; 0x02
     956:	ce 01       	movw	r24, r28
     958:	01 96       	adiw	r24, 0x01	; 1
     95a:	0e 94 56 05 	call	0xaac	; 0xaac <__pack_f>
     95e:	28 96       	adiw	r28, 0x08	; 8
     960:	e9 e0       	ldi	r30, 0x09	; 9
     962:	0c 94 84 3e 	jmp	0x7d08	; 0x7d08 <__epilogue_restores__+0x12>

00000966 <__fixsfsi>:
     966:	ac e0       	ldi	r26, 0x0C	; 12
     968:	b0 e0       	ldi	r27, 0x00	; 0
     96a:	e9 eb       	ldi	r30, 0xB9	; 185
     96c:	f4 e0       	ldi	r31, 0x04	; 4
     96e:	0c 94 6f 3e 	jmp	0x7cde	; 0x7cde <__prologue_saves__+0x20>
     972:	69 83       	std	Y+1, r22	; 0x01
     974:	7a 83       	std	Y+2, r23	; 0x02
     976:	8b 83       	std	Y+3, r24	; 0x03
     978:	9c 83       	std	Y+4, r25	; 0x04
     97a:	ce 01       	movw	r24, r28
     97c:	01 96       	adiw	r24, 0x01	; 1
     97e:	be 01       	movw	r22, r28
     980:	6b 5f       	subi	r22, 0xFB	; 251
     982:	7f 4f       	sbci	r23, 0xFF	; 255
     984:	0e 94 2b 06 	call	0xc56	; 0xc56 <__unpack_f>
     988:	8d 81       	ldd	r24, Y+5	; 0x05
     98a:	82 30       	cpi	r24, 0x02	; 2
     98c:	61 f1       	breq	.+88     	; 0x9e6 <__fixsfsi+0x80>
     98e:	82 30       	cpi	r24, 0x02	; 2
     990:	50 f1       	brcs	.+84     	; 0x9e6 <__fixsfsi+0x80>
     992:	84 30       	cpi	r24, 0x04	; 4
     994:	21 f4       	brne	.+8      	; 0x99e <__fixsfsi+0x38>
     996:	8e 81       	ldd	r24, Y+6	; 0x06
     998:	88 23       	and	r24, r24
     99a:	51 f1       	breq	.+84     	; 0x9f0 <__fixsfsi+0x8a>
     99c:	2e c0       	rjmp	.+92     	; 0x9fa <__fixsfsi+0x94>
     99e:	2f 81       	ldd	r18, Y+7	; 0x07
     9a0:	38 85       	ldd	r19, Y+8	; 0x08
     9a2:	37 fd       	sbrc	r19, 7
     9a4:	20 c0       	rjmp	.+64     	; 0x9e6 <__fixsfsi+0x80>
     9a6:	6e 81       	ldd	r22, Y+6	; 0x06
     9a8:	2f 31       	cpi	r18, 0x1F	; 31
     9aa:	31 05       	cpc	r19, r1
     9ac:	1c f0       	brlt	.+6      	; 0x9b4 <__fixsfsi+0x4e>
     9ae:	66 23       	and	r22, r22
     9b0:	f9 f0       	breq	.+62     	; 0x9f0 <__fixsfsi+0x8a>
     9b2:	23 c0       	rjmp	.+70     	; 0x9fa <__fixsfsi+0x94>
     9b4:	8e e1       	ldi	r24, 0x1E	; 30
     9b6:	90 e0       	ldi	r25, 0x00	; 0
     9b8:	82 1b       	sub	r24, r18
     9ba:	93 0b       	sbc	r25, r19
     9bc:	29 85       	ldd	r18, Y+9	; 0x09
     9be:	3a 85       	ldd	r19, Y+10	; 0x0a
     9c0:	4b 85       	ldd	r20, Y+11	; 0x0b
     9c2:	5c 85       	ldd	r21, Y+12	; 0x0c
     9c4:	04 c0       	rjmp	.+8      	; 0x9ce <__fixsfsi+0x68>
     9c6:	56 95       	lsr	r21
     9c8:	47 95       	ror	r20
     9ca:	37 95       	ror	r19
     9cc:	27 95       	ror	r18
     9ce:	8a 95       	dec	r24
     9d0:	d2 f7       	brpl	.-12     	; 0x9c6 <__fixsfsi+0x60>
     9d2:	66 23       	and	r22, r22
     9d4:	b1 f0       	breq	.+44     	; 0xa02 <__fixsfsi+0x9c>
     9d6:	50 95       	com	r21
     9d8:	40 95       	com	r20
     9da:	30 95       	com	r19
     9dc:	21 95       	neg	r18
     9de:	3f 4f       	sbci	r19, 0xFF	; 255
     9e0:	4f 4f       	sbci	r20, 0xFF	; 255
     9e2:	5f 4f       	sbci	r21, 0xFF	; 255
     9e4:	0e c0       	rjmp	.+28     	; 0xa02 <__fixsfsi+0x9c>
     9e6:	20 e0       	ldi	r18, 0x00	; 0
     9e8:	30 e0       	ldi	r19, 0x00	; 0
     9ea:	40 e0       	ldi	r20, 0x00	; 0
     9ec:	50 e0       	ldi	r21, 0x00	; 0
     9ee:	09 c0       	rjmp	.+18     	; 0xa02 <__fixsfsi+0x9c>
     9f0:	2f ef       	ldi	r18, 0xFF	; 255
     9f2:	3f ef       	ldi	r19, 0xFF	; 255
     9f4:	4f ef       	ldi	r20, 0xFF	; 255
     9f6:	5f e7       	ldi	r21, 0x7F	; 127
     9f8:	04 c0       	rjmp	.+8      	; 0xa02 <__fixsfsi+0x9c>
     9fa:	20 e0       	ldi	r18, 0x00	; 0
     9fc:	30 e0       	ldi	r19, 0x00	; 0
     9fe:	40 e0       	ldi	r20, 0x00	; 0
     a00:	50 e8       	ldi	r21, 0x80	; 128
     a02:	b9 01       	movw	r22, r18
     a04:	ca 01       	movw	r24, r20
     a06:	2c 96       	adiw	r28, 0x0c	; 12
     a08:	e2 e0       	ldi	r30, 0x02	; 2
     a0a:	0c 94 8b 3e 	jmp	0x7d16	; 0x7d16 <__epilogue_restores__+0x20>

00000a0e <__clzsi2>:
     a0e:	ef 92       	push	r14
     a10:	ff 92       	push	r15
     a12:	0f 93       	push	r16
     a14:	1f 93       	push	r17
     a16:	7b 01       	movw	r14, r22
     a18:	8c 01       	movw	r16, r24
     a1a:	80 e0       	ldi	r24, 0x00	; 0
     a1c:	e8 16       	cp	r14, r24
     a1e:	80 e0       	ldi	r24, 0x00	; 0
     a20:	f8 06       	cpc	r15, r24
     a22:	81 e0       	ldi	r24, 0x01	; 1
     a24:	08 07       	cpc	r16, r24
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	18 07       	cpc	r17, r24
     a2a:	88 f4       	brcc	.+34     	; 0xa4e <__clzsi2+0x40>
     a2c:	8f ef       	ldi	r24, 0xFF	; 255
     a2e:	e8 16       	cp	r14, r24
     a30:	f1 04       	cpc	r15, r1
     a32:	01 05       	cpc	r16, r1
     a34:	11 05       	cpc	r17, r1
     a36:	31 f0       	breq	.+12     	; 0xa44 <__clzsi2+0x36>
     a38:	28 f0       	brcs	.+10     	; 0xa44 <__clzsi2+0x36>
     a3a:	88 e0       	ldi	r24, 0x08	; 8
     a3c:	90 e0       	ldi	r25, 0x00	; 0
     a3e:	a0 e0       	ldi	r26, 0x00	; 0
     a40:	b0 e0       	ldi	r27, 0x00	; 0
     a42:	17 c0       	rjmp	.+46     	; 0xa72 <__clzsi2+0x64>
     a44:	80 e0       	ldi	r24, 0x00	; 0
     a46:	90 e0       	ldi	r25, 0x00	; 0
     a48:	a0 e0       	ldi	r26, 0x00	; 0
     a4a:	b0 e0       	ldi	r27, 0x00	; 0
     a4c:	12 c0       	rjmp	.+36     	; 0xa72 <__clzsi2+0x64>
     a4e:	80 e0       	ldi	r24, 0x00	; 0
     a50:	e8 16       	cp	r14, r24
     a52:	80 e0       	ldi	r24, 0x00	; 0
     a54:	f8 06       	cpc	r15, r24
     a56:	80 e0       	ldi	r24, 0x00	; 0
     a58:	08 07       	cpc	r16, r24
     a5a:	81 e0       	ldi	r24, 0x01	; 1
     a5c:	18 07       	cpc	r17, r24
     a5e:	28 f0       	brcs	.+10     	; 0xa6a <__clzsi2+0x5c>
     a60:	88 e1       	ldi	r24, 0x18	; 24
     a62:	90 e0       	ldi	r25, 0x00	; 0
     a64:	a0 e0       	ldi	r26, 0x00	; 0
     a66:	b0 e0       	ldi	r27, 0x00	; 0
     a68:	04 c0       	rjmp	.+8      	; 0xa72 <__clzsi2+0x64>
     a6a:	80 e1       	ldi	r24, 0x10	; 16
     a6c:	90 e0       	ldi	r25, 0x00	; 0
     a6e:	a0 e0       	ldi	r26, 0x00	; 0
     a70:	b0 e0       	ldi	r27, 0x00	; 0
     a72:	20 e2       	ldi	r18, 0x20	; 32
     a74:	30 e0       	ldi	r19, 0x00	; 0
     a76:	40 e0       	ldi	r20, 0x00	; 0
     a78:	50 e0       	ldi	r21, 0x00	; 0
     a7a:	28 1b       	sub	r18, r24
     a7c:	39 0b       	sbc	r19, r25
     a7e:	4a 0b       	sbc	r20, r26
     a80:	5b 0b       	sbc	r21, r27
     a82:	04 c0       	rjmp	.+8      	; 0xa8c <__clzsi2+0x7e>
     a84:	16 95       	lsr	r17
     a86:	07 95       	ror	r16
     a88:	f7 94       	ror	r15
     a8a:	e7 94       	ror	r14
     a8c:	8a 95       	dec	r24
     a8e:	d2 f7       	brpl	.-12     	; 0xa84 <__clzsi2+0x76>
     a90:	f7 01       	movw	r30, r14
     a92:	e8 58       	subi	r30, 0x88	; 136
     a94:	ff 4f       	sbci	r31, 0xFF	; 255
     a96:	80 81       	ld	r24, Z
     a98:	28 1b       	sub	r18, r24
     a9a:	31 09       	sbc	r19, r1
     a9c:	41 09       	sbc	r20, r1
     a9e:	51 09       	sbc	r21, r1
     aa0:	c9 01       	movw	r24, r18
     aa2:	1f 91       	pop	r17
     aa4:	0f 91       	pop	r16
     aa6:	ff 90       	pop	r15
     aa8:	ef 90       	pop	r14
     aaa:	08 95       	ret

00000aac <__pack_f>:
     aac:	df 92       	push	r13
     aae:	ef 92       	push	r14
     ab0:	ff 92       	push	r15
     ab2:	0f 93       	push	r16
     ab4:	1f 93       	push	r17
     ab6:	fc 01       	movw	r30, r24
     ab8:	e4 80       	ldd	r14, Z+4	; 0x04
     aba:	f5 80       	ldd	r15, Z+5	; 0x05
     abc:	06 81       	ldd	r16, Z+6	; 0x06
     abe:	17 81       	ldd	r17, Z+7	; 0x07
     ac0:	d1 80       	ldd	r13, Z+1	; 0x01
     ac2:	80 81       	ld	r24, Z
     ac4:	82 30       	cpi	r24, 0x02	; 2
     ac6:	48 f4       	brcc	.+18     	; 0xada <__pack_f+0x2e>
     ac8:	80 e0       	ldi	r24, 0x00	; 0
     aca:	90 e0       	ldi	r25, 0x00	; 0
     acc:	a0 e1       	ldi	r26, 0x10	; 16
     ace:	b0 e0       	ldi	r27, 0x00	; 0
     ad0:	e8 2a       	or	r14, r24
     ad2:	f9 2a       	or	r15, r25
     ad4:	0a 2b       	or	r16, r26
     ad6:	1b 2b       	or	r17, r27
     ad8:	a5 c0       	rjmp	.+330    	; 0xc24 <__pack_f+0x178>
     ada:	84 30       	cpi	r24, 0x04	; 4
     adc:	09 f4       	brne	.+2      	; 0xae0 <__pack_f+0x34>
     ade:	9f c0       	rjmp	.+318    	; 0xc1e <__pack_f+0x172>
     ae0:	82 30       	cpi	r24, 0x02	; 2
     ae2:	21 f4       	brne	.+8      	; 0xaec <__pack_f+0x40>
     ae4:	ee 24       	eor	r14, r14
     ae6:	ff 24       	eor	r15, r15
     ae8:	87 01       	movw	r16, r14
     aea:	05 c0       	rjmp	.+10     	; 0xaf6 <__pack_f+0x4a>
     aec:	e1 14       	cp	r14, r1
     aee:	f1 04       	cpc	r15, r1
     af0:	01 05       	cpc	r16, r1
     af2:	11 05       	cpc	r17, r1
     af4:	19 f4       	brne	.+6      	; 0xafc <__pack_f+0x50>
     af6:	e0 e0       	ldi	r30, 0x00	; 0
     af8:	f0 e0       	ldi	r31, 0x00	; 0
     afa:	96 c0       	rjmp	.+300    	; 0xc28 <__pack_f+0x17c>
     afc:	62 81       	ldd	r22, Z+2	; 0x02
     afe:	73 81       	ldd	r23, Z+3	; 0x03
     b00:	9f ef       	ldi	r25, 0xFF	; 255
     b02:	62 38       	cpi	r22, 0x82	; 130
     b04:	79 07       	cpc	r23, r25
     b06:	0c f0       	brlt	.+2      	; 0xb0a <__pack_f+0x5e>
     b08:	5b c0       	rjmp	.+182    	; 0xbc0 <__pack_f+0x114>
     b0a:	22 e8       	ldi	r18, 0x82	; 130
     b0c:	3f ef       	ldi	r19, 0xFF	; 255
     b0e:	26 1b       	sub	r18, r22
     b10:	37 0b       	sbc	r19, r23
     b12:	2a 31       	cpi	r18, 0x1A	; 26
     b14:	31 05       	cpc	r19, r1
     b16:	2c f0       	brlt	.+10     	; 0xb22 <__pack_f+0x76>
     b18:	20 e0       	ldi	r18, 0x00	; 0
     b1a:	30 e0       	ldi	r19, 0x00	; 0
     b1c:	40 e0       	ldi	r20, 0x00	; 0
     b1e:	50 e0       	ldi	r21, 0x00	; 0
     b20:	2a c0       	rjmp	.+84     	; 0xb76 <__pack_f+0xca>
     b22:	b8 01       	movw	r22, r16
     b24:	a7 01       	movw	r20, r14
     b26:	02 2e       	mov	r0, r18
     b28:	04 c0       	rjmp	.+8      	; 0xb32 <__pack_f+0x86>
     b2a:	76 95       	lsr	r23
     b2c:	67 95       	ror	r22
     b2e:	57 95       	ror	r21
     b30:	47 95       	ror	r20
     b32:	0a 94       	dec	r0
     b34:	d2 f7       	brpl	.-12     	; 0xb2a <__pack_f+0x7e>
     b36:	81 e0       	ldi	r24, 0x01	; 1
     b38:	90 e0       	ldi	r25, 0x00	; 0
     b3a:	a0 e0       	ldi	r26, 0x00	; 0
     b3c:	b0 e0       	ldi	r27, 0x00	; 0
     b3e:	04 c0       	rjmp	.+8      	; 0xb48 <__pack_f+0x9c>
     b40:	88 0f       	add	r24, r24
     b42:	99 1f       	adc	r25, r25
     b44:	aa 1f       	adc	r26, r26
     b46:	bb 1f       	adc	r27, r27
     b48:	2a 95       	dec	r18
     b4a:	d2 f7       	brpl	.-12     	; 0xb40 <__pack_f+0x94>
     b4c:	01 97       	sbiw	r24, 0x01	; 1
     b4e:	a1 09       	sbc	r26, r1
     b50:	b1 09       	sbc	r27, r1
     b52:	8e 21       	and	r24, r14
     b54:	9f 21       	and	r25, r15
     b56:	a0 23       	and	r26, r16
     b58:	b1 23       	and	r27, r17
     b5a:	00 97       	sbiw	r24, 0x00	; 0
     b5c:	a1 05       	cpc	r26, r1
     b5e:	b1 05       	cpc	r27, r1
     b60:	21 f0       	breq	.+8      	; 0xb6a <__pack_f+0xbe>
     b62:	81 e0       	ldi	r24, 0x01	; 1
     b64:	90 e0       	ldi	r25, 0x00	; 0
     b66:	a0 e0       	ldi	r26, 0x00	; 0
     b68:	b0 e0       	ldi	r27, 0x00	; 0
     b6a:	9a 01       	movw	r18, r20
     b6c:	ab 01       	movw	r20, r22
     b6e:	28 2b       	or	r18, r24
     b70:	39 2b       	or	r19, r25
     b72:	4a 2b       	or	r20, r26
     b74:	5b 2b       	or	r21, r27
     b76:	da 01       	movw	r26, r20
     b78:	c9 01       	movw	r24, r18
     b7a:	8f 77       	andi	r24, 0x7F	; 127
     b7c:	90 70       	andi	r25, 0x00	; 0
     b7e:	a0 70       	andi	r26, 0x00	; 0
     b80:	b0 70       	andi	r27, 0x00	; 0
     b82:	80 34       	cpi	r24, 0x40	; 64
     b84:	91 05       	cpc	r25, r1
     b86:	a1 05       	cpc	r26, r1
     b88:	b1 05       	cpc	r27, r1
     b8a:	39 f4       	brne	.+14     	; 0xb9a <__pack_f+0xee>
     b8c:	27 ff       	sbrs	r18, 7
     b8e:	09 c0       	rjmp	.+18     	; 0xba2 <__pack_f+0xf6>
     b90:	20 5c       	subi	r18, 0xC0	; 192
     b92:	3f 4f       	sbci	r19, 0xFF	; 255
     b94:	4f 4f       	sbci	r20, 0xFF	; 255
     b96:	5f 4f       	sbci	r21, 0xFF	; 255
     b98:	04 c0       	rjmp	.+8      	; 0xba2 <__pack_f+0xf6>
     b9a:	21 5c       	subi	r18, 0xC1	; 193
     b9c:	3f 4f       	sbci	r19, 0xFF	; 255
     b9e:	4f 4f       	sbci	r20, 0xFF	; 255
     ba0:	5f 4f       	sbci	r21, 0xFF	; 255
     ba2:	e0 e0       	ldi	r30, 0x00	; 0
     ba4:	f0 e0       	ldi	r31, 0x00	; 0
     ba6:	20 30       	cpi	r18, 0x00	; 0
     ba8:	a0 e0       	ldi	r26, 0x00	; 0
     baa:	3a 07       	cpc	r19, r26
     bac:	a0 e0       	ldi	r26, 0x00	; 0
     bae:	4a 07       	cpc	r20, r26
     bb0:	a0 e4       	ldi	r26, 0x40	; 64
     bb2:	5a 07       	cpc	r21, r26
     bb4:	10 f0       	brcs	.+4      	; 0xbba <__pack_f+0x10e>
     bb6:	e1 e0       	ldi	r30, 0x01	; 1
     bb8:	f0 e0       	ldi	r31, 0x00	; 0
     bba:	79 01       	movw	r14, r18
     bbc:	8a 01       	movw	r16, r20
     bbe:	27 c0       	rjmp	.+78     	; 0xc0e <__pack_f+0x162>
     bc0:	60 38       	cpi	r22, 0x80	; 128
     bc2:	71 05       	cpc	r23, r1
     bc4:	64 f5       	brge	.+88     	; 0xc1e <__pack_f+0x172>
     bc6:	fb 01       	movw	r30, r22
     bc8:	e1 58       	subi	r30, 0x81	; 129
     bca:	ff 4f       	sbci	r31, 0xFF	; 255
     bcc:	d8 01       	movw	r26, r16
     bce:	c7 01       	movw	r24, r14
     bd0:	8f 77       	andi	r24, 0x7F	; 127
     bd2:	90 70       	andi	r25, 0x00	; 0
     bd4:	a0 70       	andi	r26, 0x00	; 0
     bd6:	b0 70       	andi	r27, 0x00	; 0
     bd8:	80 34       	cpi	r24, 0x40	; 64
     bda:	91 05       	cpc	r25, r1
     bdc:	a1 05       	cpc	r26, r1
     bde:	b1 05       	cpc	r27, r1
     be0:	39 f4       	brne	.+14     	; 0xbf0 <__pack_f+0x144>
     be2:	e7 fe       	sbrs	r14, 7
     be4:	0d c0       	rjmp	.+26     	; 0xc00 <__pack_f+0x154>
     be6:	80 e4       	ldi	r24, 0x40	; 64
     be8:	90 e0       	ldi	r25, 0x00	; 0
     bea:	a0 e0       	ldi	r26, 0x00	; 0
     bec:	b0 e0       	ldi	r27, 0x00	; 0
     bee:	04 c0       	rjmp	.+8      	; 0xbf8 <__pack_f+0x14c>
     bf0:	8f e3       	ldi	r24, 0x3F	; 63
     bf2:	90 e0       	ldi	r25, 0x00	; 0
     bf4:	a0 e0       	ldi	r26, 0x00	; 0
     bf6:	b0 e0       	ldi	r27, 0x00	; 0
     bf8:	e8 0e       	add	r14, r24
     bfa:	f9 1e       	adc	r15, r25
     bfc:	0a 1f       	adc	r16, r26
     bfe:	1b 1f       	adc	r17, r27
     c00:	17 ff       	sbrs	r17, 7
     c02:	05 c0       	rjmp	.+10     	; 0xc0e <__pack_f+0x162>
     c04:	16 95       	lsr	r17
     c06:	07 95       	ror	r16
     c08:	f7 94       	ror	r15
     c0a:	e7 94       	ror	r14
     c0c:	31 96       	adiw	r30, 0x01	; 1
     c0e:	87 e0       	ldi	r24, 0x07	; 7
     c10:	16 95       	lsr	r17
     c12:	07 95       	ror	r16
     c14:	f7 94       	ror	r15
     c16:	e7 94       	ror	r14
     c18:	8a 95       	dec	r24
     c1a:	d1 f7       	brne	.-12     	; 0xc10 <__pack_f+0x164>
     c1c:	05 c0       	rjmp	.+10     	; 0xc28 <__pack_f+0x17c>
     c1e:	ee 24       	eor	r14, r14
     c20:	ff 24       	eor	r15, r15
     c22:	87 01       	movw	r16, r14
     c24:	ef ef       	ldi	r30, 0xFF	; 255
     c26:	f0 e0       	ldi	r31, 0x00	; 0
     c28:	6e 2f       	mov	r22, r30
     c2a:	67 95       	ror	r22
     c2c:	66 27       	eor	r22, r22
     c2e:	67 95       	ror	r22
     c30:	90 2f       	mov	r25, r16
     c32:	9f 77       	andi	r25, 0x7F	; 127
     c34:	d7 94       	ror	r13
     c36:	dd 24       	eor	r13, r13
     c38:	d7 94       	ror	r13
     c3a:	8e 2f       	mov	r24, r30
     c3c:	86 95       	lsr	r24
     c3e:	49 2f       	mov	r20, r25
     c40:	46 2b       	or	r20, r22
     c42:	58 2f       	mov	r21, r24
     c44:	5d 29       	or	r21, r13
     c46:	b7 01       	movw	r22, r14
     c48:	ca 01       	movw	r24, r20
     c4a:	1f 91       	pop	r17
     c4c:	0f 91       	pop	r16
     c4e:	ff 90       	pop	r15
     c50:	ef 90       	pop	r14
     c52:	df 90       	pop	r13
     c54:	08 95       	ret

00000c56 <__unpack_f>:
     c56:	fc 01       	movw	r30, r24
     c58:	db 01       	movw	r26, r22
     c5a:	40 81       	ld	r20, Z
     c5c:	51 81       	ldd	r21, Z+1	; 0x01
     c5e:	22 81       	ldd	r18, Z+2	; 0x02
     c60:	62 2f       	mov	r22, r18
     c62:	6f 77       	andi	r22, 0x7F	; 127
     c64:	70 e0       	ldi	r23, 0x00	; 0
     c66:	22 1f       	adc	r18, r18
     c68:	22 27       	eor	r18, r18
     c6a:	22 1f       	adc	r18, r18
     c6c:	93 81       	ldd	r25, Z+3	; 0x03
     c6e:	89 2f       	mov	r24, r25
     c70:	88 0f       	add	r24, r24
     c72:	82 2b       	or	r24, r18
     c74:	28 2f       	mov	r18, r24
     c76:	30 e0       	ldi	r19, 0x00	; 0
     c78:	99 1f       	adc	r25, r25
     c7a:	99 27       	eor	r25, r25
     c7c:	99 1f       	adc	r25, r25
     c7e:	11 96       	adiw	r26, 0x01	; 1
     c80:	9c 93       	st	X, r25
     c82:	11 97       	sbiw	r26, 0x01	; 1
     c84:	21 15       	cp	r18, r1
     c86:	31 05       	cpc	r19, r1
     c88:	a9 f5       	brne	.+106    	; 0xcf4 <__unpack_f+0x9e>
     c8a:	41 15       	cp	r20, r1
     c8c:	51 05       	cpc	r21, r1
     c8e:	61 05       	cpc	r22, r1
     c90:	71 05       	cpc	r23, r1
     c92:	11 f4       	brne	.+4      	; 0xc98 <__unpack_f+0x42>
     c94:	82 e0       	ldi	r24, 0x02	; 2
     c96:	37 c0       	rjmp	.+110    	; 0xd06 <__unpack_f+0xb0>
     c98:	82 e8       	ldi	r24, 0x82	; 130
     c9a:	9f ef       	ldi	r25, 0xFF	; 255
     c9c:	13 96       	adiw	r26, 0x03	; 3
     c9e:	9c 93       	st	X, r25
     ca0:	8e 93       	st	-X, r24
     ca2:	12 97       	sbiw	r26, 0x02	; 2
     ca4:	9a 01       	movw	r18, r20
     ca6:	ab 01       	movw	r20, r22
     ca8:	67 e0       	ldi	r22, 0x07	; 7
     caa:	22 0f       	add	r18, r18
     cac:	33 1f       	adc	r19, r19
     cae:	44 1f       	adc	r20, r20
     cb0:	55 1f       	adc	r21, r21
     cb2:	6a 95       	dec	r22
     cb4:	d1 f7       	brne	.-12     	; 0xcaa <__unpack_f+0x54>
     cb6:	83 e0       	ldi	r24, 0x03	; 3
     cb8:	8c 93       	st	X, r24
     cba:	0d c0       	rjmp	.+26     	; 0xcd6 <__unpack_f+0x80>
     cbc:	22 0f       	add	r18, r18
     cbe:	33 1f       	adc	r19, r19
     cc0:	44 1f       	adc	r20, r20
     cc2:	55 1f       	adc	r21, r21
     cc4:	12 96       	adiw	r26, 0x02	; 2
     cc6:	8d 91       	ld	r24, X+
     cc8:	9c 91       	ld	r25, X
     cca:	13 97       	sbiw	r26, 0x03	; 3
     ccc:	01 97       	sbiw	r24, 0x01	; 1
     cce:	13 96       	adiw	r26, 0x03	; 3
     cd0:	9c 93       	st	X, r25
     cd2:	8e 93       	st	-X, r24
     cd4:	12 97       	sbiw	r26, 0x02	; 2
     cd6:	20 30       	cpi	r18, 0x00	; 0
     cd8:	80 e0       	ldi	r24, 0x00	; 0
     cda:	38 07       	cpc	r19, r24
     cdc:	80 e0       	ldi	r24, 0x00	; 0
     cde:	48 07       	cpc	r20, r24
     ce0:	80 e4       	ldi	r24, 0x40	; 64
     ce2:	58 07       	cpc	r21, r24
     ce4:	58 f3       	brcs	.-42     	; 0xcbc <__unpack_f+0x66>
     ce6:	14 96       	adiw	r26, 0x04	; 4
     ce8:	2d 93       	st	X+, r18
     cea:	3d 93       	st	X+, r19
     cec:	4d 93       	st	X+, r20
     cee:	5c 93       	st	X, r21
     cf0:	17 97       	sbiw	r26, 0x07	; 7
     cf2:	08 95       	ret
     cf4:	2f 3f       	cpi	r18, 0xFF	; 255
     cf6:	31 05       	cpc	r19, r1
     cf8:	79 f4       	brne	.+30     	; 0xd18 <__unpack_f+0xc2>
     cfa:	41 15       	cp	r20, r1
     cfc:	51 05       	cpc	r21, r1
     cfe:	61 05       	cpc	r22, r1
     d00:	71 05       	cpc	r23, r1
     d02:	19 f4       	brne	.+6      	; 0xd0a <__unpack_f+0xb4>
     d04:	84 e0       	ldi	r24, 0x04	; 4
     d06:	8c 93       	st	X, r24
     d08:	08 95       	ret
     d0a:	64 ff       	sbrs	r22, 4
     d0c:	03 c0       	rjmp	.+6      	; 0xd14 <__unpack_f+0xbe>
     d0e:	81 e0       	ldi	r24, 0x01	; 1
     d10:	8c 93       	st	X, r24
     d12:	12 c0       	rjmp	.+36     	; 0xd38 <__unpack_f+0xe2>
     d14:	1c 92       	st	X, r1
     d16:	10 c0       	rjmp	.+32     	; 0xd38 <__unpack_f+0xe2>
     d18:	2f 57       	subi	r18, 0x7F	; 127
     d1a:	30 40       	sbci	r19, 0x00	; 0
     d1c:	13 96       	adiw	r26, 0x03	; 3
     d1e:	3c 93       	st	X, r19
     d20:	2e 93       	st	-X, r18
     d22:	12 97       	sbiw	r26, 0x02	; 2
     d24:	83 e0       	ldi	r24, 0x03	; 3
     d26:	8c 93       	st	X, r24
     d28:	87 e0       	ldi	r24, 0x07	; 7
     d2a:	44 0f       	add	r20, r20
     d2c:	55 1f       	adc	r21, r21
     d2e:	66 1f       	adc	r22, r22
     d30:	77 1f       	adc	r23, r23
     d32:	8a 95       	dec	r24
     d34:	d1 f7       	brne	.-12     	; 0xd2a <__unpack_f+0xd4>
     d36:	70 64       	ori	r23, 0x40	; 64
     d38:	14 96       	adiw	r26, 0x04	; 4
     d3a:	4d 93       	st	X+, r20
     d3c:	5d 93       	st	X+, r21
     d3e:	6d 93       	st	X+, r22
     d40:	7c 93       	st	X, r23
     d42:	17 97       	sbiw	r26, 0x07	; 7
     d44:	08 95       	ret

00000d46 <__fpcmp_parts_f>:
     d46:	1f 93       	push	r17
     d48:	dc 01       	movw	r26, r24
     d4a:	fb 01       	movw	r30, r22
     d4c:	9c 91       	ld	r25, X
     d4e:	92 30       	cpi	r25, 0x02	; 2
     d50:	08 f4       	brcc	.+2      	; 0xd54 <__fpcmp_parts_f+0xe>
     d52:	47 c0       	rjmp	.+142    	; 0xde2 <__fpcmp_parts_f+0x9c>
     d54:	80 81       	ld	r24, Z
     d56:	82 30       	cpi	r24, 0x02	; 2
     d58:	08 f4       	brcc	.+2      	; 0xd5c <__fpcmp_parts_f+0x16>
     d5a:	43 c0       	rjmp	.+134    	; 0xde2 <__fpcmp_parts_f+0x9c>
     d5c:	94 30       	cpi	r25, 0x04	; 4
     d5e:	51 f4       	brne	.+20     	; 0xd74 <__fpcmp_parts_f+0x2e>
     d60:	11 96       	adiw	r26, 0x01	; 1
     d62:	1c 91       	ld	r17, X
     d64:	84 30       	cpi	r24, 0x04	; 4
     d66:	99 f5       	brne	.+102    	; 0xdce <__fpcmp_parts_f+0x88>
     d68:	81 81       	ldd	r24, Z+1	; 0x01
     d6a:	68 2f       	mov	r22, r24
     d6c:	70 e0       	ldi	r23, 0x00	; 0
     d6e:	61 1b       	sub	r22, r17
     d70:	71 09       	sbc	r23, r1
     d72:	3f c0       	rjmp	.+126    	; 0xdf2 <__fpcmp_parts_f+0xac>
     d74:	84 30       	cpi	r24, 0x04	; 4
     d76:	21 f0       	breq	.+8      	; 0xd80 <__fpcmp_parts_f+0x3a>
     d78:	92 30       	cpi	r25, 0x02	; 2
     d7a:	31 f4       	brne	.+12     	; 0xd88 <__fpcmp_parts_f+0x42>
     d7c:	82 30       	cpi	r24, 0x02	; 2
     d7e:	b9 f1       	breq	.+110    	; 0xdee <__fpcmp_parts_f+0xa8>
     d80:	81 81       	ldd	r24, Z+1	; 0x01
     d82:	88 23       	and	r24, r24
     d84:	89 f1       	breq	.+98     	; 0xde8 <__fpcmp_parts_f+0xa2>
     d86:	2d c0       	rjmp	.+90     	; 0xde2 <__fpcmp_parts_f+0x9c>
     d88:	11 96       	adiw	r26, 0x01	; 1
     d8a:	1c 91       	ld	r17, X
     d8c:	11 97       	sbiw	r26, 0x01	; 1
     d8e:	82 30       	cpi	r24, 0x02	; 2
     d90:	f1 f0       	breq	.+60     	; 0xdce <__fpcmp_parts_f+0x88>
     d92:	81 81       	ldd	r24, Z+1	; 0x01
     d94:	18 17       	cp	r17, r24
     d96:	d9 f4       	brne	.+54     	; 0xdce <__fpcmp_parts_f+0x88>
     d98:	12 96       	adiw	r26, 0x02	; 2
     d9a:	2d 91       	ld	r18, X+
     d9c:	3c 91       	ld	r19, X
     d9e:	13 97       	sbiw	r26, 0x03	; 3
     da0:	82 81       	ldd	r24, Z+2	; 0x02
     da2:	93 81       	ldd	r25, Z+3	; 0x03
     da4:	82 17       	cp	r24, r18
     da6:	93 07       	cpc	r25, r19
     da8:	94 f0       	brlt	.+36     	; 0xdce <__fpcmp_parts_f+0x88>
     daa:	28 17       	cp	r18, r24
     dac:	39 07       	cpc	r19, r25
     dae:	bc f0       	brlt	.+46     	; 0xdde <__fpcmp_parts_f+0x98>
     db0:	14 96       	adiw	r26, 0x04	; 4
     db2:	8d 91       	ld	r24, X+
     db4:	9d 91       	ld	r25, X+
     db6:	0d 90       	ld	r0, X+
     db8:	bc 91       	ld	r27, X
     dba:	a0 2d       	mov	r26, r0
     dbc:	24 81       	ldd	r18, Z+4	; 0x04
     dbe:	35 81       	ldd	r19, Z+5	; 0x05
     dc0:	46 81       	ldd	r20, Z+6	; 0x06
     dc2:	57 81       	ldd	r21, Z+7	; 0x07
     dc4:	28 17       	cp	r18, r24
     dc6:	39 07       	cpc	r19, r25
     dc8:	4a 07       	cpc	r20, r26
     dca:	5b 07       	cpc	r21, r27
     dcc:	18 f4       	brcc	.+6      	; 0xdd4 <__fpcmp_parts_f+0x8e>
     dce:	11 23       	and	r17, r17
     dd0:	41 f0       	breq	.+16     	; 0xde2 <__fpcmp_parts_f+0x9c>
     dd2:	0a c0       	rjmp	.+20     	; 0xde8 <__fpcmp_parts_f+0xa2>
     dd4:	82 17       	cp	r24, r18
     dd6:	93 07       	cpc	r25, r19
     dd8:	a4 07       	cpc	r26, r20
     dda:	b5 07       	cpc	r27, r21
     ddc:	40 f4       	brcc	.+16     	; 0xdee <__fpcmp_parts_f+0xa8>
     dde:	11 23       	and	r17, r17
     de0:	19 f0       	breq	.+6      	; 0xde8 <__fpcmp_parts_f+0xa2>
     de2:	61 e0       	ldi	r22, 0x01	; 1
     de4:	70 e0       	ldi	r23, 0x00	; 0
     de6:	05 c0       	rjmp	.+10     	; 0xdf2 <__fpcmp_parts_f+0xac>
     de8:	6f ef       	ldi	r22, 0xFF	; 255
     dea:	7f ef       	ldi	r23, 0xFF	; 255
     dec:	02 c0       	rjmp	.+4      	; 0xdf2 <__fpcmp_parts_f+0xac>
     dee:	60 e0       	ldi	r22, 0x00	; 0
     df0:	70 e0       	ldi	r23, 0x00	; 0
     df2:	cb 01       	movw	r24, r22
     df4:	1f 91       	pop	r17
     df6:	08 95       	ret

00000df8 <DIO_void_set_port_dir>:


/* implementing the driver functions  */
/* set Portx Direction Function       */

void DIO_void_set_port_dir(u8 copy_u8_portID, u8 port_copy_dir){
     df8:	df 93       	push	r29
     dfa:	cf 93       	push	r28
     dfc:	00 d0       	rcall	.+0      	; 0xdfe <DIO_void_set_port_dir+0x6>
     dfe:	cd b7       	in	r28, 0x3d	; 61
     e00:	de b7       	in	r29, 0x3e	; 62
     e02:	89 83       	std	Y+1, r24	; 0x01
     e04:	6a 83       	std	Y+2, r22	; 0x02
	 *  Also general rule INPUT --> 0 // OUTPUT --> 1
	 *
	 *
	 */

	*(DIO_DDRx[copy_u8_portID]) = port_copy_dir;
     e06:	89 81       	ldd	r24, Y+1	; 0x01
     e08:	88 2f       	mov	r24, r24
     e0a:	90 e0       	ldi	r25, 0x00	; 0
     e0c:	88 0f       	add	r24, r24
     e0e:	99 1f       	adc	r25, r25
     e10:	fc 01       	movw	r30, r24
     e12:	e0 58       	subi	r30, 0x80	; 128
     e14:	fe 4f       	sbci	r31, 0xFE	; 254
     e16:	01 90       	ld	r0, Z+
     e18:	f0 81       	ld	r31, Z
     e1a:	e0 2d       	mov	r30, r0
     e1c:	8a 81       	ldd	r24, Y+2	; 0x02
     e1e:	80 83       	st	Z, r24

}
     e20:	0f 90       	pop	r0
     e22:	0f 90       	pop	r0
     e24:	cf 91       	pop	r28
     e26:	df 91       	pop	r29
     e28:	08 95       	ret

00000e2a <DIO_void_set_pin_dir>:

void DIO_void_set_pin_dir(u8 copy_u8_portID, u8 copy_u8_pinID, u8 pin_copy_dir){
     e2a:	df 93       	push	r29
     e2c:	cf 93       	push	r28
     e2e:	00 d0       	rcall	.+0      	; 0xe30 <DIO_void_set_pin_dir+0x6>
     e30:	0f 92       	push	r0
     e32:	cd b7       	in	r28, 0x3d	; 61
     e34:	de b7       	in	r29, 0x3e	; 62
     e36:	89 83       	std	Y+1, r24	; 0x01
     e38:	6a 83       	std	Y+2, r22	; 0x02
     e3a:	4b 83       	std	Y+3, r20	; 0x03
	 *  pin_copy_dir using the predefined macro INPUT //OUTPUT
	 *
	 *
	 */

	assign_Bit(*(DIO_DDRx[copy_u8_portID]),copy_u8_pinID,pin_copy_dir);
     e3c:	8b 81       	ldd	r24, Y+3	; 0x03
     e3e:	81 30       	cpi	r24, 0x01	; 1
     e40:	29 f5       	brne	.+74     	; 0xe8c <DIO_void_set_pin_dir+0x62>
     e42:	89 81       	ldd	r24, Y+1	; 0x01
     e44:	88 2f       	mov	r24, r24
     e46:	90 e0       	ldi	r25, 0x00	; 0
     e48:	88 0f       	add	r24, r24
     e4a:	99 1f       	adc	r25, r25
     e4c:	fc 01       	movw	r30, r24
     e4e:	e0 58       	subi	r30, 0x80	; 128
     e50:	fe 4f       	sbci	r31, 0xFE	; 254
     e52:	a0 81       	ld	r26, Z
     e54:	b1 81       	ldd	r27, Z+1	; 0x01
     e56:	89 81       	ldd	r24, Y+1	; 0x01
     e58:	88 2f       	mov	r24, r24
     e5a:	90 e0       	ldi	r25, 0x00	; 0
     e5c:	88 0f       	add	r24, r24
     e5e:	99 1f       	adc	r25, r25
     e60:	fc 01       	movw	r30, r24
     e62:	e0 58       	subi	r30, 0x80	; 128
     e64:	fe 4f       	sbci	r31, 0xFE	; 254
     e66:	01 90       	ld	r0, Z+
     e68:	f0 81       	ld	r31, Z
     e6a:	e0 2d       	mov	r30, r0
     e6c:	80 81       	ld	r24, Z
     e6e:	48 2f       	mov	r20, r24
     e70:	8a 81       	ldd	r24, Y+2	; 0x02
     e72:	28 2f       	mov	r18, r24
     e74:	30 e0       	ldi	r19, 0x00	; 0
     e76:	81 e0       	ldi	r24, 0x01	; 1
     e78:	90 e0       	ldi	r25, 0x00	; 0
     e7a:	02 2e       	mov	r0, r18
     e7c:	02 c0       	rjmp	.+4      	; 0xe82 <DIO_void_set_pin_dir+0x58>
     e7e:	88 0f       	add	r24, r24
     e80:	99 1f       	adc	r25, r25
     e82:	0a 94       	dec	r0
     e84:	e2 f7       	brpl	.-8      	; 0xe7e <DIO_void_set_pin_dir+0x54>
     e86:	84 2b       	or	r24, r20
     e88:	8c 93       	st	X, r24
     e8a:	25 c0       	rjmp	.+74     	; 0xed6 <DIO_void_set_pin_dir+0xac>
     e8c:	89 81       	ldd	r24, Y+1	; 0x01
     e8e:	88 2f       	mov	r24, r24
     e90:	90 e0       	ldi	r25, 0x00	; 0
     e92:	88 0f       	add	r24, r24
     e94:	99 1f       	adc	r25, r25
     e96:	fc 01       	movw	r30, r24
     e98:	e0 58       	subi	r30, 0x80	; 128
     e9a:	fe 4f       	sbci	r31, 0xFE	; 254
     e9c:	a0 81       	ld	r26, Z
     e9e:	b1 81       	ldd	r27, Z+1	; 0x01
     ea0:	89 81       	ldd	r24, Y+1	; 0x01
     ea2:	88 2f       	mov	r24, r24
     ea4:	90 e0       	ldi	r25, 0x00	; 0
     ea6:	88 0f       	add	r24, r24
     ea8:	99 1f       	adc	r25, r25
     eaa:	fc 01       	movw	r30, r24
     eac:	e0 58       	subi	r30, 0x80	; 128
     eae:	fe 4f       	sbci	r31, 0xFE	; 254
     eb0:	01 90       	ld	r0, Z+
     eb2:	f0 81       	ld	r31, Z
     eb4:	e0 2d       	mov	r30, r0
     eb6:	80 81       	ld	r24, Z
     eb8:	48 2f       	mov	r20, r24
     eba:	8a 81       	ldd	r24, Y+2	; 0x02
     ebc:	28 2f       	mov	r18, r24
     ebe:	30 e0       	ldi	r19, 0x00	; 0
     ec0:	81 e0       	ldi	r24, 0x01	; 1
     ec2:	90 e0       	ldi	r25, 0x00	; 0
     ec4:	02 2e       	mov	r0, r18
     ec6:	02 c0       	rjmp	.+4      	; 0xecc <DIO_void_set_pin_dir+0xa2>
     ec8:	88 0f       	add	r24, r24
     eca:	99 1f       	adc	r25, r25
     ecc:	0a 94       	dec	r0
     ece:	e2 f7       	brpl	.-8      	; 0xec8 <DIO_void_set_pin_dir+0x9e>
     ed0:	80 95       	com	r24
     ed2:	84 23       	and	r24, r20
     ed4:	8c 93       	st	X, r24

}
     ed6:	0f 90       	pop	r0
     ed8:	0f 90       	pop	r0
     eda:	0f 90       	pop	r0
     edc:	cf 91       	pop	r28
     ede:	df 91       	pop	r29
     ee0:	08 95       	ret

00000ee2 <DIO_void_port_pullup>:

void DIO_void_port_pullup(u8 copy_u8_portID){
     ee2:	df 93       	push	r29
     ee4:	cf 93       	push	r28
     ee6:	0f 92       	push	r0
     ee8:	cd b7       	in	r28, 0x3d	; 61
     eea:	de b7       	in	r29, 0x3e	; 62
     eec:	89 83       	std	Y+1, r24	; 0x01
	 *  so that is what the function does
	 *  using the pullup for any button prevents the floating effect
	 *
	 *
	 */
	*(DIO_DDRx[copy_u8_portID]) = INPUT;
     eee:	89 81       	ldd	r24, Y+1	; 0x01
     ef0:	88 2f       	mov	r24, r24
     ef2:	90 e0       	ldi	r25, 0x00	; 0
     ef4:	88 0f       	add	r24, r24
     ef6:	99 1f       	adc	r25, r25
     ef8:	fc 01       	movw	r30, r24
     efa:	e0 58       	subi	r30, 0x80	; 128
     efc:	fe 4f       	sbci	r31, 0xFE	; 254
     efe:	01 90       	ld	r0, Z+
     f00:	f0 81       	ld	r31, Z
     f02:	e0 2d       	mov	r30, r0
     f04:	10 82       	st	Z, r1
	*(DIO_PORTx[copy_u8_portID]) = PORT_MAX;
     f06:	89 81       	ldd	r24, Y+1	; 0x01
     f08:	88 2f       	mov	r24, r24
     f0a:	90 e0       	ldi	r25, 0x00	; 0
     f0c:	88 0f       	add	r24, r24
     f0e:	99 1f       	adc	r25, r25
     f10:	fc 01       	movw	r30, r24
     f12:	e8 57       	subi	r30, 0x78	; 120
     f14:	fe 4f       	sbci	r31, 0xFE	; 254
     f16:	01 90       	ld	r0, Z+
     f18:	f0 81       	ld	r31, Z
     f1a:	e0 2d       	mov	r30, r0
     f1c:	8f ef       	ldi	r24, 0xFF	; 255
     f1e:	80 83       	st	Z, r24
}
     f20:	0f 90       	pop	r0
     f22:	cf 91       	pop	r28
     f24:	df 91       	pop	r29
     f26:	08 95       	ret

00000f28 <DIO_void_pin_pullup>:

void DIO_void_pin_pullup(u8 copy_u8_portID, u8 copy_u8_pinID){
     f28:	df 93       	push	r29
     f2a:	cf 93       	push	r28
     f2c:	00 d0       	rcall	.+0      	; 0xf2e <DIO_void_pin_pullup+0x6>
     f2e:	cd b7       	in	r28, 0x3d	; 61
     f30:	de b7       	in	r29, 0x3e	; 62
     f32:	89 83       	std	Y+1, r24	; 0x01
     f34:	6a 83       	std	Y+2, r22	; 0x02
	/*  the function works as the one that set pullup for the whole port
	 *
	 *
	 */

	clear_Bit(*(DIO_DDRx[copy_u8_portID]),copy_u8_pinID);
     f36:	89 81       	ldd	r24, Y+1	; 0x01
     f38:	88 2f       	mov	r24, r24
     f3a:	90 e0       	ldi	r25, 0x00	; 0
     f3c:	88 0f       	add	r24, r24
     f3e:	99 1f       	adc	r25, r25
     f40:	fc 01       	movw	r30, r24
     f42:	e0 58       	subi	r30, 0x80	; 128
     f44:	fe 4f       	sbci	r31, 0xFE	; 254
     f46:	a0 81       	ld	r26, Z
     f48:	b1 81       	ldd	r27, Z+1	; 0x01
     f4a:	89 81       	ldd	r24, Y+1	; 0x01
     f4c:	88 2f       	mov	r24, r24
     f4e:	90 e0       	ldi	r25, 0x00	; 0
     f50:	88 0f       	add	r24, r24
     f52:	99 1f       	adc	r25, r25
     f54:	fc 01       	movw	r30, r24
     f56:	e0 58       	subi	r30, 0x80	; 128
     f58:	fe 4f       	sbci	r31, 0xFE	; 254
     f5a:	01 90       	ld	r0, Z+
     f5c:	f0 81       	ld	r31, Z
     f5e:	e0 2d       	mov	r30, r0
     f60:	80 81       	ld	r24, Z
     f62:	48 2f       	mov	r20, r24
     f64:	8a 81       	ldd	r24, Y+2	; 0x02
     f66:	28 2f       	mov	r18, r24
     f68:	30 e0       	ldi	r19, 0x00	; 0
     f6a:	81 e0       	ldi	r24, 0x01	; 1
     f6c:	90 e0       	ldi	r25, 0x00	; 0
     f6e:	02 c0       	rjmp	.+4      	; 0xf74 <DIO_void_pin_pullup+0x4c>
     f70:	88 0f       	add	r24, r24
     f72:	99 1f       	adc	r25, r25
     f74:	2a 95       	dec	r18
     f76:	e2 f7       	brpl	.-8      	; 0xf70 <DIO_void_pin_pullup+0x48>
     f78:	80 95       	com	r24
     f7a:	84 23       	and	r24, r20
     f7c:	8c 93       	st	X, r24
	set_Bit(*(DIO_PORTx[copy_u8_portID]),copy_u8_pinID);
     f7e:	89 81       	ldd	r24, Y+1	; 0x01
     f80:	88 2f       	mov	r24, r24
     f82:	90 e0       	ldi	r25, 0x00	; 0
     f84:	88 0f       	add	r24, r24
     f86:	99 1f       	adc	r25, r25
     f88:	fc 01       	movw	r30, r24
     f8a:	e8 57       	subi	r30, 0x78	; 120
     f8c:	fe 4f       	sbci	r31, 0xFE	; 254
     f8e:	a0 81       	ld	r26, Z
     f90:	b1 81       	ldd	r27, Z+1	; 0x01
     f92:	89 81       	ldd	r24, Y+1	; 0x01
     f94:	88 2f       	mov	r24, r24
     f96:	90 e0       	ldi	r25, 0x00	; 0
     f98:	88 0f       	add	r24, r24
     f9a:	99 1f       	adc	r25, r25
     f9c:	fc 01       	movw	r30, r24
     f9e:	e8 57       	subi	r30, 0x78	; 120
     fa0:	fe 4f       	sbci	r31, 0xFE	; 254
     fa2:	01 90       	ld	r0, Z+
     fa4:	f0 81       	ld	r31, Z
     fa6:	e0 2d       	mov	r30, r0
     fa8:	80 81       	ld	r24, Z
     faa:	48 2f       	mov	r20, r24
     fac:	8a 81       	ldd	r24, Y+2	; 0x02
     fae:	28 2f       	mov	r18, r24
     fb0:	30 e0       	ldi	r19, 0x00	; 0
     fb2:	81 e0       	ldi	r24, 0x01	; 1
     fb4:	90 e0       	ldi	r25, 0x00	; 0
     fb6:	02 2e       	mov	r0, r18
     fb8:	02 c0       	rjmp	.+4      	; 0xfbe <DIO_void_pin_pullup+0x96>
     fba:	88 0f       	add	r24, r24
     fbc:	99 1f       	adc	r25, r25
     fbe:	0a 94       	dec	r0
     fc0:	e2 f7       	brpl	.-8      	; 0xfba <DIO_void_pin_pullup+0x92>
     fc2:	84 2b       	or	r24, r20
     fc4:	8c 93       	st	X, r24

}
     fc6:	0f 90       	pop	r0
     fc8:	0f 90       	pop	r0
     fca:	cf 91       	pop	r28
     fcc:	df 91       	pop	r29
     fce:	08 95       	ret

00000fd0 <DIO_void_set_port>:

void DIO_void_set_port(u8 copy_u8_portID){
     fd0:	df 93       	push	r29
     fd2:	cf 93       	push	r28
     fd4:	0f 92       	push	r0
     fd6:	cd b7       	in	r28, 0x3d	; 61
     fd8:	de b7       	in	r29, 0x3e	; 62
     fda:	89 83       	std	Y+1, r24	; 0x01
	 *
	 */



	*(DIO_PORTx[copy_u8_portID]) = PORT_MAX;
     fdc:	89 81       	ldd	r24, Y+1	; 0x01
     fde:	88 2f       	mov	r24, r24
     fe0:	90 e0       	ldi	r25, 0x00	; 0
     fe2:	88 0f       	add	r24, r24
     fe4:	99 1f       	adc	r25, r25
     fe6:	fc 01       	movw	r30, r24
     fe8:	e8 57       	subi	r30, 0x78	; 120
     fea:	fe 4f       	sbci	r31, 0xFE	; 254
     fec:	01 90       	ld	r0, Z+
     fee:	f0 81       	ld	r31, Z
     ff0:	e0 2d       	mov	r30, r0
     ff2:	8f ef       	ldi	r24, 0xFF	; 255
     ff4:	80 83       	st	Z, r24

}
     ff6:	0f 90       	pop	r0
     ff8:	cf 91       	pop	r28
     ffa:	df 91       	pop	r29
     ffc:	08 95       	ret

00000ffe <DIO_void_clear_port>:

void DIO_void_clear_port(u8 copy_u8_portID){
     ffe:	df 93       	push	r29
    1000:	cf 93       	push	r28
    1002:	0f 92       	push	r0
    1004:	cd b7       	in	r28, 0x3d	; 61
    1006:	de b7       	in	r29, 0x3e	; 62
    1008:	89 83       	std	Y+1, r24	; 0x01
	 *
	 *
	 */


	*(DIO_PORTx[copy_u8_portID]) = LOW;
    100a:	89 81       	ldd	r24, Y+1	; 0x01
    100c:	88 2f       	mov	r24, r24
    100e:	90 e0       	ldi	r25, 0x00	; 0
    1010:	88 0f       	add	r24, r24
    1012:	99 1f       	adc	r25, r25
    1014:	fc 01       	movw	r30, r24
    1016:	e8 57       	subi	r30, 0x78	; 120
    1018:	fe 4f       	sbci	r31, 0xFE	; 254
    101a:	01 90       	ld	r0, Z+
    101c:	f0 81       	ld	r31, Z
    101e:	e0 2d       	mov	r30, r0
    1020:	10 82       	st	Z, r1

}
    1022:	0f 90       	pop	r0
    1024:	cf 91       	pop	r28
    1026:	df 91       	pop	r29
    1028:	08 95       	ret

0000102a <DIO_void_assign_port>:

void DIO_void_assign_port(u8 copy_u8_portID, u8 copy_value){
    102a:	df 93       	push	r29
    102c:	cf 93       	push	r28
    102e:	00 d0       	rcall	.+0      	; 0x1030 <DIO_void_assign_port+0x6>
    1030:	cd b7       	in	r28, 0x3d	; 61
    1032:	de b7       	in	r29, 0x3e	; 62
    1034:	89 83       	std	Y+1, r24	; 0x01
    1036:	6a 83       	std	Y+2, r22	; 0x02
	 *
	 */



	*(DIO_PORTx[copy_u8_portID]) = copy_value;
    1038:	89 81       	ldd	r24, Y+1	; 0x01
    103a:	88 2f       	mov	r24, r24
    103c:	90 e0       	ldi	r25, 0x00	; 0
    103e:	88 0f       	add	r24, r24
    1040:	99 1f       	adc	r25, r25
    1042:	fc 01       	movw	r30, r24
    1044:	e8 57       	subi	r30, 0x78	; 120
    1046:	fe 4f       	sbci	r31, 0xFE	; 254
    1048:	01 90       	ld	r0, Z+
    104a:	f0 81       	ld	r31, Z
    104c:	e0 2d       	mov	r30, r0
    104e:	8a 81       	ldd	r24, Y+2	; 0x02
    1050:	80 83       	st	Z, r24

}
    1052:	0f 90       	pop	r0
    1054:	0f 90       	pop	r0
    1056:	cf 91       	pop	r28
    1058:	df 91       	pop	r29
    105a:	08 95       	ret

0000105c <DIO_void_toggle_port>:

void DIO_void_toggle_port(u8 copy_u8_portID){
    105c:	df 93       	push	r29
    105e:	cf 93       	push	r28
    1060:	0f 92       	push	r0
    1062:	cd b7       	in	r28, 0x3d	; 61
    1064:	de b7       	in	r29, 0x3e	; 62
    1066:	89 83       	std	Y+1, r24	; 0x01
	 *
	 *
	 */


	*(DIO_PORTx[copy_u8_portID]) ^= PORT_MAX;
    1068:	89 81       	ldd	r24, Y+1	; 0x01
    106a:	88 2f       	mov	r24, r24
    106c:	90 e0       	ldi	r25, 0x00	; 0
    106e:	88 0f       	add	r24, r24
    1070:	99 1f       	adc	r25, r25
    1072:	fc 01       	movw	r30, r24
    1074:	e8 57       	subi	r30, 0x78	; 120
    1076:	fe 4f       	sbci	r31, 0xFE	; 254
    1078:	a0 81       	ld	r26, Z
    107a:	b1 81       	ldd	r27, Z+1	; 0x01
    107c:	89 81       	ldd	r24, Y+1	; 0x01
    107e:	88 2f       	mov	r24, r24
    1080:	90 e0       	ldi	r25, 0x00	; 0
    1082:	88 0f       	add	r24, r24
    1084:	99 1f       	adc	r25, r25
    1086:	fc 01       	movw	r30, r24
    1088:	e8 57       	subi	r30, 0x78	; 120
    108a:	fe 4f       	sbci	r31, 0xFE	; 254
    108c:	01 90       	ld	r0, Z+
    108e:	f0 81       	ld	r31, Z
    1090:	e0 2d       	mov	r30, r0
    1092:	80 81       	ld	r24, Z
    1094:	80 95       	com	r24
    1096:	8c 93       	st	X, r24
}
    1098:	0f 90       	pop	r0
    109a:	cf 91       	pop	r28
    109c:	df 91       	pop	r29
    109e:	08 95       	ret

000010a0 <DIO_void_set_pin>:

void DIO_void_set_pin(u8 copy_u8_portID , u8 copy_u8_pinID){
    10a0:	df 93       	push	r29
    10a2:	cf 93       	push	r28
    10a4:	00 d0       	rcall	.+0      	; 0x10a6 <DIO_void_set_pin+0x6>
    10a6:	cd b7       	in	r28, 0x3d	; 61
    10a8:	de b7       	in	r29, 0x3e	; 62
    10aa:	89 83       	std	Y+1, r24	; 0x01
    10ac:	6a 83       	std	Y+2, r22	; 0x02
	 *
	 *
	 */


	set_Bit(*(DIO_PORTx[copy_u8_portID]),copy_u8_pinID);
    10ae:	89 81       	ldd	r24, Y+1	; 0x01
    10b0:	88 2f       	mov	r24, r24
    10b2:	90 e0       	ldi	r25, 0x00	; 0
    10b4:	88 0f       	add	r24, r24
    10b6:	99 1f       	adc	r25, r25
    10b8:	fc 01       	movw	r30, r24
    10ba:	e8 57       	subi	r30, 0x78	; 120
    10bc:	fe 4f       	sbci	r31, 0xFE	; 254
    10be:	a0 81       	ld	r26, Z
    10c0:	b1 81       	ldd	r27, Z+1	; 0x01
    10c2:	89 81       	ldd	r24, Y+1	; 0x01
    10c4:	88 2f       	mov	r24, r24
    10c6:	90 e0       	ldi	r25, 0x00	; 0
    10c8:	88 0f       	add	r24, r24
    10ca:	99 1f       	adc	r25, r25
    10cc:	fc 01       	movw	r30, r24
    10ce:	e8 57       	subi	r30, 0x78	; 120
    10d0:	fe 4f       	sbci	r31, 0xFE	; 254
    10d2:	01 90       	ld	r0, Z+
    10d4:	f0 81       	ld	r31, Z
    10d6:	e0 2d       	mov	r30, r0
    10d8:	80 81       	ld	r24, Z
    10da:	48 2f       	mov	r20, r24
    10dc:	8a 81       	ldd	r24, Y+2	; 0x02
    10de:	28 2f       	mov	r18, r24
    10e0:	30 e0       	ldi	r19, 0x00	; 0
    10e2:	81 e0       	ldi	r24, 0x01	; 1
    10e4:	90 e0       	ldi	r25, 0x00	; 0
    10e6:	02 2e       	mov	r0, r18
    10e8:	02 c0       	rjmp	.+4      	; 0x10ee <DIO_void_set_pin+0x4e>
    10ea:	88 0f       	add	r24, r24
    10ec:	99 1f       	adc	r25, r25
    10ee:	0a 94       	dec	r0
    10f0:	e2 f7       	brpl	.-8      	; 0x10ea <DIO_void_set_pin+0x4a>
    10f2:	84 2b       	or	r24, r20
    10f4:	8c 93       	st	X, r24
}
    10f6:	0f 90       	pop	r0
    10f8:	0f 90       	pop	r0
    10fa:	cf 91       	pop	r28
    10fc:	df 91       	pop	r29
    10fe:	08 95       	ret

00001100 <DIO_void_clear_pin>:

void DIO_void_clear_pin(u8 copy_u8_portID , u8 copy_u8_pinID){
    1100:	df 93       	push	r29
    1102:	cf 93       	push	r28
    1104:	00 d0       	rcall	.+0      	; 0x1106 <DIO_void_clear_pin+0x6>
    1106:	cd b7       	in	r28, 0x3d	; 61
    1108:	de b7       	in	r29, 0x3e	; 62
    110a:	89 83       	std	Y+1, r24	; 0x01
    110c:	6a 83       	std	Y+2, r22	; 0x02
	 *
	 *
	 */


	clear_Bit(*(DIO_PORTx[copy_u8_portID]),copy_u8_pinID);
    110e:	89 81       	ldd	r24, Y+1	; 0x01
    1110:	88 2f       	mov	r24, r24
    1112:	90 e0       	ldi	r25, 0x00	; 0
    1114:	88 0f       	add	r24, r24
    1116:	99 1f       	adc	r25, r25
    1118:	fc 01       	movw	r30, r24
    111a:	e8 57       	subi	r30, 0x78	; 120
    111c:	fe 4f       	sbci	r31, 0xFE	; 254
    111e:	a0 81       	ld	r26, Z
    1120:	b1 81       	ldd	r27, Z+1	; 0x01
    1122:	89 81       	ldd	r24, Y+1	; 0x01
    1124:	88 2f       	mov	r24, r24
    1126:	90 e0       	ldi	r25, 0x00	; 0
    1128:	88 0f       	add	r24, r24
    112a:	99 1f       	adc	r25, r25
    112c:	fc 01       	movw	r30, r24
    112e:	e8 57       	subi	r30, 0x78	; 120
    1130:	fe 4f       	sbci	r31, 0xFE	; 254
    1132:	01 90       	ld	r0, Z+
    1134:	f0 81       	ld	r31, Z
    1136:	e0 2d       	mov	r30, r0
    1138:	80 81       	ld	r24, Z
    113a:	48 2f       	mov	r20, r24
    113c:	8a 81       	ldd	r24, Y+2	; 0x02
    113e:	28 2f       	mov	r18, r24
    1140:	30 e0       	ldi	r19, 0x00	; 0
    1142:	81 e0       	ldi	r24, 0x01	; 1
    1144:	90 e0       	ldi	r25, 0x00	; 0
    1146:	02 2e       	mov	r0, r18
    1148:	02 c0       	rjmp	.+4      	; 0x114e <DIO_void_clear_pin+0x4e>
    114a:	88 0f       	add	r24, r24
    114c:	99 1f       	adc	r25, r25
    114e:	0a 94       	dec	r0
    1150:	e2 f7       	brpl	.-8      	; 0x114a <DIO_void_clear_pin+0x4a>
    1152:	80 95       	com	r24
    1154:	84 23       	and	r24, r20
    1156:	8c 93       	st	X, r24
}
    1158:	0f 90       	pop	r0
    115a:	0f 90       	pop	r0
    115c:	cf 91       	pop	r28
    115e:	df 91       	pop	r29
    1160:	08 95       	ret

00001162 <DIO_void_assign_pin>:

void DIO_void_assign_pin(u8 copy_u8_portID,u8 copy_u8_pinID ,u8 copy_value){
    1162:	df 93       	push	r29
    1164:	cf 93       	push	r28
    1166:	00 d0       	rcall	.+0      	; 0x1168 <DIO_void_assign_pin+0x6>
    1168:	0f 92       	push	r0
    116a:	cd b7       	in	r28, 0x3d	; 61
    116c:	de b7       	in	r29, 0x3e	; 62
    116e:	89 83       	std	Y+1, r24	; 0x01
    1170:	6a 83       	std	Y+2, r22	; 0x02
    1172:	4b 83       	std	Y+3, r20	; 0x03
	 *
	 */



	assign_Bit(*(DIO_PORTx[copy_u8_portID]),copy_u8_pinID,copy_value);
    1174:	8b 81       	ldd	r24, Y+3	; 0x03
    1176:	81 30       	cpi	r24, 0x01	; 1
    1178:	29 f5       	brne	.+74     	; 0x11c4 <DIO_void_assign_pin+0x62>
    117a:	89 81       	ldd	r24, Y+1	; 0x01
    117c:	88 2f       	mov	r24, r24
    117e:	90 e0       	ldi	r25, 0x00	; 0
    1180:	88 0f       	add	r24, r24
    1182:	99 1f       	adc	r25, r25
    1184:	fc 01       	movw	r30, r24
    1186:	e8 57       	subi	r30, 0x78	; 120
    1188:	fe 4f       	sbci	r31, 0xFE	; 254
    118a:	a0 81       	ld	r26, Z
    118c:	b1 81       	ldd	r27, Z+1	; 0x01
    118e:	89 81       	ldd	r24, Y+1	; 0x01
    1190:	88 2f       	mov	r24, r24
    1192:	90 e0       	ldi	r25, 0x00	; 0
    1194:	88 0f       	add	r24, r24
    1196:	99 1f       	adc	r25, r25
    1198:	fc 01       	movw	r30, r24
    119a:	e8 57       	subi	r30, 0x78	; 120
    119c:	fe 4f       	sbci	r31, 0xFE	; 254
    119e:	01 90       	ld	r0, Z+
    11a0:	f0 81       	ld	r31, Z
    11a2:	e0 2d       	mov	r30, r0
    11a4:	80 81       	ld	r24, Z
    11a6:	48 2f       	mov	r20, r24
    11a8:	8a 81       	ldd	r24, Y+2	; 0x02
    11aa:	28 2f       	mov	r18, r24
    11ac:	30 e0       	ldi	r19, 0x00	; 0
    11ae:	81 e0       	ldi	r24, 0x01	; 1
    11b0:	90 e0       	ldi	r25, 0x00	; 0
    11b2:	02 2e       	mov	r0, r18
    11b4:	02 c0       	rjmp	.+4      	; 0x11ba <DIO_void_assign_pin+0x58>
    11b6:	88 0f       	add	r24, r24
    11b8:	99 1f       	adc	r25, r25
    11ba:	0a 94       	dec	r0
    11bc:	e2 f7       	brpl	.-8      	; 0x11b6 <DIO_void_assign_pin+0x54>
    11be:	84 2b       	or	r24, r20
    11c0:	8c 93       	st	X, r24
    11c2:	25 c0       	rjmp	.+74     	; 0x120e <DIO_void_assign_pin+0xac>
    11c4:	89 81       	ldd	r24, Y+1	; 0x01
    11c6:	88 2f       	mov	r24, r24
    11c8:	90 e0       	ldi	r25, 0x00	; 0
    11ca:	88 0f       	add	r24, r24
    11cc:	99 1f       	adc	r25, r25
    11ce:	fc 01       	movw	r30, r24
    11d0:	e8 57       	subi	r30, 0x78	; 120
    11d2:	fe 4f       	sbci	r31, 0xFE	; 254
    11d4:	a0 81       	ld	r26, Z
    11d6:	b1 81       	ldd	r27, Z+1	; 0x01
    11d8:	89 81       	ldd	r24, Y+1	; 0x01
    11da:	88 2f       	mov	r24, r24
    11dc:	90 e0       	ldi	r25, 0x00	; 0
    11de:	88 0f       	add	r24, r24
    11e0:	99 1f       	adc	r25, r25
    11e2:	fc 01       	movw	r30, r24
    11e4:	e8 57       	subi	r30, 0x78	; 120
    11e6:	fe 4f       	sbci	r31, 0xFE	; 254
    11e8:	01 90       	ld	r0, Z+
    11ea:	f0 81       	ld	r31, Z
    11ec:	e0 2d       	mov	r30, r0
    11ee:	80 81       	ld	r24, Z
    11f0:	48 2f       	mov	r20, r24
    11f2:	8a 81       	ldd	r24, Y+2	; 0x02
    11f4:	28 2f       	mov	r18, r24
    11f6:	30 e0       	ldi	r19, 0x00	; 0
    11f8:	81 e0       	ldi	r24, 0x01	; 1
    11fa:	90 e0       	ldi	r25, 0x00	; 0
    11fc:	02 2e       	mov	r0, r18
    11fe:	02 c0       	rjmp	.+4      	; 0x1204 <DIO_void_assign_pin+0xa2>
    1200:	88 0f       	add	r24, r24
    1202:	99 1f       	adc	r25, r25
    1204:	0a 94       	dec	r0
    1206:	e2 f7       	brpl	.-8      	; 0x1200 <DIO_void_assign_pin+0x9e>
    1208:	80 95       	com	r24
    120a:	84 23       	and	r24, r20
    120c:	8c 93       	st	X, r24
}
    120e:	0f 90       	pop	r0
    1210:	0f 90       	pop	r0
    1212:	0f 90       	pop	r0
    1214:	cf 91       	pop	r28
    1216:	df 91       	pop	r29
    1218:	08 95       	ret

0000121a <DIO_void_toggle_pin>:

void DIO_void_toggle_pin(u8 copy_u8_portID , u8 copy_u8_pinID){
    121a:	df 93       	push	r29
    121c:	cf 93       	push	r28
    121e:	00 d0       	rcall	.+0      	; 0x1220 <DIO_void_toggle_pin+0x6>
    1220:	cd b7       	in	r28, 0x3d	; 61
    1222:	de b7       	in	r29, 0x3e	; 62
    1224:	89 83       	std	Y+1, r24	; 0x01
    1226:	6a 83       	std	Y+2, r22	; 0x02
	 *
	 *
	 */


	toggle_Bit(*(DIO_PORTx[copy_u8_portID]),copy_u8_pinID);
    1228:	89 81       	ldd	r24, Y+1	; 0x01
    122a:	88 2f       	mov	r24, r24
    122c:	90 e0       	ldi	r25, 0x00	; 0
    122e:	88 0f       	add	r24, r24
    1230:	99 1f       	adc	r25, r25
    1232:	fc 01       	movw	r30, r24
    1234:	e8 57       	subi	r30, 0x78	; 120
    1236:	fe 4f       	sbci	r31, 0xFE	; 254
    1238:	a0 81       	ld	r26, Z
    123a:	b1 81       	ldd	r27, Z+1	; 0x01
    123c:	89 81       	ldd	r24, Y+1	; 0x01
    123e:	88 2f       	mov	r24, r24
    1240:	90 e0       	ldi	r25, 0x00	; 0
    1242:	88 0f       	add	r24, r24
    1244:	99 1f       	adc	r25, r25
    1246:	fc 01       	movw	r30, r24
    1248:	e8 57       	subi	r30, 0x78	; 120
    124a:	fe 4f       	sbci	r31, 0xFE	; 254
    124c:	01 90       	ld	r0, Z+
    124e:	f0 81       	ld	r31, Z
    1250:	e0 2d       	mov	r30, r0
    1252:	80 81       	ld	r24, Z
    1254:	48 2f       	mov	r20, r24
    1256:	8a 81       	ldd	r24, Y+2	; 0x02
    1258:	28 2f       	mov	r18, r24
    125a:	30 e0       	ldi	r19, 0x00	; 0
    125c:	81 e0       	ldi	r24, 0x01	; 1
    125e:	90 e0       	ldi	r25, 0x00	; 0
    1260:	02 2e       	mov	r0, r18
    1262:	02 c0       	rjmp	.+4      	; 0x1268 <DIO_void_toggle_pin+0x4e>
    1264:	88 0f       	add	r24, r24
    1266:	99 1f       	adc	r25, r25
    1268:	0a 94       	dec	r0
    126a:	e2 f7       	brpl	.-8      	; 0x1264 <DIO_void_toggle_pin+0x4a>
    126c:	84 27       	eor	r24, r20
    126e:	8c 93       	st	X, r24

}
    1270:	0f 90       	pop	r0
    1272:	0f 90       	pop	r0
    1274:	cf 91       	pop	r28
    1276:	df 91       	pop	r29
    1278:	08 95       	ret

0000127a <DIO_u8_get_port>:

u8 DIO_u8_get_port(u8 copy_u8_portID){
    127a:	df 93       	push	r29
    127c:	cf 93       	push	r28
    127e:	0f 92       	push	r0
    1280:	cd b7       	in	r28, 0x3d	; 61
    1282:	de b7       	in	r29, 0x3e	; 62
    1284:	89 83       	std	Y+1, r24	; 0x01
	 *  1 byte data
	 */



	return *(DIO_PINx[copy_u8_portID]);
    1286:	89 81       	ldd	r24, Y+1	; 0x01
    1288:	88 2f       	mov	r24, r24
    128a:	90 e0       	ldi	r25, 0x00	; 0
    128c:	88 0f       	add	r24, r24
    128e:	99 1f       	adc	r25, r25
    1290:	fc 01       	movw	r30, r24
    1292:	e8 58       	subi	r30, 0x88	; 136
    1294:	fe 4f       	sbci	r31, 0xFE	; 254
    1296:	01 90       	ld	r0, Z+
    1298:	f0 81       	ld	r31, Z
    129a:	e0 2d       	mov	r30, r0
    129c:	80 81       	ld	r24, Z
}
    129e:	0f 90       	pop	r0
    12a0:	cf 91       	pop	r28
    12a2:	df 91       	pop	r29
    12a4:	08 95       	ret

000012a6 <DIO_u8_get_pin>:

u8 DIO_u8_get_pin(u8 copy_u8_portID, u8 copy_u8_pinID){
    12a6:	df 93       	push	r29
    12a8:	cf 93       	push	r28
    12aa:	00 d0       	rcall	.+0      	; 0x12ac <DIO_u8_get_pin+0x6>
    12ac:	cd b7       	in	r28, 0x3d	; 61
    12ae:	de b7       	in	r29, 0x3e	; 62
    12b0:	89 83       	std	Y+1, r24	; 0x01
    12b2:	6a 83       	std	Y+2, r22	; 0x02
	 *
	 *
	 */


	return get_Bit(*(DIO_PINx[copy_u8_portID]),copy_u8_pinID);
    12b4:	89 81       	ldd	r24, Y+1	; 0x01
    12b6:	88 2f       	mov	r24, r24
    12b8:	90 e0       	ldi	r25, 0x00	; 0
    12ba:	88 0f       	add	r24, r24
    12bc:	99 1f       	adc	r25, r25
    12be:	fc 01       	movw	r30, r24
    12c0:	e8 58       	subi	r30, 0x88	; 136
    12c2:	fe 4f       	sbci	r31, 0xFE	; 254
    12c4:	01 90       	ld	r0, Z+
    12c6:	f0 81       	ld	r31, Z
    12c8:	e0 2d       	mov	r30, r0
    12ca:	80 81       	ld	r24, Z
    12cc:	28 2f       	mov	r18, r24
    12ce:	30 e0       	ldi	r19, 0x00	; 0
    12d0:	8a 81       	ldd	r24, Y+2	; 0x02
    12d2:	88 2f       	mov	r24, r24
    12d4:	90 e0       	ldi	r25, 0x00	; 0
    12d6:	a9 01       	movw	r20, r18
    12d8:	02 c0       	rjmp	.+4      	; 0x12de <DIO_u8_get_pin+0x38>
    12da:	55 95       	asr	r21
    12dc:	47 95       	ror	r20
    12de:	8a 95       	dec	r24
    12e0:	e2 f7       	brpl	.-8      	; 0x12da <DIO_u8_get_pin+0x34>
    12e2:	ca 01       	movw	r24, r20
    12e4:	81 70       	andi	r24, 0x01	; 1
}
    12e6:	0f 90       	pop	r0
    12e8:	0f 90       	pop	r0
    12ea:	cf 91       	pop	r28
    12ec:	df 91       	pop	r29
    12ee:	08 95       	ret

000012f0 <array_Swap>:
#include "../../../Drivers/HAL/LCD/LCD_Config.h"
#include "LCD_Interface.h"
#include "../../../Drivers/HAL/LCD/LCD_Private.h"


static void array_Swap(u8* copy_pu8_arr, u8 copy_length){
    12f0:	df 93       	push	r29
    12f2:	cf 93       	push	r28
    12f4:	00 d0       	rcall	.+0      	; 0x12f6 <array_Swap+0x6>
    12f6:	00 d0       	rcall	.+0      	; 0x12f8 <array_Swap+0x8>
    12f8:	00 d0       	rcall	.+0      	; 0x12fa <array_Swap+0xa>
    12fa:	cd b7       	in	r28, 0x3d	; 61
    12fc:	de b7       	in	r29, 0x3e	; 62
    12fe:	9d 83       	std	Y+5, r25	; 0x05
    1300:	8c 83       	std	Y+4, r24	; 0x04
    1302:	6e 83       	std	Y+6, r22	; 0x06
	 *
	 *
	 */


	u8 start = 0;
    1304:	1b 82       	std	Y+3, r1	; 0x03
	u8 end = copy_length - 1;
    1306:	8e 81       	ldd	r24, Y+6	; 0x06
    1308:	81 50       	subi	r24, 0x01	; 1
    130a:	8a 83       	std	Y+2, r24	; 0x02
    130c:	2c c0       	rjmp	.+88     	; 0x1366 <array_Swap+0x76>

	while(start < end){

		u8 temp = copy_pu8_arr[start];
    130e:	8b 81       	ldd	r24, Y+3	; 0x03
    1310:	28 2f       	mov	r18, r24
    1312:	30 e0       	ldi	r19, 0x00	; 0
    1314:	8c 81       	ldd	r24, Y+4	; 0x04
    1316:	9d 81       	ldd	r25, Y+5	; 0x05
    1318:	fc 01       	movw	r30, r24
    131a:	e2 0f       	add	r30, r18
    131c:	f3 1f       	adc	r31, r19
    131e:	80 81       	ld	r24, Z
    1320:	89 83       	std	Y+1, r24	; 0x01
		copy_pu8_arr[start] = copy_pu8_arr[end];
    1322:	8b 81       	ldd	r24, Y+3	; 0x03
    1324:	28 2f       	mov	r18, r24
    1326:	30 e0       	ldi	r19, 0x00	; 0
    1328:	8c 81       	ldd	r24, Y+4	; 0x04
    132a:	9d 81       	ldd	r25, Y+5	; 0x05
    132c:	dc 01       	movw	r26, r24
    132e:	a2 0f       	add	r26, r18
    1330:	b3 1f       	adc	r27, r19
    1332:	8a 81       	ldd	r24, Y+2	; 0x02
    1334:	28 2f       	mov	r18, r24
    1336:	30 e0       	ldi	r19, 0x00	; 0
    1338:	8c 81       	ldd	r24, Y+4	; 0x04
    133a:	9d 81       	ldd	r25, Y+5	; 0x05
    133c:	fc 01       	movw	r30, r24
    133e:	e2 0f       	add	r30, r18
    1340:	f3 1f       	adc	r31, r19
    1342:	80 81       	ld	r24, Z
    1344:	8c 93       	st	X, r24
		copy_pu8_arr[end] = temp;
    1346:	8a 81       	ldd	r24, Y+2	; 0x02
    1348:	28 2f       	mov	r18, r24
    134a:	30 e0       	ldi	r19, 0x00	; 0
    134c:	8c 81       	ldd	r24, Y+4	; 0x04
    134e:	9d 81       	ldd	r25, Y+5	; 0x05
    1350:	fc 01       	movw	r30, r24
    1352:	e2 0f       	add	r30, r18
    1354:	f3 1f       	adc	r31, r19
    1356:	89 81       	ldd	r24, Y+1	; 0x01
    1358:	80 83       	st	Z, r24

		start++;
    135a:	8b 81       	ldd	r24, Y+3	; 0x03
    135c:	8f 5f       	subi	r24, 0xFF	; 255
    135e:	8b 83       	std	Y+3, r24	; 0x03
		end--;
    1360:	8a 81       	ldd	r24, Y+2	; 0x02
    1362:	81 50       	subi	r24, 0x01	; 1
    1364:	8a 83       	std	Y+2, r24	; 0x02


	u8 start = 0;
	u8 end = copy_length - 1;

	while(start < end){
    1366:	9b 81       	ldd	r25, Y+3	; 0x03
    1368:	8a 81       	ldd	r24, Y+2	; 0x02
    136a:	98 17       	cp	r25, r24
    136c:	80 f2       	brcs	.-96     	; 0x130e <array_Swap+0x1e>
	}




}
    136e:	26 96       	adiw	r28, 0x06	; 6
    1370:	0f b6       	in	r0, 0x3f	; 63
    1372:	f8 94       	cli
    1374:	de bf       	out	0x3e, r29	; 62
    1376:	0f be       	out	0x3f, r0	; 63
    1378:	cd bf       	out	0x3d, r28	; 61
    137a:	cf 91       	pop	r28
    137c:	df 91       	pop	r29
    137e:	08 95       	ret

00001380 <power_10>:

s32 power_10(u8 power){
    1380:	df 93       	push	r29
    1382:	cf 93       	push	r28
    1384:	00 d0       	rcall	.+0      	; 0x1386 <power_10+0x6>
    1386:	00 d0       	rcall	.+0      	; 0x1388 <power_10+0x8>
    1388:	0f 92       	push	r0
    138a:	cd b7       	in	r28, 0x3d	; 61
    138c:	de b7       	in	r29, 0x3e	; 62
    138e:	8d 83       	std	Y+5, r24	; 0x05
	 *
	 * do you not use this function outside this driver
	 *
	 */

	s32 result = 1;
    1390:	81 e0       	ldi	r24, 0x01	; 1
    1392:	90 e0       	ldi	r25, 0x00	; 0
    1394:	a0 e0       	ldi	r26, 0x00	; 0
    1396:	b0 e0       	ldi	r27, 0x00	; 0
    1398:	89 83       	std	Y+1, r24	; 0x01
    139a:	9a 83       	std	Y+2, r25	; 0x02
    139c:	ab 83       	std	Y+3, r26	; 0x03
    139e:	bc 83       	std	Y+4, r27	; 0x04
    13a0:	15 c0       	rjmp	.+42     	; 0x13cc <power_10+0x4c>

	while(power > 0){

		result *= 10;
    13a2:	89 81       	ldd	r24, Y+1	; 0x01
    13a4:	9a 81       	ldd	r25, Y+2	; 0x02
    13a6:	ab 81       	ldd	r26, Y+3	; 0x03
    13a8:	bc 81       	ldd	r27, Y+4	; 0x04
    13aa:	2a e0       	ldi	r18, 0x0A	; 10
    13ac:	30 e0       	ldi	r19, 0x00	; 0
    13ae:	40 e0       	ldi	r20, 0x00	; 0
    13b0:	50 e0       	ldi	r21, 0x00	; 0
    13b2:	bc 01       	movw	r22, r24
    13b4:	cd 01       	movw	r24, r26
    13b6:	0e 94 03 3e 	call	0x7c06	; 0x7c06 <__mulsi3>
    13ba:	dc 01       	movw	r26, r24
    13bc:	cb 01       	movw	r24, r22
    13be:	89 83       	std	Y+1, r24	; 0x01
    13c0:	9a 83       	std	Y+2, r25	; 0x02
    13c2:	ab 83       	std	Y+3, r26	; 0x03
    13c4:	bc 83       	std	Y+4, r27	; 0x04
		power--;
    13c6:	8d 81       	ldd	r24, Y+5	; 0x05
    13c8:	81 50       	subi	r24, 0x01	; 1
    13ca:	8d 83       	std	Y+5, r24	; 0x05
	 *
	 */

	s32 result = 1;

	while(power > 0){
    13cc:	8d 81       	ldd	r24, Y+5	; 0x05
    13ce:	88 23       	and	r24, r24
    13d0:	41 f7       	brne	.-48     	; 0x13a2 <power_10+0x22>

		result *= 10;
		power--;
	}

	return result;
    13d2:	89 81       	ldd	r24, Y+1	; 0x01
    13d4:	9a 81       	ldd	r25, Y+2	; 0x02
    13d6:	ab 81       	ldd	r26, Y+3	; 0x03
    13d8:	bc 81       	ldd	r27, Y+4	; 0x04
}
    13da:	bc 01       	movw	r22, r24
    13dc:	cd 01       	movw	r24, r26
    13de:	0f 90       	pop	r0
    13e0:	0f 90       	pop	r0
    13e2:	0f 90       	pop	r0
    13e4:	0f 90       	pop	r0
    13e6:	0f 90       	pop	r0
    13e8:	cf 91       	pop	r28
    13ea:	df 91       	pop	r29
    13ec:	08 95       	ret

000013ee <LCD_write_data_8bit>:

/* 8bit mode functions */


static void LCD_write_data_8bit(u8 copy_data_8bit){
    13ee:	df 93       	push	r29
    13f0:	cf 93       	push	r28
    13f2:	cd b7       	in	r28, 0x3d	; 61
    13f4:	de b7       	in	r29, 0x3e	; 62
    13f6:	e1 97       	sbiw	r28, 0x31	; 49
    13f8:	0f b6       	in	r0, 0x3f	; 63
    13fa:	f8 94       	cli
    13fc:	de bf       	out	0x3e, r29	; 62
    13fe:	0f be       	out	0x3f, r0	; 63
    1400:	cd bf       	out	0x3d, r28	; 61
    1402:	89 ab       	std	Y+49, r24	; 0x31
	 *  function will only be used inside this source file
	 *  do you not use it in your code!
	 *
	 */

	DIO_void_set_pin(lcd_control_port, lcd_RS); // set RS pin high select data register
    1404:	83 e0       	ldi	r24, 0x03	; 3
    1406:	62 e0       	ldi	r22, 0x02	; 2
    1408:	0e 94 50 08 	call	0x10a0	; 0x10a0 <DIO_void_set_pin>
	DIO_void_clear_pin(lcd_control_port, lcd_RW); // clear RW pin  0 for writing operation
    140c:	83 e0       	ldi	r24, 0x03	; 3
    140e:	61 e0       	ldi	r22, 0x01	; 1
    1410:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>
    1414:	80 e0       	ldi	r24, 0x00	; 0
    1416:	90 e0       	ldi	r25, 0x00	; 0
    1418:	a8 e4       	ldi	r26, 0x48	; 72
    141a:	b2 e4       	ldi	r27, 0x42	; 66
    141c:	8d a7       	std	Y+45, r24	; 0x2d
    141e:	9e a7       	std	Y+46, r25	; 0x2e
    1420:	af a7       	std	Y+47, r26	; 0x2f
    1422:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1424:	6d a5       	ldd	r22, Y+45	; 0x2d
    1426:	7e a5       	ldd	r23, Y+46	; 0x2e
    1428:	8f a5       	ldd	r24, Y+47	; 0x2f
    142a:	98 a9       	ldd	r25, Y+48	; 0x30
    142c:	2b ea       	ldi	r18, 0xAB	; 171
    142e:	3a ea       	ldi	r19, 0xAA	; 170
    1430:	4a e2       	ldi	r20, 0x2A	; 42
    1432:	50 e4       	ldi	r21, 0x40	; 64
    1434:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1438:	dc 01       	movw	r26, r24
    143a:	cb 01       	movw	r24, r22
    143c:	89 a7       	std	Y+41, r24	; 0x29
    143e:	9a a7       	std	Y+42, r25	; 0x2a
    1440:	ab a7       	std	Y+43, r26	; 0x2b
    1442:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    1444:	69 a5       	ldd	r22, Y+41	; 0x29
    1446:	7a a5       	ldd	r23, Y+42	; 0x2a
    1448:	8b a5       	ldd	r24, Y+43	; 0x2b
    144a:	9c a5       	ldd	r25, Y+44	; 0x2c
    144c:	20 e0       	ldi	r18, 0x00	; 0
    144e:	30 e0       	ldi	r19, 0x00	; 0
    1450:	40 e8       	ldi	r20, 0x80	; 128
    1452:	5f e3       	ldi	r21, 0x3F	; 63
    1454:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1458:	88 23       	and	r24, r24
    145a:	1c f4       	brge	.+6      	; 0x1462 <LCD_write_data_8bit+0x74>
		__ticks = 1;
    145c:	81 e0       	ldi	r24, 0x01	; 1
    145e:	88 a7       	std	Y+40, r24	; 0x28
    1460:	91 c0       	rjmp	.+290    	; 0x1584 <LCD_write_data_8bit+0x196>
	else if (__tmp > 255)
    1462:	69 a5       	ldd	r22, Y+41	; 0x29
    1464:	7a a5       	ldd	r23, Y+42	; 0x2a
    1466:	8b a5       	ldd	r24, Y+43	; 0x2b
    1468:	9c a5       	ldd	r25, Y+44	; 0x2c
    146a:	20 e0       	ldi	r18, 0x00	; 0
    146c:	30 e0       	ldi	r19, 0x00	; 0
    146e:	4f e7       	ldi	r20, 0x7F	; 127
    1470:	53 e4       	ldi	r21, 0x43	; 67
    1472:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1476:	18 16       	cp	r1, r24
    1478:	0c f0       	brlt	.+2      	; 0x147c <LCD_write_data_8bit+0x8e>
    147a:	7b c0       	rjmp	.+246    	; 0x1572 <LCD_write_data_8bit+0x184>
	{
		_delay_ms(__us / 1000.0);
    147c:	6d a5       	ldd	r22, Y+45	; 0x2d
    147e:	7e a5       	ldd	r23, Y+46	; 0x2e
    1480:	8f a5       	ldd	r24, Y+47	; 0x2f
    1482:	98 a9       	ldd	r25, Y+48	; 0x30
    1484:	20 e0       	ldi	r18, 0x00	; 0
    1486:	30 e0       	ldi	r19, 0x00	; 0
    1488:	4a e7       	ldi	r20, 0x7A	; 122
    148a:	54 e4       	ldi	r21, 0x44	; 68
    148c:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1490:	dc 01       	movw	r26, r24
    1492:	cb 01       	movw	r24, r22
    1494:	8c a3       	std	Y+36, r24	; 0x24
    1496:	9d a3       	std	Y+37, r25	; 0x25
    1498:	ae a3       	std	Y+38, r26	; 0x26
    149a:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    149c:	6c a1       	ldd	r22, Y+36	; 0x24
    149e:	7d a1       	ldd	r23, Y+37	; 0x25
    14a0:	8e a1       	ldd	r24, Y+38	; 0x26
    14a2:	9f a1       	ldd	r25, Y+39	; 0x27
    14a4:	20 e0       	ldi	r18, 0x00	; 0
    14a6:	30 e0       	ldi	r19, 0x00	; 0
    14a8:	4a ef       	ldi	r20, 0xFA	; 250
    14aa:	54 e4       	ldi	r21, 0x44	; 68
    14ac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    14b0:	dc 01       	movw	r26, r24
    14b2:	cb 01       	movw	r24, r22
    14b4:	88 a3       	std	Y+32, r24	; 0x20
    14b6:	99 a3       	std	Y+33, r25	; 0x21
    14b8:	aa a3       	std	Y+34, r26	; 0x22
    14ba:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    14bc:	68 a1       	ldd	r22, Y+32	; 0x20
    14be:	79 a1       	ldd	r23, Y+33	; 0x21
    14c0:	8a a1       	ldd	r24, Y+34	; 0x22
    14c2:	9b a1       	ldd	r25, Y+35	; 0x23
    14c4:	20 e0       	ldi	r18, 0x00	; 0
    14c6:	30 e0       	ldi	r19, 0x00	; 0
    14c8:	40 e8       	ldi	r20, 0x80	; 128
    14ca:	5f e3       	ldi	r21, 0x3F	; 63
    14cc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    14d0:	88 23       	and	r24, r24
    14d2:	2c f4       	brge	.+10     	; 0x14de <LCD_write_data_8bit+0xf0>
		__ticks = 1;
    14d4:	81 e0       	ldi	r24, 0x01	; 1
    14d6:	90 e0       	ldi	r25, 0x00	; 0
    14d8:	9f 8f       	std	Y+31, r25	; 0x1f
    14da:	8e 8f       	std	Y+30, r24	; 0x1e
    14dc:	3f c0       	rjmp	.+126    	; 0x155c <LCD_write_data_8bit+0x16e>
	else if (__tmp > 65535)
    14de:	68 a1       	ldd	r22, Y+32	; 0x20
    14e0:	79 a1       	ldd	r23, Y+33	; 0x21
    14e2:	8a a1       	ldd	r24, Y+34	; 0x22
    14e4:	9b a1       	ldd	r25, Y+35	; 0x23
    14e6:	20 e0       	ldi	r18, 0x00	; 0
    14e8:	3f ef       	ldi	r19, 0xFF	; 255
    14ea:	4f e7       	ldi	r20, 0x7F	; 127
    14ec:	57 e4       	ldi	r21, 0x47	; 71
    14ee:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    14f2:	18 16       	cp	r1, r24
    14f4:	4c f5       	brge	.+82     	; 0x1548 <LCD_write_data_8bit+0x15a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    14f6:	6c a1       	ldd	r22, Y+36	; 0x24
    14f8:	7d a1       	ldd	r23, Y+37	; 0x25
    14fa:	8e a1       	ldd	r24, Y+38	; 0x26
    14fc:	9f a1       	ldd	r25, Y+39	; 0x27
    14fe:	20 e0       	ldi	r18, 0x00	; 0
    1500:	30 e0       	ldi	r19, 0x00	; 0
    1502:	40 e2       	ldi	r20, 0x20	; 32
    1504:	51 e4       	ldi	r21, 0x41	; 65
    1506:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    150a:	dc 01       	movw	r26, r24
    150c:	cb 01       	movw	r24, r22
    150e:	bc 01       	movw	r22, r24
    1510:	cd 01       	movw	r24, r26
    1512:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1516:	dc 01       	movw	r26, r24
    1518:	cb 01       	movw	r24, r22
    151a:	9f 8f       	std	Y+31, r25	; 0x1f
    151c:	8e 8f       	std	Y+30, r24	; 0x1e
    151e:	0f c0       	rjmp	.+30     	; 0x153e <LCD_write_data_8bit+0x150>
    1520:	88 ec       	ldi	r24, 0xC8	; 200
    1522:	90 e0       	ldi	r25, 0x00	; 0
    1524:	9d 8f       	std	Y+29, r25	; 0x1d
    1526:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1528:	8c 8d       	ldd	r24, Y+28	; 0x1c
    152a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    152c:	01 97       	sbiw	r24, 0x01	; 1
    152e:	f1 f7       	brne	.-4      	; 0x152c <LCD_write_data_8bit+0x13e>
    1530:	9d 8f       	std	Y+29, r25	; 0x1d
    1532:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1534:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1536:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1538:	01 97       	sbiw	r24, 0x01	; 1
    153a:	9f 8f       	std	Y+31, r25	; 0x1f
    153c:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    153e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1540:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1542:	00 97       	sbiw	r24, 0x00	; 0
    1544:	69 f7       	brne	.-38     	; 0x1520 <LCD_write_data_8bit+0x132>
    1546:	24 c0       	rjmp	.+72     	; 0x1590 <LCD_write_data_8bit+0x1a2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1548:	68 a1       	ldd	r22, Y+32	; 0x20
    154a:	79 a1       	ldd	r23, Y+33	; 0x21
    154c:	8a a1       	ldd	r24, Y+34	; 0x22
    154e:	9b a1       	ldd	r25, Y+35	; 0x23
    1550:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1554:	dc 01       	movw	r26, r24
    1556:	cb 01       	movw	r24, r22
    1558:	9f 8f       	std	Y+31, r25	; 0x1f
    155a:	8e 8f       	std	Y+30, r24	; 0x1e
    155c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    155e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1560:	9b 8f       	std	Y+27, r25	; 0x1b
    1562:	8a 8f       	std	Y+26, r24	; 0x1a
    1564:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1566:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1568:	01 97       	sbiw	r24, 0x01	; 1
    156a:	f1 f7       	brne	.-4      	; 0x1568 <LCD_write_data_8bit+0x17a>
    156c:	9b 8f       	std	Y+27, r25	; 0x1b
    156e:	8a 8f       	std	Y+26, r24	; 0x1a
    1570:	0f c0       	rjmp	.+30     	; 0x1590 <LCD_write_data_8bit+0x1a2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1572:	69 a5       	ldd	r22, Y+41	; 0x29
    1574:	7a a5       	ldd	r23, Y+42	; 0x2a
    1576:	8b a5       	ldd	r24, Y+43	; 0x2b
    1578:	9c a5       	ldd	r25, Y+44	; 0x2c
    157a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    157e:	dc 01       	movw	r26, r24
    1580:	cb 01       	movw	r24, r22
    1582:	88 a7       	std	Y+40, r24	; 0x28
    1584:	88 a5       	ldd	r24, Y+40	; 0x28
    1586:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1588:	89 8d       	ldd	r24, Y+25	; 0x19
    158a:	8a 95       	dec	r24
    158c:	f1 f7       	brne	.-4      	; 0x158a <LCD_write_data_8bit+0x19c>
    158e:	89 8f       	std	Y+25, r24	; 0x19

	_delay_us(50);
	//enable pin high
	DIO_void_set_pin(lcd_control_port, lcd_enable);
    1590:	83 e0       	ldi	r24, 0x03	; 3
    1592:	60 e0       	ldi	r22, 0x00	; 0
    1594:	0e 94 50 08 	call	0x10a0	; 0x10a0 <DIO_void_set_pin>
    1598:	80 e0       	ldi	r24, 0x00	; 0
    159a:	90 e0       	ldi	r25, 0x00	; 0
    159c:	a8 e4       	ldi	r26, 0x48	; 72
    159e:	b2 e4       	ldi	r27, 0x42	; 66
    15a0:	8d 8b       	std	Y+21, r24	; 0x15
    15a2:	9e 8b       	std	Y+22, r25	; 0x16
    15a4:	af 8b       	std	Y+23, r26	; 0x17
    15a6:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    15a8:	6d 89       	ldd	r22, Y+21	; 0x15
    15aa:	7e 89       	ldd	r23, Y+22	; 0x16
    15ac:	8f 89       	ldd	r24, Y+23	; 0x17
    15ae:	98 8d       	ldd	r25, Y+24	; 0x18
    15b0:	2b ea       	ldi	r18, 0xAB	; 171
    15b2:	3a ea       	ldi	r19, 0xAA	; 170
    15b4:	4a e2       	ldi	r20, 0x2A	; 42
    15b6:	50 e4       	ldi	r21, 0x40	; 64
    15b8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    15bc:	dc 01       	movw	r26, r24
    15be:	cb 01       	movw	r24, r22
    15c0:	89 8b       	std	Y+17, r24	; 0x11
    15c2:	9a 8b       	std	Y+18, r25	; 0x12
    15c4:	ab 8b       	std	Y+19, r26	; 0x13
    15c6:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    15c8:	69 89       	ldd	r22, Y+17	; 0x11
    15ca:	7a 89       	ldd	r23, Y+18	; 0x12
    15cc:	8b 89       	ldd	r24, Y+19	; 0x13
    15ce:	9c 89       	ldd	r25, Y+20	; 0x14
    15d0:	20 e0       	ldi	r18, 0x00	; 0
    15d2:	30 e0       	ldi	r19, 0x00	; 0
    15d4:	40 e8       	ldi	r20, 0x80	; 128
    15d6:	5f e3       	ldi	r21, 0x3F	; 63
    15d8:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    15dc:	88 23       	and	r24, r24
    15de:	1c f4       	brge	.+6      	; 0x15e6 <LCD_write_data_8bit+0x1f8>
		__ticks = 1;
    15e0:	81 e0       	ldi	r24, 0x01	; 1
    15e2:	88 8b       	std	Y+16, r24	; 0x10
    15e4:	91 c0       	rjmp	.+290    	; 0x1708 <LCD_write_data_8bit+0x31a>
	else if (__tmp > 255)
    15e6:	69 89       	ldd	r22, Y+17	; 0x11
    15e8:	7a 89       	ldd	r23, Y+18	; 0x12
    15ea:	8b 89       	ldd	r24, Y+19	; 0x13
    15ec:	9c 89       	ldd	r25, Y+20	; 0x14
    15ee:	20 e0       	ldi	r18, 0x00	; 0
    15f0:	30 e0       	ldi	r19, 0x00	; 0
    15f2:	4f e7       	ldi	r20, 0x7F	; 127
    15f4:	53 e4       	ldi	r21, 0x43	; 67
    15f6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    15fa:	18 16       	cp	r1, r24
    15fc:	0c f0       	brlt	.+2      	; 0x1600 <LCD_write_data_8bit+0x212>
    15fe:	7b c0       	rjmp	.+246    	; 0x16f6 <LCD_write_data_8bit+0x308>
	{
		_delay_ms(__us / 1000.0);
    1600:	6d 89       	ldd	r22, Y+21	; 0x15
    1602:	7e 89       	ldd	r23, Y+22	; 0x16
    1604:	8f 89       	ldd	r24, Y+23	; 0x17
    1606:	98 8d       	ldd	r25, Y+24	; 0x18
    1608:	20 e0       	ldi	r18, 0x00	; 0
    160a:	30 e0       	ldi	r19, 0x00	; 0
    160c:	4a e7       	ldi	r20, 0x7A	; 122
    160e:	54 e4       	ldi	r21, 0x44	; 68
    1610:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1614:	dc 01       	movw	r26, r24
    1616:	cb 01       	movw	r24, r22
    1618:	8c 87       	std	Y+12, r24	; 0x0c
    161a:	9d 87       	std	Y+13, r25	; 0x0d
    161c:	ae 87       	std	Y+14, r26	; 0x0e
    161e:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1620:	6c 85       	ldd	r22, Y+12	; 0x0c
    1622:	7d 85       	ldd	r23, Y+13	; 0x0d
    1624:	8e 85       	ldd	r24, Y+14	; 0x0e
    1626:	9f 85       	ldd	r25, Y+15	; 0x0f
    1628:	20 e0       	ldi	r18, 0x00	; 0
    162a:	30 e0       	ldi	r19, 0x00	; 0
    162c:	4a ef       	ldi	r20, 0xFA	; 250
    162e:	54 e4       	ldi	r21, 0x44	; 68
    1630:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1634:	dc 01       	movw	r26, r24
    1636:	cb 01       	movw	r24, r22
    1638:	88 87       	std	Y+8, r24	; 0x08
    163a:	99 87       	std	Y+9, r25	; 0x09
    163c:	aa 87       	std	Y+10, r26	; 0x0a
    163e:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    1640:	68 85       	ldd	r22, Y+8	; 0x08
    1642:	79 85       	ldd	r23, Y+9	; 0x09
    1644:	8a 85       	ldd	r24, Y+10	; 0x0a
    1646:	9b 85       	ldd	r25, Y+11	; 0x0b
    1648:	20 e0       	ldi	r18, 0x00	; 0
    164a:	30 e0       	ldi	r19, 0x00	; 0
    164c:	40 e8       	ldi	r20, 0x80	; 128
    164e:	5f e3       	ldi	r21, 0x3F	; 63
    1650:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1654:	88 23       	and	r24, r24
    1656:	2c f4       	brge	.+10     	; 0x1662 <LCD_write_data_8bit+0x274>
		__ticks = 1;
    1658:	81 e0       	ldi	r24, 0x01	; 1
    165a:	90 e0       	ldi	r25, 0x00	; 0
    165c:	9f 83       	std	Y+7, r25	; 0x07
    165e:	8e 83       	std	Y+6, r24	; 0x06
    1660:	3f c0       	rjmp	.+126    	; 0x16e0 <LCD_write_data_8bit+0x2f2>
	else if (__tmp > 65535)
    1662:	68 85       	ldd	r22, Y+8	; 0x08
    1664:	79 85       	ldd	r23, Y+9	; 0x09
    1666:	8a 85       	ldd	r24, Y+10	; 0x0a
    1668:	9b 85       	ldd	r25, Y+11	; 0x0b
    166a:	20 e0       	ldi	r18, 0x00	; 0
    166c:	3f ef       	ldi	r19, 0xFF	; 255
    166e:	4f e7       	ldi	r20, 0x7F	; 127
    1670:	57 e4       	ldi	r21, 0x47	; 71
    1672:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1676:	18 16       	cp	r1, r24
    1678:	4c f5       	brge	.+82     	; 0x16cc <LCD_write_data_8bit+0x2de>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    167a:	6c 85       	ldd	r22, Y+12	; 0x0c
    167c:	7d 85       	ldd	r23, Y+13	; 0x0d
    167e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1680:	9f 85       	ldd	r25, Y+15	; 0x0f
    1682:	20 e0       	ldi	r18, 0x00	; 0
    1684:	30 e0       	ldi	r19, 0x00	; 0
    1686:	40 e2       	ldi	r20, 0x20	; 32
    1688:	51 e4       	ldi	r21, 0x41	; 65
    168a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    168e:	dc 01       	movw	r26, r24
    1690:	cb 01       	movw	r24, r22
    1692:	bc 01       	movw	r22, r24
    1694:	cd 01       	movw	r24, r26
    1696:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    169a:	dc 01       	movw	r26, r24
    169c:	cb 01       	movw	r24, r22
    169e:	9f 83       	std	Y+7, r25	; 0x07
    16a0:	8e 83       	std	Y+6, r24	; 0x06
    16a2:	0f c0       	rjmp	.+30     	; 0x16c2 <LCD_write_data_8bit+0x2d4>
    16a4:	88 ec       	ldi	r24, 0xC8	; 200
    16a6:	90 e0       	ldi	r25, 0x00	; 0
    16a8:	9d 83       	std	Y+5, r25	; 0x05
    16aa:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    16ac:	8c 81       	ldd	r24, Y+4	; 0x04
    16ae:	9d 81       	ldd	r25, Y+5	; 0x05
    16b0:	01 97       	sbiw	r24, 0x01	; 1
    16b2:	f1 f7       	brne	.-4      	; 0x16b0 <LCD_write_data_8bit+0x2c2>
    16b4:	9d 83       	std	Y+5, r25	; 0x05
    16b6:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    16b8:	8e 81       	ldd	r24, Y+6	; 0x06
    16ba:	9f 81       	ldd	r25, Y+7	; 0x07
    16bc:	01 97       	sbiw	r24, 0x01	; 1
    16be:	9f 83       	std	Y+7, r25	; 0x07
    16c0:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    16c2:	8e 81       	ldd	r24, Y+6	; 0x06
    16c4:	9f 81       	ldd	r25, Y+7	; 0x07
    16c6:	00 97       	sbiw	r24, 0x00	; 0
    16c8:	69 f7       	brne	.-38     	; 0x16a4 <LCD_write_data_8bit+0x2b6>
    16ca:	24 c0       	rjmp	.+72     	; 0x1714 <LCD_write_data_8bit+0x326>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    16cc:	68 85       	ldd	r22, Y+8	; 0x08
    16ce:	79 85       	ldd	r23, Y+9	; 0x09
    16d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    16d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    16d4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16d8:	dc 01       	movw	r26, r24
    16da:	cb 01       	movw	r24, r22
    16dc:	9f 83       	std	Y+7, r25	; 0x07
    16de:	8e 83       	std	Y+6, r24	; 0x06
    16e0:	8e 81       	ldd	r24, Y+6	; 0x06
    16e2:	9f 81       	ldd	r25, Y+7	; 0x07
    16e4:	9b 83       	std	Y+3, r25	; 0x03
    16e6:	8a 83       	std	Y+2, r24	; 0x02
    16e8:	8a 81       	ldd	r24, Y+2	; 0x02
    16ea:	9b 81       	ldd	r25, Y+3	; 0x03
    16ec:	01 97       	sbiw	r24, 0x01	; 1
    16ee:	f1 f7       	brne	.-4      	; 0x16ec <LCD_write_data_8bit+0x2fe>
    16f0:	9b 83       	std	Y+3, r25	; 0x03
    16f2:	8a 83       	std	Y+2, r24	; 0x02
    16f4:	0f c0       	rjmp	.+30     	; 0x1714 <LCD_write_data_8bit+0x326>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    16f6:	69 89       	ldd	r22, Y+17	; 0x11
    16f8:	7a 89       	ldd	r23, Y+18	; 0x12
    16fa:	8b 89       	ldd	r24, Y+19	; 0x13
    16fc:	9c 89       	ldd	r25, Y+20	; 0x14
    16fe:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1702:	dc 01       	movw	r26, r24
    1704:	cb 01       	movw	r24, r22
    1706:	88 8b       	std	Y+16, r24	; 0x10
    1708:	88 89       	ldd	r24, Y+16	; 0x10
    170a:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    170c:	89 81       	ldd	r24, Y+1	; 0x01
    170e:	8a 95       	dec	r24
    1710:	f1 f7       	brne	.-4      	; 0x170e <LCD_write_data_8bit+0x320>
    1712:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(50);
	//send data to the entire port


	DIO_void_clear_pin(lcd_control_port, lcd_enable);
    1714:	83 e0       	ldi	r24, 0x03	; 3
    1716:	60 e0       	ldi	r22, 0x00	; 0
    1718:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>


}
    171c:	e1 96       	adiw	r28, 0x31	; 49
    171e:	0f b6       	in	r0, 0x3f	; 63
    1720:	f8 94       	cli
    1722:	de bf       	out	0x3e, r29	; 62
    1724:	0f be       	out	0x3f, r0	; 63
    1726:	cd bf       	out	0x3d, r28	; 61
    1728:	cf 91       	pop	r28
    172a:	df 91       	pop	r29
    172c:	08 95       	ret

0000172e <LCD_write_command_8bit>:

static void LCD_write_command_8bit(u8 copy_command_8bit){
    172e:	df 93       	push	r29
    1730:	cf 93       	push	r28
    1732:	cd b7       	in	r28, 0x3d	; 61
    1734:	de b7       	in	r29, 0x3e	; 62
    1736:	e1 97       	sbiw	r28, 0x31	; 49
    1738:	0f b6       	in	r0, 0x3f	; 63
    173a:	f8 94       	cli
    173c:	de bf       	out	0x3e, r29	; 62
    173e:	0f be       	out	0x3f, r0	; 63
    1740:	cd bf       	out	0x3d, r28	; 61
    1742:	89 ab       	std	Y+49, r24	; 0x31
		 *
		 *  function will only be used inside this source file
		 *  do you not use it in your code!
		 *
		 */
	DIO_void_clear_pin(lcd_control_port, lcd_RS); // clear the RS pin to select instruction register
    1744:	83 e0       	ldi	r24, 0x03	; 3
    1746:	62 e0       	ldi	r22, 0x02	; 2
    1748:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>
	DIO_void_clear_pin(lcd_control_port, lcd_RW); // clear RW pin  0 for writing operation
    174c:	83 e0       	ldi	r24, 0x03	; 3
    174e:	61 e0       	ldi	r22, 0x01	; 1
    1750:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>
    1754:	80 e0       	ldi	r24, 0x00	; 0
    1756:	90 e0       	ldi	r25, 0x00	; 0
    1758:	a0 e8       	ldi	r26, 0x80	; 128
    175a:	bf e3       	ldi	r27, 0x3F	; 63
    175c:	8d a7       	std	Y+45, r24	; 0x2d
    175e:	9e a7       	std	Y+46, r25	; 0x2e
    1760:	af a7       	std	Y+47, r26	; 0x2f
    1762:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1764:	6d a5       	ldd	r22, Y+45	; 0x2d
    1766:	7e a5       	ldd	r23, Y+46	; 0x2e
    1768:	8f a5       	ldd	r24, Y+47	; 0x2f
    176a:	98 a9       	ldd	r25, Y+48	; 0x30
    176c:	2b ea       	ldi	r18, 0xAB	; 171
    176e:	3a ea       	ldi	r19, 0xAA	; 170
    1770:	4a e2       	ldi	r20, 0x2A	; 42
    1772:	50 e4       	ldi	r21, 0x40	; 64
    1774:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1778:	dc 01       	movw	r26, r24
    177a:	cb 01       	movw	r24, r22
    177c:	89 a7       	std	Y+41, r24	; 0x29
    177e:	9a a7       	std	Y+42, r25	; 0x2a
    1780:	ab a7       	std	Y+43, r26	; 0x2b
    1782:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    1784:	69 a5       	ldd	r22, Y+41	; 0x29
    1786:	7a a5       	ldd	r23, Y+42	; 0x2a
    1788:	8b a5       	ldd	r24, Y+43	; 0x2b
    178a:	9c a5       	ldd	r25, Y+44	; 0x2c
    178c:	20 e0       	ldi	r18, 0x00	; 0
    178e:	30 e0       	ldi	r19, 0x00	; 0
    1790:	40 e8       	ldi	r20, 0x80	; 128
    1792:	5f e3       	ldi	r21, 0x3F	; 63
    1794:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1798:	88 23       	and	r24, r24
    179a:	1c f4       	brge	.+6      	; 0x17a2 <LCD_write_command_8bit+0x74>
		__ticks = 1;
    179c:	81 e0       	ldi	r24, 0x01	; 1
    179e:	88 a7       	std	Y+40, r24	; 0x28
    17a0:	91 c0       	rjmp	.+290    	; 0x18c4 <LCD_write_command_8bit+0x196>
	else if (__tmp > 255)
    17a2:	69 a5       	ldd	r22, Y+41	; 0x29
    17a4:	7a a5       	ldd	r23, Y+42	; 0x2a
    17a6:	8b a5       	ldd	r24, Y+43	; 0x2b
    17a8:	9c a5       	ldd	r25, Y+44	; 0x2c
    17aa:	20 e0       	ldi	r18, 0x00	; 0
    17ac:	30 e0       	ldi	r19, 0x00	; 0
    17ae:	4f e7       	ldi	r20, 0x7F	; 127
    17b0:	53 e4       	ldi	r21, 0x43	; 67
    17b2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    17b6:	18 16       	cp	r1, r24
    17b8:	0c f0       	brlt	.+2      	; 0x17bc <LCD_write_command_8bit+0x8e>
    17ba:	7b c0       	rjmp	.+246    	; 0x18b2 <LCD_write_command_8bit+0x184>
	{
		_delay_ms(__us / 1000.0);
    17bc:	6d a5       	ldd	r22, Y+45	; 0x2d
    17be:	7e a5       	ldd	r23, Y+46	; 0x2e
    17c0:	8f a5       	ldd	r24, Y+47	; 0x2f
    17c2:	98 a9       	ldd	r25, Y+48	; 0x30
    17c4:	20 e0       	ldi	r18, 0x00	; 0
    17c6:	30 e0       	ldi	r19, 0x00	; 0
    17c8:	4a e7       	ldi	r20, 0x7A	; 122
    17ca:	54 e4       	ldi	r21, 0x44	; 68
    17cc:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    17d0:	dc 01       	movw	r26, r24
    17d2:	cb 01       	movw	r24, r22
    17d4:	8c a3       	std	Y+36, r24	; 0x24
    17d6:	9d a3       	std	Y+37, r25	; 0x25
    17d8:	ae a3       	std	Y+38, r26	; 0x26
    17da:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    17dc:	6c a1       	ldd	r22, Y+36	; 0x24
    17de:	7d a1       	ldd	r23, Y+37	; 0x25
    17e0:	8e a1       	ldd	r24, Y+38	; 0x26
    17e2:	9f a1       	ldd	r25, Y+39	; 0x27
    17e4:	20 e0       	ldi	r18, 0x00	; 0
    17e6:	30 e0       	ldi	r19, 0x00	; 0
    17e8:	4a ef       	ldi	r20, 0xFA	; 250
    17ea:	54 e4       	ldi	r21, 0x44	; 68
    17ec:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    17f0:	dc 01       	movw	r26, r24
    17f2:	cb 01       	movw	r24, r22
    17f4:	88 a3       	std	Y+32, r24	; 0x20
    17f6:	99 a3       	std	Y+33, r25	; 0x21
    17f8:	aa a3       	std	Y+34, r26	; 0x22
    17fa:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    17fc:	68 a1       	ldd	r22, Y+32	; 0x20
    17fe:	79 a1       	ldd	r23, Y+33	; 0x21
    1800:	8a a1       	ldd	r24, Y+34	; 0x22
    1802:	9b a1       	ldd	r25, Y+35	; 0x23
    1804:	20 e0       	ldi	r18, 0x00	; 0
    1806:	30 e0       	ldi	r19, 0x00	; 0
    1808:	40 e8       	ldi	r20, 0x80	; 128
    180a:	5f e3       	ldi	r21, 0x3F	; 63
    180c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1810:	88 23       	and	r24, r24
    1812:	2c f4       	brge	.+10     	; 0x181e <LCD_write_command_8bit+0xf0>
		__ticks = 1;
    1814:	81 e0       	ldi	r24, 0x01	; 1
    1816:	90 e0       	ldi	r25, 0x00	; 0
    1818:	9f 8f       	std	Y+31, r25	; 0x1f
    181a:	8e 8f       	std	Y+30, r24	; 0x1e
    181c:	3f c0       	rjmp	.+126    	; 0x189c <LCD_write_command_8bit+0x16e>
	else if (__tmp > 65535)
    181e:	68 a1       	ldd	r22, Y+32	; 0x20
    1820:	79 a1       	ldd	r23, Y+33	; 0x21
    1822:	8a a1       	ldd	r24, Y+34	; 0x22
    1824:	9b a1       	ldd	r25, Y+35	; 0x23
    1826:	20 e0       	ldi	r18, 0x00	; 0
    1828:	3f ef       	ldi	r19, 0xFF	; 255
    182a:	4f e7       	ldi	r20, 0x7F	; 127
    182c:	57 e4       	ldi	r21, 0x47	; 71
    182e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1832:	18 16       	cp	r1, r24
    1834:	4c f5       	brge	.+82     	; 0x1888 <LCD_write_command_8bit+0x15a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1836:	6c a1       	ldd	r22, Y+36	; 0x24
    1838:	7d a1       	ldd	r23, Y+37	; 0x25
    183a:	8e a1       	ldd	r24, Y+38	; 0x26
    183c:	9f a1       	ldd	r25, Y+39	; 0x27
    183e:	20 e0       	ldi	r18, 0x00	; 0
    1840:	30 e0       	ldi	r19, 0x00	; 0
    1842:	40 e2       	ldi	r20, 0x20	; 32
    1844:	51 e4       	ldi	r21, 0x41	; 65
    1846:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    184a:	dc 01       	movw	r26, r24
    184c:	cb 01       	movw	r24, r22
    184e:	bc 01       	movw	r22, r24
    1850:	cd 01       	movw	r24, r26
    1852:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1856:	dc 01       	movw	r26, r24
    1858:	cb 01       	movw	r24, r22
    185a:	9f 8f       	std	Y+31, r25	; 0x1f
    185c:	8e 8f       	std	Y+30, r24	; 0x1e
    185e:	0f c0       	rjmp	.+30     	; 0x187e <LCD_write_command_8bit+0x150>
    1860:	88 ec       	ldi	r24, 0xC8	; 200
    1862:	90 e0       	ldi	r25, 0x00	; 0
    1864:	9d 8f       	std	Y+29, r25	; 0x1d
    1866:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1868:	8c 8d       	ldd	r24, Y+28	; 0x1c
    186a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    186c:	01 97       	sbiw	r24, 0x01	; 1
    186e:	f1 f7       	brne	.-4      	; 0x186c <LCD_write_command_8bit+0x13e>
    1870:	9d 8f       	std	Y+29, r25	; 0x1d
    1872:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1874:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1876:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1878:	01 97       	sbiw	r24, 0x01	; 1
    187a:	9f 8f       	std	Y+31, r25	; 0x1f
    187c:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    187e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1880:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1882:	00 97       	sbiw	r24, 0x00	; 0
    1884:	69 f7       	brne	.-38     	; 0x1860 <LCD_write_command_8bit+0x132>
    1886:	24 c0       	rjmp	.+72     	; 0x18d0 <LCD_write_command_8bit+0x1a2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1888:	68 a1       	ldd	r22, Y+32	; 0x20
    188a:	79 a1       	ldd	r23, Y+33	; 0x21
    188c:	8a a1       	ldd	r24, Y+34	; 0x22
    188e:	9b a1       	ldd	r25, Y+35	; 0x23
    1890:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1894:	dc 01       	movw	r26, r24
    1896:	cb 01       	movw	r24, r22
    1898:	9f 8f       	std	Y+31, r25	; 0x1f
    189a:	8e 8f       	std	Y+30, r24	; 0x1e
    189c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    189e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    18a0:	9b 8f       	std	Y+27, r25	; 0x1b
    18a2:	8a 8f       	std	Y+26, r24	; 0x1a
    18a4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    18a6:	9b 8d       	ldd	r25, Y+27	; 0x1b
    18a8:	01 97       	sbiw	r24, 0x01	; 1
    18aa:	f1 f7       	brne	.-4      	; 0x18a8 <LCD_write_command_8bit+0x17a>
    18ac:	9b 8f       	std	Y+27, r25	; 0x1b
    18ae:	8a 8f       	std	Y+26, r24	; 0x1a
    18b0:	0f c0       	rjmp	.+30     	; 0x18d0 <LCD_write_command_8bit+0x1a2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    18b2:	69 a5       	ldd	r22, Y+41	; 0x29
    18b4:	7a a5       	ldd	r23, Y+42	; 0x2a
    18b6:	8b a5       	ldd	r24, Y+43	; 0x2b
    18b8:	9c a5       	ldd	r25, Y+44	; 0x2c
    18ba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    18be:	dc 01       	movw	r26, r24
    18c0:	cb 01       	movw	r24, r22
    18c2:	88 a7       	std	Y+40, r24	; 0x28
    18c4:	88 a5       	ldd	r24, Y+40	; 0x28
    18c6:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    18c8:	89 8d       	ldd	r24, Y+25	; 0x19
    18ca:	8a 95       	dec	r24
    18cc:	f1 f7       	brne	.-4      	; 0x18ca <LCD_write_command_8bit+0x19c>
    18ce:	89 8f       	std	Y+25, r24	; 0x19

	_delay_us(1);
	//enable pin high
	DIO_void_set_pin(lcd_control_port, lcd_enable);
    18d0:	83 e0       	ldi	r24, 0x03	; 3
    18d2:	60 e0       	ldi	r22, 0x00	; 0
    18d4:	0e 94 50 08 	call	0x10a0	; 0x10a0 <DIO_void_set_pin>
    18d8:	80 e0       	ldi	r24, 0x00	; 0
    18da:	90 e0       	ldi	r25, 0x00	; 0
    18dc:	a0 e8       	ldi	r26, 0x80	; 128
    18de:	bf e3       	ldi	r27, 0x3F	; 63
    18e0:	8d 8b       	std	Y+21, r24	; 0x15
    18e2:	9e 8b       	std	Y+22, r25	; 0x16
    18e4:	af 8b       	std	Y+23, r26	; 0x17
    18e6:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    18e8:	6d 89       	ldd	r22, Y+21	; 0x15
    18ea:	7e 89       	ldd	r23, Y+22	; 0x16
    18ec:	8f 89       	ldd	r24, Y+23	; 0x17
    18ee:	98 8d       	ldd	r25, Y+24	; 0x18
    18f0:	2b ea       	ldi	r18, 0xAB	; 171
    18f2:	3a ea       	ldi	r19, 0xAA	; 170
    18f4:	4a e2       	ldi	r20, 0x2A	; 42
    18f6:	50 e4       	ldi	r21, 0x40	; 64
    18f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    18fc:	dc 01       	movw	r26, r24
    18fe:	cb 01       	movw	r24, r22
    1900:	89 8b       	std	Y+17, r24	; 0x11
    1902:	9a 8b       	std	Y+18, r25	; 0x12
    1904:	ab 8b       	std	Y+19, r26	; 0x13
    1906:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    1908:	69 89       	ldd	r22, Y+17	; 0x11
    190a:	7a 89       	ldd	r23, Y+18	; 0x12
    190c:	8b 89       	ldd	r24, Y+19	; 0x13
    190e:	9c 89       	ldd	r25, Y+20	; 0x14
    1910:	20 e0       	ldi	r18, 0x00	; 0
    1912:	30 e0       	ldi	r19, 0x00	; 0
    1914:	40 e8       	ldi	r20, 0x80	; 128
    1916:	5f e3       	ldi	r21, 0x3F	; 63
    1918:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    191c:	88 23       	and	r24, r24
    191e:	1c f4       	brge	.+6      	; 0x1926 <LCD_write_command_8bit+0x1f8>
		__ticks = 1;
    1920:	81 e0       	ldi	r24, 0x01	; 1
    1922:	88 8b       	std	Y+16, r24	; 0x10
    1924:	91 c0       	rjmp	.+290    	; 0x1a48 <LCD_write_command_8bit+0x31a>
	else if (__tmp > 255)
    1926:	69 89       	ldd	r22, Y+17	; 0x11
    1928:	7a 89       	ldd	r23, Y+18	; 0x12
    192a:	8b 89       	ldd	r24, Y+19	; 0x13
    192c:	9c 89       	ldd	r25, Y+20	; 0x14
    192e:	20 e0       	ldi	r18, 0x00	; 0
    1930:	30 e0       	ldi	r19, 0x00	; 0
    1932:	4f e7       	ldi	r20, 0x7F	; 127
    1934:	53 e4       	ldi	r21, 0x43	; 67
    1936:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    193a:	18 16       	cp	r1, r24
    193c:	0c f0       	brlt	.+2      	; 0x1940 <LCD_write_command_8bit+0x212>
    193e:	7b c0       	rjmp	.+246    	; 0x1a36 <LCD_write_command_8bit+0x308>
	{
		_delay_ms(__us / 1000.0);
    1940:	6d 89       	ldd	r22, Y+21	; 0x15
    1942:	7e 89       	ldd	r23, Y+22	; 0x16
    1944:	8f 89       	ldd	r24, Y+23	; 0x17
    1946:	98 8d       	ldd	r25, Y+24	; 0x18
    1948:	20 e0       	ldi	r18, 0x00	; 0
    194a:	30 e0       	ldi	r19, 0x00	; 0
    194c:	4a e7       	ldi	r20, 0x7A	; 122
    194e:	54 e4       	ldi	r21, 0x44	; 68
    1950:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1954:	dc 01       	movw	r26, r24
    1956:	cb 01       	movw	r24, r22
    1958:	8c 87       	std	Y+12, r24	; 0x0c
    195a:	9d 87       	std	Y+13, r25	; 0x0d
    195c:	ae 87       	std	Y+14, r26	; 0x0e
    195e:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1960:	6c 85       	ldd	r22, Y+12	; 0x0c
    1962:	7d 85       	ldd	r23, Y+13	; 0x0d
    1964:	8e 85       	ldd	r24, Y+14	; 0x0e
    1966:	9f 85       	ldd	r25, Y+15	; 0x0f
    1968:	20 e0       	ldi	r18, 0x00	; 0
    196a:	30 e0       	ldi	r19, 0x00	; 0
    196c:	4a ef       	ldi	r20, 0xFA	; 250
    196e:	54 e4       	ldi	r21, 0x44	; 68
    1970:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1974:	dc 01       	movw	r26, r24
    1976:	cb 01       	movw	r24, r22
    1978:	88 87       	std	Y+8, r24	; 0x08
    197a:	99 87       	std	Y+9, r25	; 0x09
    197c:	aa 87       	std	Y+10, r26	; 0x0a
    197e:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    1980:	68 85       	ldd	r22, Y+8	; 0x08
    1982:	79 85       	ldd	r23, Y+9	; 0x09
    1984:	8a 85       	ldd	r24, Y+10	; 0x0a
    1986:	9b 85       	ldd	r25, Y+11	; 0x0b
    1988:	20 e0       	ldi	r18, 0x00	; 0
    198a:	30 e0       	ldi	r19, 0x00	; 0
    198c:	40 e8       	ldi	r20, 0x80	; 128
    198e:	5f e3       	ldi	r21, 0x3F	; 63
    1990:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1994:	88 23       	and	r24, r24
    1996:	2c f4       	brge	.+10     	; 0x19a2 <LCD_write_command_8bit+0x274>
		__ticks = 1;
    1998:	81 e0       	ldi	r24, 0x01	; 1
    199a:	90 e0       	ldi	r25, 0x00	; 0
    199c:	9f 83       	std	Y+7, r25	; 0x07
    199e:	8e 83       	std	Y+6, r24	; 0x06
    19a0:	3f c0       	rjmp	.+126    	; 0x1a20 <LCD_write_command_8bit+0x2f2>
	else if (__tmp > 65535)
    19a2:	68 85       	ldd	r22, Y+8	; 0x08
    19a4:	79 85       	ldd	r23, Y+9	; 0x09
    19a6:	8a 85       	ldd	r24, Y+10	; 0x0a
    19a8:	9b 85       	ldd	r25, Y+11	; 0x0b
    19aa:	20 e0       	ldi	r18, 0x00	; 0
    19ac:	3f ef       	ldi	r19, 0xFF	; 255
    19ae:	4f e7       	ldi	r20, 0x7F	; 127
    19b0:	57 e4       	ldi	r21, 0x47	; 71
    19b2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    19b6:	18 16       	cp	r1, r24
    19b8:	4c f5       	brge	.+82     	; 0x1a0c <LCD_write_command_8bit+0x2de>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    19ba:	6c 85       	ldd	r22, Y+12	; 0x0c
    19bc:	7d 85       	ldd	r23, Y+13	; 0x0d
    19be:	8e 85       	ldd	r24, Y+14	; 0x0e
    19c0:	9f 85       	ldd	r25, Y+15	; 0x0f
    19c2:	20 e0       	ldi	r18, 0x00	; 0
    19c4:	30 e0       	ldi	r19, 0x00	; 0
    19c6:	40 e2       	ldi	r20, 0x20	; 32
    19c8:	51 e4       	ldi	r21, 0x41	; 65
    19ca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    19ce:	dc 01       	movw	r26, r24
    19d0:	cb 01       	movw	r24, r22
    19d2:	bc 01       	movw	r22, r24
    19d4:	cd 01       	movw	r24, r26
    19d6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    19da:	dc 01       	movw	r26, r24
    19dc:	cb 01       	movw	r24, r22
    19de:	9f 83       	std	Y+7, r25	; 0x07
    19e0:	8e 83       	std	Y+6, r24	; 0x06
    19e2:	0f c0       	rjmp	.+30     	; 0x1a02 <LCD_write_command_8bit+0x2d4>
    19e4:	88 ec       	ldi	r24, 0xC8	; 200
    19e6:	90 e0       	ldi	r25, 0x00	; 0
    19e8:	9d 83       	std	Y+5, r25	; 0x05
    19ea:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    19ec:	8c 81       	ldd	r24, Y+4	; 0x04
    19ee:	9d 81       	ldd	r25, Y+5	; 0x05
    19f0:	01 97       	sbiw	r24, 0x01	; 1
    19f2:	f1 f7       	brne	.-4      	; 0x19f0 <LCD_write_command_8bit+0x2c2>
    19f4:	9d 83       	std	Y+5, r25	; 0x05
    19f6:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19f8:	8e 81       	ldd	r24, Y+6	; 0x06
    19fa:	9f 81       	ldd	r25, Y+7	; 0x07
    19fc:	01 97       	sbiw	r24, 0x01	; 1
    19fe:	9f 83       	std	Y+7, r25	; 0x07
    1a00:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1a02:	8e 81       	ldd	r24, Y+6	; 0x06
    1a04:	9f 81       	ldd	r25, Y+7	; 0x07
    1a06:	00 97       	sbiw	r24, 0x00	; 0
    1a08:	69 f7       	brne	.-38     	; 0x19e4 <LCD_write_command_8bit+0x2b6>
    1a0a:	24 c0       	rjmp	.+72     	; 0x1a54 <LCD_write_command_8bit+0x326>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1a0c:	68 85       	ldd	r22, Y+8	; 0x08
    1a0e:	79 85       	ldd	r23, Y+9	; 0x09
    1a10:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a12:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a14:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a18:	dc 01       	movw	r26, r24
    1a1a:	cb 01       	movw	r24, r22
    1a1c:	9f 83       	std	Y+7, r25	; 0x07
    1a1e:	8e 83       	std	Y+6, r24	; 0x06
    1a20:	8e 81       	ldd	r24, Y+6	; 0x06
    1a22:	9f 81       	ldd	r25, Y+7	; 0x07
    1a24:	9b 83       	std	Y+3, r25	; 0x03
    1a26:	8a 83       	std	Y+2, r24	; 0x02
    1a28:	8a 81       	ldd	r24, Y+2	; 0x02
    1a2a:	9b 81       	ldd	r25, Y+3	; 0x03
    1a2c:	01 97       	sbiw	r24, 0x01	; 1
    1a2e:	f1 f7       	brne	.-4      	; 0x1a2c <LCD_write_command_8bit+0x2fe>
    1a30:	9b 83       	std	Y+3, r25	; 0x03
    1a32:	8a 83       	std	Y+2, r24	; 0x02
    1a34:	0f c0       	rjmp	.+30     	; 0x1a54 <LCD_write_command_8bit+0x326>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1a36:	69 89       	ldd	r22, Y+17	; 0x11
    1a38:	7a 89       	ldd	r23, Y+18	; 0x12
    1a3a:	8b 89       	ldd	r24, Y+19	; 0x13
    1a3c:	9c 89       	ldd	r25, Y+20	; 0x14
    1a3e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1a42:	dc 01       	movw	r26, r24
    1a44:	cb 01       	movw	r24, r22
    1a46:	88 8b       	std	Y+16, r24	; 0x10
    1a48:	88 89       	ldd	r24, Y+16	; 0x10
    1a4a:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1a4c:	89 81       	ldd	r24, Y+1	; 0x01
    1a4e:	8a 95       	dec	r24
    1a50:	f1 f7       	brne	.-4      	; 0x1a4e <LCD_write_command_8bit+0x320>
    1a52:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1);
	//send command to the entire port
	DIO_void_assign_port(lcd_data_port, copy_command_8bit);
    1a54:	82 e0       	ldi	r24, 0x02	; 2
    1a56:	69 a9       	ldd	r22, Y+49	; 0x31
    1a58:	0e 94 15 08 	call	0x102a	; 0x102a <DIO_void_assign_port>
	//enable pin low
	DIO_void_clear_pin(lcd_control_port, lcd_enable);
    1a5c:	83 e0       	ldi	r24, 0x03	; 3
    1a5e:	60 e0       	ldi	r22, 0x00	; 0
    1a60:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>

}
    1a64:	e1 96       	adiw	r28, 0x31	; 49
    1a66:	0f b6       	in	r0, 0x3f	; 63
    1a68:	f8 94       	cli
    1a6a:	de bf       	out	0x3e, r29	; 62
    1a6c:	0f be       	out	0x3f, r0	; 63
    1a6e:	cd bf       	out	0x3d, r28	; 61
    1a70:	cf 91       	pop	r28
    1a72:	df 91       	pop	r29
    1a74:	08 95       	ret

00001a76 <LCD_write_data_4bit>:


/* 4bit mode functions */

static void LCD_write_data_4bit(u8 copy_data_4bit){
    1a76:	0f 93       	push	r16
    1a78:	1f 93       	push	r17
    1a7a:	df 93       	push	r29
    1a7c:	cf 93       	push	r28
    1a7e:	cd b7       	in	r28, 0x3d	; 61
    1a80:	de b7       	in	r29, 0x3e	; 62
    1a82:	c3 56       	subi	r28, 0x63	; 99
    1a84:	d0 40       	sbci	r29, 0x00	; 0
    1a86:	0f b6       	in	r0, 0x3f	; 63
    1a88:	f8 94       	cli
    1a8a:	de bf       	out	0x3e, r29	; 62
    1a8c:	0f be       	out	0x3f, r0	; 63
    1a8e:	cd bf       	out	0x3d, r28	; 61
    1a90:	fe 01       	movw	r30, r28
    1a92:	ed 59       	subi	r30, 0x9D	; 157
    1a94:	ff 4f       	sbci	r31, 0xFF	; 255
    1a96:	80 83       	st	Z, r24
		 *  function will only be used inside this source file
		 *  do you not use it in your code!
		 *
		 */

	DIO_void_set_pin(lcd_control_port, lcd_RS); // set RS pin high select data register
    1a98:	83 e0       	ldi	r24, 0x03	; 3
    1a9a:	62 e0       	ldi	r22, 0x02	; 2
    1a9c:	0e 94 50 08 	call	0x10a0	; 0x10a0 <DIO_void_set_pin>
	DIO_void_clear_pin(lcd_control_port, lcd_RW); // clear RW pin  0 for writing operation
    1aa0:	83 e0       	ldi	r24, 0x03	; 3
    1aa2:	61 e0       	ldi	r22, 0x01	; 1
    1aa4:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>
    1aa8:	fe 01       	movw	r30, r28
    1aaa:	e3 5a       	subi	r30, 0xA3	; 163
    1aac:	ff 4f       	sbci	r31, 0xFF	; 255
    1aae:	80 e0       	ldi	r24, 0x00	; 0
    1ab0:	90 e0       	ldi	r25, 0x00	; 0
    1ab2:	a0 e8       	ldi	r26, 0x80	; 128
    1ab4:	bf e3       	ldi	r27, 0x3F	; 63
    1ab6:	80 83       	st	Z, r24
    1ab8:	91 83       	std	Z+1, r25	; 0x01
    1aba:	a2 83       	std	Z+2, r26	; 0x02
    1abc:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1abe:	8e 01       	movw	r16, r28
    1ac0:	07 5a       	subi	r16, 0xA7	; 167
    1ac2:	1f 4f       	sbci	r17, 0xFF	; 255
    1ac4:	fe 01       	movw	r30, r28
    1ac6:	e3 5a       	subi	r30, 0xA3	; 163
    1ac8:	ff 4f       	sbci	r31, 0xFF	; 255
    1aca:	60 81       	ld	r22, Z
    1acc:	71 81       	ldd	r23, Z+1	; 0x01
    1ace:	82 81       	ldd	r24, Z+2	; 0x02
    1ad0:	93 81       	ldd	r25, Z+3	; 0x03
    1ad2:	2b ea       	ldi	r18, 0xAB	; 171
    1ad4:	3a ea       	ldi	r19, 0xAA	; 170
    1ad6:	4a e2       	ldi	r20, 0x2A	; 42
    1ad8:	50 e4       	ldi	r21, 0x40	; 64
    1ada:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1ade:	dc 01       	movw	r26, r24
    1ae0:	cb 01       	movw	r24, r22
    1ae2:	f8 01       	movw	r30, r16
    1ae4:	80 83       	st	Z, r24
    1ae6:	91 83       	std	Z+1, r25	; 0x01
    1ae8:	a2 83       	std	Z+2, r26	; 0x02
    1aea:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1aec:	fe 01       	movw	r30, r28
    1aee:	e7 5a       	subi	r30, 0xA7	; 167
    1af0:	ff 4f       	sbci	r31, 0xFF	; 255
    1af2:	60 81       	ld	r22, Z
    1af4:	71 81       	ldd	r23, Z+1	; 0x01
    1af6:	82 81       	ldd	r24, Z+2	; 0x02
    1af8:	93 81       	ldd	r25, Z+3	; 0x03
    1afa:	20 e0       	ldi	r18, 0x00	; 0
    1afc:	30 e0       	ldi	r19, 0x00	; 0
    1afe:	40 e8       	ldi	r20, 0x80	; 128
    1b00:	5f e3       	ldi	r21, 0x3F	; 63
    1b02:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1b06:	88 23       	and	r24, r24
    1b08:	34 f4       	brge	.+12     	; 0x1b16 <LCD_write_data_4bit+0xa0>
		__ticks = 1;
    1b0a:	fe 01       	movw	r30, r28
    1b0c:	e8 5a       	subi	r30, 0xA8	; 168
    1b0e:	ff 4f       	sbci	r31, 0xFF	; 255
    1b10:	81 e0       	ldi	r24, 0x01	; 1
    1b12:	80 83       	st	Z, r24
    1b14:	e0 c0       	rjmp	.+448    	; 0x1cd6 <LCD_write_data_4bit+0x260>
	else if (__tmp > 255)
    1b16:	fe 01       	movw	r30, r28
    1b18:	e7 5a       	subi	r30, 0xA7	; 167
    1b1a:	ff 4f       	sbci	r31, 0xFF	; 255
    1b1c:	60 81       	ld	r22, Z
    1b1e:	71 81       	ldd	r23, Z+1	; 0x01
    1b20:	82 81       	ldd	r24, Z+2	; 0x02
    1b22:	93 81       	ldd	r25, Z+3	; 0x03
    1b24:	20 e0       	ldi	r18, 0x00	; 0
    1b26:	30 e0       	ldi	r19, 0x00	; 0
    1b28:	4f e7       	ldi	r20, 0x7F	; 127
    1b2a:	53 e4       	ldi	r21, 0x43	; 67
    1b2c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1b30:	18 16       	cp	r1, r24
    1b32:	0c f0       	brlt	.+2      	; 0x1b36 <LCD_write_data_4bit+0xc0>
    1b34:	c0 c0       	rjmp	.+384    	; 0x1cb6 <LCD_write_data_4bit+0x240>
	{
		_delay_ms(__us / 1000.0);
    1b36:	fe 01       	movw	r30, r28
    1b38:	e3 5a       	subi	r30, 0xA3	; 163
    1b3a:	ff 4f       	sbci	r31, 0xFF	; 255
    1b3c:	60 81       	ld	r22, Z
    1b3e:	71 81       	ldd	r23, Z+1	; 0x01
    1b40:	82 81       	ldd	r24, Z+2	; 0x02
    1b42:	93 81       	ldd	r25, Z+3	; 0x03
    1b44:	20 e0       	ldi	r18, 0x00	; 0
    1b46:	30 e0       	ldi	r19, 0x00	; 0
    1b48:	4a e7       	ldi	r20, 0x7A	; 122
    1b4a:	54 e4       	ldi	r21, 0x44	; 68
    1b4c:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1b50:	dc 01       	movw	r26, r24
    1b52:	cb 01       	movw	r24, r22
    1b54:	fe 01       	movw	r30, r28
    1b56:	ec 5a       	subi	r30, 0xAC	; 172
    1b58:	ff 4f       	sbci	r31, 0xFF	; 255
    1b5a:	80 83       	st	Z, r24
    1b5c:	91 83       	std	Z+1, r25	; 0x01
    1b5e:	a2 83       	std	Z+2, r26	; 0x02
    1b60:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1b62:	8e 01       	movw	r16, r28
    1b64:	00 5b       	subi	r16, 0xB0	; 176
    1b66:	1f 4f       	sbci	r17, 0xFF	; 255
    1b68:	fe 01       	movw	r30, r28
    1b6a:	ec 5a       	subi	r30, 0xAC	; 172
    1b6c:	ff 4f       	sbci	r31, 0xFF	; 255
    1b6e:	60 81       	ld	r22, Z
    1b70:	71 81       	ldd	r23, Z+1	; 0x01
    1b72:	82 81       	ldd	r24, Z+2	; 0x02
    1b74:	93 81       	ldd	r25, Z+3	; 0x03
    1b76:	20 e0       	ldi	r18, 0x00	; 0
    1b78:	30 e0       	ldi	r19, 0x00	; 0
    1b7a:	4a ef       	ldi	r20, 0xFA	; 250
    1b7c:	54 e4       	ldi	r21, 0x44	; 68
    1b7e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b82:	dc 01       	movw	r26, r24
    1b84:	cb 01       	movw	r24, r22
    1b86:	f8 01       	movw	r30, r16
    1b88:	80 83       	st	Z, r24
    1b8a:	91 83       	std	Z+1, r25	; 0x01
    1b8c:	a2 83       	std	Z+2, r26	; 0x02
    1b8e:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1b90:	fe 01       	movw	r30, r28
    1b92:	e0 5b       	subi	r30, 0xB0	; 176
    1b94:	ff 4f       	sbci	r31, 0xFF	; 255
    1b96:	60 81       	ld	r22, Z
    1b98:	71 81       	ldd	r23, Z+1	; 0x01
    1b9a:	82 81       	ldd	r24, Z+2	; 0x02
    1b9c:	93 81       	ldd	r25, Z+3	; 0x03
    1b9e:	20 e0       	ldi	r18, 0x00	; 0
    1ba0:	30 e0       	ldi	r19, 0x00	; 0
    1ba2:	40 e8       	ldi	r20, 0x80	; 128
    1ba4:	5f e3       	ldi	r21, 0x3F	; 63
    1ba6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1baa:	88 23       	and	r24, r24
    1bac:	44 f4       	brge	.+16     	; 0x1bbe <LCD_write_data_4bit+0x148>
		__ticks = 1;
    1bae:	fe 01       	movw	r30, r28
    1bb0:	e2 5b       	subi	r30, 0xB2	; 178
    1bb2:	ff 4f       	sbci	r31, 0xFF	; 255
    1bb4:	81 e0       	ldi	r24, 0x01	; 1
    1bb6:	90 e0       	ldi	r25, 0x00	; 0
    1bb8:	91 83       	std	Z+1, r25	; 0x01
    1bba:	80 83       	st	Z, r24
    1bbc:	64 c0       	rjmp	.+200    	; 0x1c86 <LCD_write_data_4bit+0x210>
	else if (__tmp > 65535)
    1bbe:	fe 01       	movw	r30, r28
    1bc0:	e0 5b       	subi	r30, 0xB0	; 176
    1bc2:	ff 4f       	sbci	r31, 0xFF	; 255
    1bc4:	60 81       	ld	r22, Z
    1bc6:	71 81       	ldd	r23, Z+1	; 0x01
    1bc8:	82 81       	ldd	r24, Z+2	; 0x02
    1bca:	93 81       	ldd	r25, Z+3	; 0x03
    1bcc:	20 e0       	ldi	r18, 0x00	; 0
    1bce:	3f ef       	ldi	r19, 0xFF	; 255
    1bd0:	4f e7       	ldi	r20, 0x7F	; 127
    1bd2:	57 e4       	ldi	r21, 0x47	; 71
    1bd4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1bd8:	18 16       	cp	r1, r24
    1bda:	0c f0       	brlt	.+2      	; 0x1bde <LCD_write_data_4bit+0x168>
    1bdc:	43 c0       	rjmp	.+134    	; 0x1c64 <LCD_write_data_4bit+0x1ee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1bde:	fe 01       	movw	r30, r28
    1be0:	ec 5a       	subi	r30, 0xAC	; 172
    1be2:	ff 4f       	sbci	r31, 0xFF	; 255
    1be4:	60 81       	ld	r22, Z
    1be6:	71 81       	ldd	r23, Z+1	; 0x01
    1be8:	82 81       	ldd	r24, Z+2	; 0x02
    1bea:	93 81       	ldd	r25, Z+3	; 0x03
    1bec:	20 e0       	ldi	r18, 0x00	; 0
    1bee:	30 e0       	ldi	r19, 0x00	; 0
    1bf0:	40 e2       	ldi	r20, 0x20	; 32
    1bf2:	51 e4       	ldi	r21, 0x41	; 65
    1bf4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1bf8:	dc 01       	movw	r26, r24
    1bfa:	cb 01       	movw	r24, r22
    1bfc:	8e 01       	movw	r16, r28
    1bfe:	02 5b       	subi	r16, 0xB2	; 178
    1c00:	1f 4f       	sbci	r17, 0xFF	; 255
    1c02:	bc 01       	movw	r22, r24
    1c04:	cd 01       	movw	r24, r26
    1c06:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c0a:	dc 01       	movw	r26, r24
    1c0c:	cb 01       	movw	r24, r22
    1c0e:	f8 01       	movw	r30, r16
    1c10:	91 83       	std	Z+1, r25	; 0x01
    1c12:	80 83       	st	Z, r24
    1c14:	1f c0       	rjmp	.+62     	; 0x1c54 <LCD_write_data_4bit+0x1de>
    1c16:	fe 01       	movw	r30, r28
    1c18:	e4 5b       	subi	r30, 0xB4	; 180
    1c1a:	ff 4f       	sbci	r31, 0xFF	; 255
    1c1c:	88 ec       	ldi	r24, 0xC8	; 200
    1c1e:	90 e0       	ldi	r25, 0x00	; 0
    1c20:	91 83       	std	Z+1, r25	; 0x01
    1c22:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1c24:	fe 01       	movw	r30, r28
    1c26:	e4 5b       	subi	r30, 0xB4	; 180
    1c28:	ff 4f       	sbci	r31, 0xFF	; 255
    1c2a:	80 81       	ld	r24, Z
    1c2c:	91 81       	ldd	r25, Z+1	; 0x01
    1c2e:	01 97       	sbiw	r24, 0x01	; 1
    1c30:	f1 f7       	brne	.-4      	; 0x1c2e <LCD_write_data_4bit+0x1b8>
    1c32:	fe 01       	movw	r30, r28
    1c34:	e4 5b       	subi	r30, 0xB4	; 180
    1c36:	ff 4f       	sbci	r31, 0xFF	; 255
    1c38:	91 83       	std	Z+1, r25	; 0x01
    1c3a:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c3c:	de 01       	movw	r26, r28
    1c3e:	a2 5b       	subi	r26, 0xB2	; 178
    1c40:	bf 4f       	sbci	r27, 0xFF	; 255
    1c42:	fe 01       	movw	r30, r28
    1c44:	e2 5b       	subi	r30, 0xB2	; 178
    1c46:	ff 4f       	sbci	r31, 0xFF	; 255
    1c48:	80 81       	ld	r24, Z
    1c4a:	91 81       	ldd	r25, Z+1	; 0x01
    1c4c:	01 97       	sbiw	r24, 0x01	; 1
    1c4e:	11 96       	adiw	r26, 0x01	; 1
    1c50:	9c 93       	st	X, r25
    1c52:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1c54:	fe 01       	movw	r30, r28
    1c56:	e2 5b       	subi	r30, 0xB2	; 178
    1c58:	ff 4f       	sbci	r31, 0xFF	; 255
    1c5a:	80 81       	ld	r24, Z
    1c5c:	91 81       	ldd	r25, Z+1	; 0x01
    1c5e:	00 97       	sbiw	r24, 0x00	; 0
    1c60:	d1 f6       	brne	.-76     	; 0x1c16 <LCD_write_data_4bit+0x1a0>
    1c62:	4b c0       	rjmp	.+150    	; 0x1cfa <LCD_write_data_4bit+0x284>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1c64:	8e 01       	movw	r16, r28
    1c66:	02 5b       	subi	r16, 0xB2	; 178
    1c68:	1f 4f       	sbci	r17, 0xFF	; 255
    1c6a:	fe 01       	movw	r30, r28
    1c6c:	e0 5b       	subi	r30, 0xB0	; 176
    1c6e:	ff 4f       	sbci	r31, 0xFF	; 255
    1c70:	60 81       	ld	r22, Z
    1c72:	71 81       	ldd	r23, Z+1	; 0x01
    1c74:	82 81       	ldd	r24, Z+2	; 0x02
    1c76:	93 81       	ldd	r25, Z+3	; 0x03
    1c78:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1c7c:	dc 01       	movw	r26, r24
    1c7e:	cb 01       	movw	r24, r22
    1c80:	f8 01       	movw	r30, r16
    1c82:	91 83       	std	Z+1, r25	; 0x01
    1c84:	80 83       	st	Z, r24
    1c86:	de 01       	movw	r26, r28
    1c88:	a6 5b       	subi	r26, 0xB6	; 182
    1c8a:	bf 4f       	sbci	r27, 0xFF	; 255
    1c8c:	fe 01       	movw	r30, r28
    1c8e:	e2 5b       	subi	r30, 0xB2	; 178
    1c90:	ff 4f       	sbci	r31, 0xFF	; 255
    1c92:	80 81       	ld	r24, Z
    1c94:	91 81       	ldd	r25, Z+1	; 0x01
    1c96:	11 96       	adiw	r26, 0x01	; 1
    1c98:	9c 93       	st	X, r25
    1c9a:	8e 93       	st	-X, r24
    1c9c:	fe 01       	movw	r30, r28
    1c9e:	e6 5b       	subi	r30, 0xB6	; 182
    1ca0:	ff 4f       	sbci	r31, 0xFF	; 255
    1ca2:	80 81       	ld	r24, Z
    1ca4:	91 81       	ldd	r25, Z+1	; 0x01
    1ca6:	01 97       	sbiw	r24, 0x01	; 1
    1ca8:	f1 f7       	brne	.-4      	; 0x1ca6 <LCD_write_data_4bit+0x230>
    1caa:	fe 01       	movw	r30, r28
    1cac:	e6 5b       	subi	r30, 0xB6	; 182
    1cae:	ff 4f       	sbci	r31, 0xFF	; 255
    1cb0:	91 83       	std	Z+1, r25	; 0x01
    1cb2:	80 83       	st	Z, r24
    1cb4:	22 c0       	rjmp	.+68     	; 0x1cfa <LCD_write_data_4bit+0x284>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1cb6:	8e 01       	movw	r16, r28
    1cb8:	08 5a       	subi	r16, 0xA8	; 168
    1cba:	1f 4f       	sbci	r17, 0xFF	; 255
    1cbc:	fe 01       	movw	r30, r28
    1cbe:	e7 5a       	subi	r30, 0xA7	; 167
    1cc0:	ff 4f       	sbci	r31, 0xFF	; 255
    1cc2:	60 81       	ld	r22, Z
    1cc4:	71 81       	ldd	r23, Z+1	; 0x01
    1cc6:	82 81       	ldd	r24, Z+2	; 0x02
    1cc8:	93 81       	ldd	r25, Z+3	; 0x03
    1cca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1cce:	dc 01       	movw	r26, r24
    1cd0:	cb 01       	movw	r24, r22
    1cd2:	f8 01       	movw	r30, r16
    1cd4:	80 83       	st	Z, r24
    1cd6:	de 01       	movw	r26, r28
    1cd8:	a7 5b       	subi	r26, 0xB7	; 183
    1cda:	bf 4f       	sbci	r27, 0xFF	; 255
    1cdc:	fe 01       	movw	r30, r28
    1cde:	e8 5a       	subi	r30, 0xA8	; 168
    1ce0:	ff 4f       	sbci	r31, 0xFF	; 255
    1ce2:	80 81       	ld	r24, Z
    1ce4:	8c 93       	st	X, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1ce6:	fe 01       	movw	r30, r28
    1ce8:	e7 5b       	subi	r30, 0xB7	; 183
    1cea:	ff 4f       	sbci	r31, 0xFF	; 255
    1cec:	80 81       	ld	r24, Z
    1cee:	8a 95       	dec	r24
    1cf0:	f1 f7       	brne	.-4      	; 0x1cee <LCD_write_data_4bit+0x278>
    1cf2:	fe 01       	movw	r30, r28
    1cf4:	e7 5b       	subi	r30, 0xB7	; 183
    1cf6:	ff 4f       	sbci	r31, 0xFF	; 255
    1cf8:	80 83       	st	Z, r24

	_delay_us(1);
	//enable pin high
	DIO_void_set_pin(lcd_control_port, lcd_enable);
    1cfa:	83 e0       	ldi	r24, 0x03	; 3
    1cfc:	60 e0       	ldi	r22, 0x00	; 0
    1cfe:	0e 94 50 08 	call	0x10a0	; 0x10a0 <DIO_void_set_pin>
    1d02:	fe 01       	movw	r30, r28
    1d04:	eb 5b       	subi	r30, 0xBB	; 187
    1d06:	ff 4f       	sbci	r31, 0xFF	; 255
    1d08:	80 e0       	ldi	r24, 0x00	; 0
    1d0a:	90 e0       	ldi	r25, 0x00	; 0
    1d0c:	a0 e8       	ldi	r26, 0x80	; 128
    1d0e:	bf e3       	ldi	r27, 0x3F	; 63
    1d10:	80 83       	st	Z, r24
    1d12:	91 83       	std	Z+1, r25	; 0x01
    1d14:	a2 83       	std	Z+2, r26	; 0x02
    1d16:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1d18:	8e 01       	movw	r16, r28
    1d1a:	0f 5b       	subi	r16, 0xBF	; 191
    1d1c:	1f 4f       	sbci	r17, 0xFF	; 255
    1d1e:	fe 01       	movw	r30, r28
    1d20:	eb 5b       	subi	r30, 0xBB	; 187
    1d22:	ff 4f       	sbci	r31, 0xFF	; 255
    1d24:	60 81       	ld	r22, Z
    1d26:	71 81       	ldd	r23, Z+1	; 0x01
    1d28:	82 81       	ldd	r24, Z+2	; 0x02
    1d2a:	93 81       	ldd	r25, Z+3	; 0x03
    1d2c:	2b ea       	ldi	r18, 0xAB	; 171
    1d2e:	3a ea       	ldi	r19, 0xAA	; 170
    1d30:	4a e2       	ldi	r20, 0x2A	; 42
    1d32:	50 e4       	ldi	r21, 0x40	; 64
    1d34:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1d38:	dc 01       	movw	r26, r24
    1d3a:	cb 01       	movw	r24, r22
    1d3c:	f8 01       	movw	r30, r16
    1d3e:	80 83       	st	Z, r24
    1d40:	91 83       	std	Z+1, r25	; 0x01
    1d42:	a2 83       	std	Z+2, r26	; 0x02
    1d44:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1d46:	fe 01       	movw	r30, r28
    1d48:	ef 5b       	subi	r30, 0xBF	; 191
    1d4a:	ff 4f       	sbci	r31, 0xFF	; 255
    1d4c:	60 81       	ld	r22, Z
    1d4e:	71 81       	ldd	r23, Z+1	; 0x01
    1d50:	82 81       	ldd	r24, Z+2	; 0x02
    1d52:	93 81       	ldd	r25, Z+3	; 0x03
    1d54:	20 e0       	ldi	r18, 0x00	; 0
    1d56:	30 e0       	ldi	r19, 0x00	; 0
    1d58:	40 e8       	ldi	r20, 0x80	; 128
    1d5a:	5f e3       	ldi	r21, 0x3F	; 63
    1d5c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1d60:	88 23       	and	r24, r24
    1d62:	34 f4       	brge	.+12     	; 0x1d70 <LCD_write_data_4bit+0x2fa>
		__ticks = 1;
    1d64:	81 e0       	ldi	r24, 0x01	; 1
    1d66:	fe 01       	movw	r30, r28
    1d68:	e0 5c       	subi	r30, 0xC0	; 192
    1d6a:	ff 4f       	sbci	r31, 0xFF	; 255
    1d6c:	80 83       	st	Z, r24
    1d6e:	9d c0       	rjmp	.+314    	; 0x1eaa <LCD_write_data_4bit+0x434>
	else if (__tmp > 255)
    1d70:	fe 01       	movw	r30, r28
    1d72:	ef 5b       	subi	r30, 0xBF	; 191
    1d74:	ff 4f       	sbci	r31, 0xFF	; 255
    1d76:	60 81       	ld	r22, Z
    1d78:	71 81       	ldd	r23, Z+1	; 0x01
    1d7a:	82 81       	ldd	r24, Z+2	; 0x02
    1d7c:	93 81       	ldd	r25, Z+3	; 0x03
    1d7e:	20 e0       	ldi	r18, 0x00	; 0
    1d80:	30 e0       	ldi	r19, 0x00	; 0
    1d82:	4f e7       	ldi	r20, 0x7F	; 127
    1d84:	53 e4       	ldi	r21, 0x43	; 67
    1d86:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1d8a:	18 16       	cp	r1, r24
    1d8c:	0c f0       	brlt	.+2      	; 0x1d90 <LCD_write_data_4bit+0x31a>
    1d8e:	7e c0       	rjmp	.+252    	; 0x1e8c <LCD_write_data_4bit+0x416>
	{
		_delay_ms(__us / 1000.0);
    1d90:	fe 01       	movw	r30, r28
    1d92:	eb 5b       	subi	r30, 0xBB	; 187
    1d94:	ff 4f       	sbci	r31, 0xFF	; 255
    1d96:	60 81       	ld	r22, Z
    1d98:	71 81       	ldd	r23, Z+1	; 0x01
    1d9a:	82 81       	ldd	r24, Z+2	; 0x02
    1d9c:	93 81       	ldd	r25, Z+3	; 0x03
    1d9e:	20 e0       	ldi	r18, 0x00	; 0
    1da0:	30 e0       	ldi	r19, 0x00	; 0
    1da2:	4a e7       	ldi	r20, 0x7A	; 122
    1da4:	54 e4       	ldi	r21, 0x44	; 68
    1da6:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1daa:	dc 01       	movw	r26, r24
    1dac:	cb 01       	movw	r24, r22
    1dae:	8c af       	std	Y+60, r24	; 0x3c
    1db0:	9d af       	std	Y+61, r25	; 0x3d
    1db2:	ae af       	std	Y+62, r26	; 0x3e
    1db4:	bf af       	std	Y+63, r27	; 0x3f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1db6:	6c ad       	ldd	r22, Y+60	; 0x3c
    1db8:	7d ad       	ldd	r23, Y+61	; 0x3d
    1dba:	8e ad       	ldd	r24, Y+62	; 0x3e
    1dbc:	9f ad       	ldd	r25, Y+63	; 0x3f
    1dbe:	20 e0       	ldi	r18, 0x00	; 0
    1dc0:	30 e0       	ldi	r19, 0x00	; 0
    1dc2:	4a ef       	ldi	r20, 0xFA	; 250
    1dc4:	54 e4       	ldi	r21, 0x44	; 68
    1dc6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1dca:	dc 01       	movw	r26, r24
    1dcc:	cb 01       	movw	r24, r22
    1dce:	88 af       	std	Y+56, r24	; 0x38
    1dd0:	99 af       	std	Y+57, r25	; 0x39
    1dd2:	aa af       	std	Y+58, r26	; 0x3a
    1dd4:	bb af       	std	Y+59, r27	; 0x3b
	if (__tmp < 1.0)
    1dd6:	68 ad       	ldd	r22, Y+56	; 0x38
    1dd8:	79 ad       	ldd	r23, Y+57	; 0x39
    1dda:	8a ad       	ldd	r24, Y+58	; 0x3a
    1ddc:	9b ad       	ldd	r25, Y+59	; 0x3b
    1dde:	20 e0       	ldi	r18, 0x00	; 0
    1de0:	30 e0       	ldi	r19, 0x00	; 0
    1de2:	40 e8       	ldi	r20, 0x80	; 128
    1de4:	5f e3       	ldi	r21, 0x3F	; 63
    1de6:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1dea:	88 23       	and	r24, r24
    1dec:	2c f4       	brge	.+10     	; 0x1df8 <LCD_write_data_4bit+0x382>
		__ticks = 1;
    1dee:	81 e0       	ldi	r24, 0x01	; 1
    1df0:	90 e0       	ldi	r25, 0x00	; 0
    1df2:	9f ab       	std	Y+55, r25	; 0x37
    1df4:	8e ab       	std	Y+54, r24	; 0x36
    1df6:	3f c0       	rjmp	.+126    	; 0x1e76 <LCD_write_data_4bit+0x400>
	else if (__tmp > 65535)
    1df8:	68 ad       	ldd	r22, Y+56	; 0x38
    1dfa:	79 ad       	ldd	r23, Y+57	; 0x39
    1dfc:	8a ad       	ldd	r24, Y+58	; 0x3a
    1dfe:	9b ad       	ldd	r25, Y+59	; 0x3b
    1e00:	20 e0       	ldi	r18, 0x00	; 0
    1e02:	3f ef       	ldi	r19, 0xFF	; 255
    1e04:	4f e7       	ldi	r20, 0x7F	; 127
    1e06:	57 e4       	ldi	r21, 0x47	; 71
    1e08:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1e0c:	18 16       	cp	r1, r24
    1e0e:	4c f5       	brge	.+82     	; 0x1e62 <LCD_write_data_4bit+0x3ec>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1e10:	6c ad       	ldd	r22, Y+60	; 0x3c
    1e12:	7d ad       	ldd	r23, Y+61	; 0x3d
    1e14:	8e ad       	ldd	r24, Y+62	; 0x3e
    1e16:	9f ad       	ldd	r25, Y+63	; 0x3f
    1e18:	20 e0       	ldi	r18, 0x00	; 0
    1e1a:	30 e0       	ldi	r19, 0x00	; 0
    1e1c:	40 e2       	ldi	r20, 0x20	; 32
    1e1e:	51 e4       	ldi	r21, 0x41	; 65
    1e20:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e24:	dc 01       	movw	r26, r24
    1e26:	cb 01       	movw	r24, r22
    1e28:	bc 01       	movw	r22, r24
    1e2a:	cd 01       	movw	r24, r26
    1e2c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e30:	dc 01       	movw	r26, r24
    1e32:	cb 01       	movw	r24, r22
    1e34:	9f ab       	std	Y+55, r25	; 0x37
    1e36:	8e ab       	std	Y+54, r24	; 0x36
    1e38:	0f c0       	rjmp	.+30     	; 0x1e58 <LCD_write_data_4bit+0x3e2>
    1e3a:	88 ec       	ldi	r24, 0xC8	; 200
    1e3c:	90 e0       	ldi	r25, 0x00	; 0
    1e3e:	9d ab       	std	Y+53, r25	; 0x35
    1e40:	8c ab       	std	Y+52, r24	; 0x34
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1e42:	8c a9       	ldd	r24, Y+52	; 0x34
    1e44:	9d a9       	ldd	r25, Y+53	; 0x35
    1e46:	01 97       	sbiw	r24, 0x01	; 1
    1e48:	f1 f7       	brne	.-4      	; 0x1e46 <LCD_write_data_4bit+0x3d0>
    1e4a:	9d ab       	std	Y+53, r25	; 0x35
    1e4c:	8c ab       	std	Y+52, r24	; 0x34
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e4e:	8e a9       	ldd	r24, Y+54	; 0x36
    1e50:	9f a9       	ldd	r25, Y+55	; 0x37
    1e52:	01 97       	sbiw	r24, 0x01	; 1
    1e54:	9f ab       	std	Y+55, r25	; 0x37
    1e56:	8e ab       	std	Y+54, r24	; 0x36
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e58:	8e a9       	ldd	r24, Y+54	; 0x36
    1e5a:	9f a9       	ldd	r25, Y+55	; 0x37
    1e5c:	00 97       	sbiw	r24, 0x00	; 0
    1e5e:	69 f7       	brne	.-38     	; 0x1e3a <LCD_write_data_4bit+0x3c4>
    1e60:	2d c0       	rjmp	.+90     	; 0x1ebc <LCD_write_data_4bit+0x446>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e62:	68 ad       	ldd	r22, Y+56	; 0x38
    1e64:	79 ad       	ldd	r23, Y+57	; 0x39
    1e66:	8a ad       	ldd	r24, Y+58	; 0x3a
    1e68:	9b ad       	ldd	r25, Y+59	; 0x3b
    1e6a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e6e:	dc 01       	movw	r26, r24
    1e70:	cb 01       	movw	r24, r22
    1e72:	9f ab       	std	Y+55, r25	; 0x37
    1e74:	8e ab       	std	Y+54, r24	; 0x36
    1e76:	8e a9       	ldd	r24, Y+54	; 0x36
    1e78:	9f a9       	ldd	r25, Y+55	; 0x37
    1e7a:	9b ab       	std	Y+51, r25	; 0x33
    1e7c:	8a ab       	std	Y+50, r24	; 0x32
    1e7e:	8a a9       	ldd	r24, Y+50	; 0x32
    1e80:	9b a9       	ldd	r25, Y+51	; 0x33
    1e82:	01 97       	sbiw	r24, 0x01	; 1
    1e84:	f1 f7       	brne	.-4      	; 0x1e82 <LCD_write_data_4bit+0x40c>
    1e86:	9b ab       	std	Y+51, r25	; 0x33
    1e88:	8a ab       	std	Y+50, r24	; 0x32
    1e8a:	18 c0       	rjmp	.+48     	; 0x1ebc <LCD_write_data_4bit+0x446>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1e8c:	fe 01       	movw	r30, r28
    1e8e:	ef 5b       	subi	r30, 0xBF	; 191
    1e90:	ff 4f       	sbci	r31, 0xFF	; 255
    1e92:	60 81       	ld	r22, Z
    1e94:	71 81       	ldd	r23, Z+1	; 0x01
    1e96:	82 81       	ldd	r24, Z+2	; 0x02
    1e98:	93 81       	ldd	r25, Z+3	; 0x03
    1e9a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e9e:	dc 01       	movw	r26, r24
    1ea0:	cb 01       	movw	r24, r22
    1ea2:	fe 01       	movw	r30, r28
    1ea4:	e0 5c       	subi	r30, 0xC0	; 192
    1ea6:	ff 4f       	sbci	r31, 0xFF	; 255
    1ea8:	80 83       	st	Z, r24
    1eaa:	fe 01       	movw	r30, r28
    1eac:	e0 5c       	subi	r30, 0xC0	; 192
    1eae:	ff 4f       	sbci	r31, 0xFF	; 255
    1eb0:	80 81       	ld	r24, Z
    1eb2:	89 ab       	std	Y+49, r24	; 0x31
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1eb4:	89 a9       	ldd	r24, Y+49	; 0x31
    1eb6:	8a 95       	dec	r24
    1eb8:	f1 f7       	brne	.-4      	; 0x1eb6 <LCD_write_data_4bit+0x440>
    1eba:	89 ab       	std	Y+49, r24	; 0x31
	 *  any change in this sequence will result in a wrong behavior
	 *  i will try to make it more generic in the next versions
	 *
	 */

	for(u8 i = 4; i < 8; i++){
    1ebc:	fe 01       	movw	r30, r28
    1ebe:	ee 59       	subi	r30, 0x9E	; 158
    1ec0:	ff 4f       	sbci	r31, 0xFF	; 255
    1ec2:	84 e0       	ldi	r24, 0x04	; 4
    1ec4:	80 83       	st	Z, r24
    1ec6:	26 c0       	rjmp	.+76     	; 0x1f14 <LCD_write_data_4bit+0x49e>

		DIO_void_assign_pin(lcd_data_port, i, get_Bit(copy_data_4bit,i));
    1ec8:	fe 01       	movw	r30, r28
    1eca:	ed 59       	subi	r30, 0x9D	; 157
    1ecc:	ff 4f       	sbci	r31, 0xFF	; 255
    1ece:	80 81       	ld	r24, Z
    1ed0:	28 2f       	mov	r18, r24
    1ed2:	30 e0       	ldi	r19, 0x00	; 0
    1ed4:	fe 01       	movw	r30, r28
    1ed6:	ee 59       	subi	r30, 0x9E	; 158
    1ed8:	ff 4f       	sbci	r31, 0xFF	; 255
    1eda:	80 81       	ld	r24, Z
    1edc:	88 2f       	mov	r24, r24
    1ede:	90 e0       	ldi	r25, 0x00	; 0
    1ee0:	a9 01       	movw	r20, r18
    1ee2:	02 c0       	rjmp	.+4      	; 0x1ee8 <LCD_write_data_4bit+0x472>
    1ee4:	55 95       	asr	r21
    1ee6:	47 95       	ror	r20
    1ee8:	8a 95       	dec	r24
    1eea:	e2 f7       	brpl	.-8      	; 0x1ee4 <LCD_write_data_4bit+0x46e>
    1eec:	ca 01       	movw	r24, r20
    1eee:	98 2f       	mov	r25, r24
    1ef0:	91 70       	andi	r25, 0x01	; 1
    1ef2:	fe 01       	movw	r30, r28
    1ef4:	ee 59       	subi	r30, 0x9E	; 158
    1ef6:	ff 4f       	sbci	r31, 0xFF	; 255
    1ef8:	82 e0       	ldi	r24, 0x02	; 2
    1efa:	60 81       	ld	r22, Z
    1efc:	49 2f       	mov	r20, r25
    1efe:	0e 94 b1 08 	call	0x1162	; 0x1162 <DIO_void_assign_pin>
	 *  any change in this sequence will result in a wrong behavior
	 *  i will try to make it more generic in the next versions
	 *
	 */

	for(u8 i = 4; i < 8; i++){
    1f02:	de 01       	movw	r26, r28
    1f04:	ae 59       	subi	r26, 0x9E	; 158
    1f06:	bf 4f       	sbci	r27, 0xFF	; 255
    1f08:	fe 01       	movw	r30, r28
    1f0a:	ee 59       	subi	r30, 0x9E	; 158
    1f0c:	ff 4f       	sbci	r31, 0xFF	; 255
    1f0e:	80 81       	ld	r24, Z
    1f10:	8f 5f       	subi	r24, 0xFF	; 255
    1f12:	8c 93       	st	X, r24
    1f14:	fe 01       	movw	r30, r28
    1f16:	ee 59       	subi	r30, 0x9E	; 158
    1f18:	ff 4f       	sbci	r31, 0xFF	; 255
    1f1a:	80 81       	ld	r24, Z
    1f1c:	88 30       	cpi	r24, 0x08	; 8
    1f1e:	a0 f2       	brcs	.-88     	; 0x1ec8 <LCD_write_data_4bit+0x452>
		// the for loop assigns the data value in the function input
		// by starting by the most significant 4 bits b4-b7

	}
	// set enable to low to send the lower nibble
	DIO_void_clear_pin(lcd_control_port, lcd_enable);
    1f20:	83 e0       	ldi	r24, 0x03	; 3
    1f22:	60 e0       	ldi	r22, 0x00	; 0
    1f24:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>
    1f28:	80 e0       	ldi	r24, 0x00	; 0
    1f2a:	90 e0       	ldi	r25, 0x00	; 0
    1f2c:	a0 e2       	ldi	r26, 0x20	; 32
    1f2e:	b1 e4       	ldi	r27, 0x41	; 65
    1f30:	8d a7       	std	Y+45, r24	; 0x2d
    1f32:	9e a7       	std	Y+46, r25	; 0x2e
    1f34:	af a7       	std	Y+47, r26	; 0x2f
    1f36:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1f38:	6d a5       	ldd	r22, Y+45	; 0x2d
    1f3a:	7e a5       	ldd	r23, Y+46	; 0x2e
    1f3c:	8f a5       	ldd	r24, Y+47	; 0x2f
    1f3e:	98 a9       	ldd	r25, Y+48	; 0x30
    1f40:	2b ea       	ldi	r18, 0xAB	; 171
    1f42:	3a ea       	ldi	r19, 0xAA	; 170
    1f44:	4a e2       	ldi	r20, 0x2A	; 42
    1f46:	50 e4       	ldi	r21, 0x40	; 64
    1f48:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f4c:	dc 01       	movw	r26, r24
    1f4e:	cb 01       	movw	r24, r22
    1f50:	89 a7       	std	Y+41, r24	; 0x29
    1f52:	9a a7       	std	Y+42, r25	; 0x2a
    1f54:	ab a7       	std	Y+43, r26	; 0x2b
    1f56:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    1f58:	69 a5       	ldd	r22, Y+41	; 0x29
    1f5a:	7a a5       	ldd	r23, Y+42	; 0x2a
    1f5c:	8b a5       	ldd	r24, Y+43	; 0x2b
    1f5e:	9c a5       	ldd	r25, Y+44	; 0x2c
    1f60:	20 e0       	ldi	r18, 0x00	; 0
    1f62:	30 e0       	ldi	r19, 0x00	; 0
    1f64:	40 e8       	ldi	r20, 0x80	; 128
    1f66:	5f e3       	ldi	r21, 0x3F	; 63
    1f68:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1f6c:	88 23       	and	r24, r24
    1f6e:	1c f4       	brge	.+6      	; 0x1f76 <LCD_write_data_4bit+0x500>
		__ticks = 1;
    1f70:	81 e0       	ldi	r24, 0x01	; 1
    1f72:	88 a7       	std	Y+40, r24	; 0x28
    1f74:	91 c0       	rjmp	.+290    	; 0x2098 <LCD_write_data_4bit+0x622>
	else if (__tmp > 255)
    1f76:	69 a5       	ldd	r22, Y+41	; 0x29
    1f78:	7a a5       	ldd	r23, Y+42	; 0x2a
    1f7a:	8b a5       	ldd	r24, Y+43	; 0x2b
    1f7c:	9c a5       	ldd	r25, Y+44	; 0x2c
    1f7e:	20 e0       	ldi	r18, 0x00	; 0
    1f80:	30 e0       	ldi	r19, 0x00	; 0
    1f82:	4f e7       	ldi	r20, 0x7F	; 127
    1f84:	53 e4       	ldi	r21, 0x43	; 67
    1f86:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    1f8a:	18 16       	cp	r1, r24
    1f8c:	0c f0       	brlt	.+2      	; 0x1f90 <LCD_write_data_4bit+0x51a>
    1f8e:	7b c0       	rjmp	.+246    	; 0x2086 <LCD_write_data_4bit+0x610>
	{
		_delay_ms(__us / 1000.0);
    1f90:	6d a5       	ldd	r22, Y+45	; 0x2d
    1f92:	7e a5       	ldd	r23, Y+46	; 0x2e
    1f94:	8f a5       	ldd	r24, Y+47	; 0x2f
    1f96:	98 a9       	ldd	r25, Y+48	; 0x30
    1f98:	20 e0       	ldi	r18, 0x00	; 0
    1f9a:	30 e0       	ldi	r19, 0x00	; 0
    1f9c:	4a e7       	ldi	r20, 0x7A	; 122
    1f9e:	54 e4       	ldi	r21, 0x44	; 68
    1fa0:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1fa4:	dc 01       	movw	r26, r24
    1fa6:	cb 01       	movw	r24, r22
    1fa8:	8c a3       	std	Y+36, r24	; 0x24
    1faa:	9d a3       	std	Y+37, r25	; 0x25
    1fac:	ae a3       	std	Y+38, r26	; 0x26
    1fae:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1fb0:	6c a1       	ldd	r22, Y+36	; 0x24
    1fb2:	7d a1       	ldd	r23, Y+37	; 0x25
    1fb4:	8e a1       	ldd	r24, Y+38	; 0x26
    1fb6:	9f a1       	ldd	r25, Y+39	; 0x27
    1fb8:	20 e0       	ldi	r18, 0x00	; 0
    1fba:	30 e0       	ldi	r19, 0x00	; 0
    1fbc:	4a ef       	ldi	r20, 0xFA	; 250
    1fbe:	54 e4       	ldi	r21, 0x44	; 68
    1fc0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1fc4:	dc 01       	movw	r26, r24
    1fc6:	cb 01       	movw	r24, r22
    1fc8:	88 a3       	std	Y+32, r24	; 0x20
    1fca:	99 a3       	std	Y+33, r25	; 0x21
    1fcc:	aa a3       	std	Y+34, r26	; 0x22
    1fce:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    1fd0:	68 a1       	ldd	r22, Y+32	; 0x20
    1fd2:	79 a1       	ldd	r23, Y+33	; 0x21
    1fd4:	8a a1       	ldd	r24, Y+34	; 0x22
    1fd6:	9b a1       	ldd	r25, Y+35	; 0x23
    1fd8:	20 e0       	ldi	r18, 0x00	; 0
    1fda:	30 e0       	ldi	r19, 0x00	; 0
    1fdc:	40 e8       	ldi	r20, 0x80	; 128
    1fde:	5f e3       	ldi	r21, 0x3F	; 63
    1fe0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    1fe4:	88 23       	and	r24, r24
    1fe6:	2c f4       	brge	.+10     	; 0x1ff2 <LCD_write_data_4bit+0x57c>
		__ticks = 1;
    1fe8:	81 e0       	ldi	r24, 0x01	; 1
    1fea:	90 e0       	ldi	r25, 0x00	; 0
    1fec:	9f 8f       	std	Y+31, r25	; 0x1f
    1fee:	8e 8f       	std	Y+30, r24	; 0x1e
    1ff0:	3f c0       	rjmp	.+126    	; 0x2070 <LCD_write_data_4bit+0x5fa>
	else if (__tmp > 65535)
    1ff2:	68 a1       	ldd	r22, Y+32	; 0x20
    1ff4:	79 a1       	ldd	r23, Y+33	; 0x21
    1ff6:	8a a1       	ldd	r24, Y+34	; 0x22
    1ff8:	9b a1       	ldd	r25, Y+35	; 0x23
    1ffa:	20 e0       	ldi	r18, 0x00	; 0
    1ffc:	3f ef       	ldi	r19, 0xFF	; 255
    1ffe:	4f e7       	ldi	r20, 0x7F	; 127
    2000:	57 e4       	ldi	r21, 0x47	; 71
    2002:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2006:	18 16       	cp	r1, r24
    2008:	4c f5       	brge	.+82     	; 0x205c <LCD_write_data_4bit+0x5e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    200a:	6c a1       	ldd	r22, Y+36	; 0x24
    200c:	7d a1       	ldd	r23, Y+37	; 0x25
    200e:	8e a1       	ldd	r24, Y+38	; 0x26
    2010:	9f a1       	ldd	r25, Y+39	; 0x27
    2012:	20 e0       	ldi	r18, 0x00	; 0
    2014:	30 e0       	ldi	r19, 0x00	; 0
    2016:	40 e2       	ldi	r20, 0x20	; 32
    2018:	51 e4       	ldi	r21, 0x41	; 65
    201a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    201e:	dc 01       	movw	r26, r24
    2020:	cb 01       	movw	r24, r22
    2022:	bc 01       	movw	r22, r24
    2024:	cd 01       	movw	r24, r26
    2026:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    202a:	dc 01       	movw	r26, r24
    202c:	cb 01       	movw	r24, r22
    202e:	9f 8f       	std	Y+31, r25	; 0x1f
    2030:	8e 8f       	std	Y+30, r24	; 0x1e
    2032:	0f c0       	rjmp	.+30     	; 0x2052 <LCD_write_data_4bit+0x5dc>
    2034:	88 ec       	ldi	r24, 0xC8	; 200
    2036:	90 e0       	ldi	r25, 0x00	; 0
    2038:	9d 8f       	std	Y+29, r25	; 0x1d
    203a:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    203c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    203e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    2040:	01 97       	sbiw	r24, 0x01	; 1
    2042:	f1 f7       	brne	.-4      	; 0x2040 <LCD_write_data_4bit+0x5ca>
    2044:	9d 8f       	std	Y+29, r25	; 0x1d
    2046:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2048:	8e 8d       	ldd	r24, Y+30	; 0x1e
    204a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    204c:	01 97       	sbiw	r24, 0x01	; 1
    204e:	9f 8f       	std	Y+31, r25	; 0x1f
    2050:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2052:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2054:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2056:	00 97       	sbiw	r24, 0x00	; 0
    2058:	69 f7       	brne	.-38     	; 0x2034 <LCD_write_data_4bit+0x5be>
    205a:	24 c0       	rjmp	.+72     	; 0x20a4 <LCD_write_data_4bit+0x62e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    205c:	68 a1       	ldd	r22, Y+32	; 0x20
    205e:	79 a1       	ldd	r23, Y+33	; 0x21
    2060:	8a a1       	ldd	r24, Y+34	; 0x22
    2062:	9b a1       	ldd	r25, Y+35	; 0x23
    2064:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2068:	dc 01       	movw	r26, r24
    206a:	cb 01       	movw	r24, r22
    206c:	9f 8f       	std	Y+31, r25	; 0x1f
    206e:	8e 8f       	std	Y+30, r24	; 0x1e
    2070:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2072:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2074:	9b 8f       	std	Y+27, r25	; 0x1b
    2076:	8a 8f       	std	Y+26, r24	; 0x1a
    2078:	8a 8d       	ldd	r24, Y+26	; 0x1a
    207a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    207c:	01 97       	sbiw	r24, 0x01	; 1
    207e:	f1 f7       	brne	.-4      	; 0x207c <LCD_write_data_4bit+0x606>
    2080:	9b 8f       	std	Y+27, r25	; 0x1b
    2082:	8a 8f       	std	Y+26, r24	; 0x1a
    2084:	0f c0       	rjmp	.+30     	; 0x20a4 <LCD_write_data_4bit+0x62e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2086:	69 a5       	ldd	r22, Y+41	; 0x29
    2088:	7a a5       	ldd	r23, Y+42	; 0x2a
    208a:	8b a5       	ldd	r24, Y+43	; 0x2b
    208c:	9c a5       	ldd	r25, Y+44	; 0x2c
    208e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2092:	dc 01       	movw	r26, r24
    2094:	cb 01       	movw	r24, r22
    2096:	88 a7       	std	Y+40, r24	; 0x28
    2098:	88 a5       	ldd	r24, Y+40	; 0x28
    209a:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    209c:	89 8d       	ldd	r24, Y+25	; 0x19
    209e:	8a 95       	dec	r24
    20a0:	f1 f7       	brne	.-4      	; 0x209e <LCD_write_data_4bit+0x628>
    20a2:	89 8f       	std	Y+25, r24	; 0x19
	//delay to smooth things out
	_delay_us(10);
	//enable HIGH
	DIO_void_set_pin(lcd_control_port, lcd_enable);
    20a4:	83 e0       	ldi	r24, 0x03	; 3
    20a6:	60 e0       	ldi	r22, 0x00	; 0
    20a8:	0e 94 50 08 	call	0x10a0	; 0x10a0 <DIO_void_set_pin>
    20ac:	80 e0       	ldi	r24, 0x00	; 0
    20ae:	90 e0       	ldi	r25, 0x00	; 0
    20b0:	a0 e8       	ldi	r26, 0x80	; 128
    20b2:	bf e3       	ldi	r27, 0x3F	; 63
    20b4:	8d 8b       	std	Y+21, r24	; 0x15
    20b6:	9e 8b       	std	Y+22, r25	; 0x16
    20b8:	af 8b       	std	Y+23, r26	; 0x17
    20ba:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    20bc:	6d 89       	ldd	r22, Y+21	; 0x15
    20be:	7e 89       	ldd	r23, Y+22	; 0x16
    20c0:	8f 89       	ldd	r24, Y+23	; 0x17
    20c2:	98 8d       	ldd	r25, Y+24	; 0x18
    20c4:	2b ea       	ldi	r18, 0xAB	; 171
    20c6:	3a ea       	ldi	r19, 0xAA	; 170
    20c8:	4a e2       	ldi	r20, 0x2A	; 42
    20ca:	50 e4       	ldi	r21, 0x40	; 64
    20cc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20d0:	dc 01       	movw	r26, r24
    20d2:	cb 01       	movw	r24, r22
    20d4:	89 8b       	std	Y+17, r24	; 0x11
    20d6:	9a 8b       	std	Y+18, r25	; 0x12
    20d8:	ab 8b       	std	Y+19, r26	; 0x13
    20da:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    20dc:	69 89       	ldd	r22, Y+17	; 0x11
    20de:	7a 89       	ldd	r23, Y+18	; 0x12
    20e0:	8b 89       	ldd	r24, Y+19	; 0x13
    20e2:	9c 89       	ldd	r25, Y+20	; 0x14
    20e4:	20 e0       	ldi	r18, 0x00	; 0
    20e6:	30 e0       	ldi	r19, 0x00	; 0
    20e8:	40 e8       	ldi	r20, 0x80	; 128
    20ea:	5f e3       	ldi	r21, 0x3F	; 63
    20ec:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    20f0:	88 23       	and	r24, r24
    20f2:	1c f4       	brge	.+6      	; 0x20fa <LCD_write_data_4bit+0x684>
		__ticks = 1;
    20f4:	81 e0       	ldi	r24, 0x01	; 1
    20f6:	88 8b       	std	Y+16, r24	; 0x10
    20f8:	91 c0       	rjmp	.+290    	; 0x221c <LCD_write_data_4bit+0x7a6>
	else if (__tmp > 255)
    20fa:	69 89       	ldd	r22, Y+17	; 0x11
    20fc:	7a 89       	ldd	r23, Y+18	; 0x12
    20fe:	8b 89       	ldd	r24, Y+19	; 0x13
    2100:	9c 89       	ldd	r25, Y+20	; 0x14
    2102:	20 e0       	ldi	r18, 0x00	; 0
    2104:	30 e0       	ldi	r19, 0x00	; 0
    2106:	4f e7       	ldi	r20, 0x7F	; 127
    2108:	53 e4       	ldi	r21, 0x43	; 67
    210a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    210e:	18 16       	cp	r1, r24
    2110:	0c f0       	brlt	.+2      	; 0x2114 <LCD_write_data_4bit+0x69e>
    2112:	7b c0       	rjmp	.+246    	; 0x220a <LCD_write_data_4bit+0x794>
	{
		_delay_ms(__us / 1000.0);
    2114:	6d 89       	ldd	r22, Y+21	; 0x15
    2116:	7e 89       	ldd	r23, Y+22	; 0x16
    2118:	8f 89       	ldd	r24, Y+23	; 0x17
    211a:	98 8d       	ldd	r25, Y+24	; 0x18
    211c:	20 e0       	ldi	r18, 0x00	; 0
    211e:	30 e0       	ldi	r19, 0x00	; 0
    2120:	4a e7       	ldi	r20, 0x7A	; 122
    2122:	54 e4       	ldi	r21, 0x44	; 68
    2124:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2128:	dc 01       	movw	r26, r24
    212a:	cb 01       	movw	r24, r22
    212c:	8c 87       	std	Y+12, r24	; 0x0c
    212e:	9d 87       	std	Y+13, r25	; 0x0d
    2130:	ae 87       	std	Y+14, r26	; 0x0e
    2132:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2134:	6c 85       	ldd	r22, Y+12	; 0x0c
    2136:	7d 85       	ldd	r23, Y+13	; 0x0d
    2138:	8e 85       	ldd	r24, Y+14	; 0x0e
    213a:	9f 85       	ldd	r25, Y+15	; 0x0f
    213c:	20 e0       	ldi	r18, 0x00	; 0
    213e:	30 e0       	ldi	r19, 0x00	; 0
    2140:	4a ef       	ldi	r20, 0xFA	; 250
    2142:	54 e4       	ldi	r21, 0x44	; 68
    2144:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2148:	dc 01       	movw	r26, r24
    214a:	cb 01       	movw	r24, r22
    214c:	88 87       	std	Y+8, r24	; 0x08
    214e:	99 87       	std	Y+9, r25	; 0x09
    2150:	aa 87       	std	Y+10, r26	; 0x0a
    2152:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    2154:	68 85       	ldd	r22, Y+8	; 0x08
    2156:	79 85       	ldd	r23, Y+9	; 0x09
    2158:	8a 85       	ldd	r24, Y+10	; 0x0a
    215a:	9b 85       	ldd	r25, Y+11	; 0x0b
    215c:	20 e0       	ldi	r18, 0x00	; 0
    215e:	30 e0       	ldi	r19, 0x00	; 0
    2160:	40 e8       	ldi	r20, 0x80	; 128
    2162:	5f e3       	ldi	r21, 0x3F	; 63
    2164:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2168:	88 23       	and	r24, r24
    216a:	2c f4       	brge	.+10     	; 0x2176 <LCD_write_data_4bit+0x700>
		__ticks = 1;
    216c:	81 e0       	ldi	r24, 0x01	; 1
    216e:	90 e0       	ldi	r25, 0x00	; 0
    2170:	9f 83       	std	Y+7, r25	; 0x07
    2172:	8e 83       	std	Y+6, r24	; 0x06
    2174:	3f c0       	rjmp	.+126    	; 0x21f4 <LCD_write_data_4bit+0x77e>
	else if (__tmp > 65535)
    2176:	68 85       	ldd	r22, Y+8	; 0x08
    2178:	79 85       	ldd	r23, Y+9	; 0x09
    217a:	8a 85       	ldd	r24, Y+10	; 0x0a
    217c:	9b 85       	ldd	r25, Y+11	; 0x0b
    217e:	20 e0       	ldi	r18, 0x00	; 0
    2180:	3f ef       	ldi	r19, 0xFF	; 255
    2182:	4f e7       	ldi	r20, 0x7F	; 127
    2184:	57 e4       	ldi	r21, 0x47	; 71
    2186:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    218a:	18 16       	cp	r1, r24
    218c:	4c f5       	brge	.+82     	; 0x21e0 <LCD_write_data_4bit+0x76a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    218e:	6c 85       	ldd	r22, Y+12	; 0x0c
    2190:	7d 85       	ldd	r23, Y+13	; 0x0d
    2192:	8e 85       	ldd	r24, Y+14	; 0x0e
    2194:	9f 85       	ldd	r25, Y+15	; 0x0f
    2196:	20 e0       	ldi	r18, 0x00	; 0
    2198:	30 e0       	ldi	r19, 0x00	; 0
    219a:	40 e2       	ldi	r20, 0x20	; 32
    219c:	51 e4       	ldi	r21, 0x41	; 65
    219e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    21a2:	dc 01       	movw	r26, r24
    21a4:	cb 01       	movw	r24, r22
    21a6:	bc 01       	movw	r22, r24
    21a8:	cd 01       	movw	r24, r26
    21aa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21ae:	dc 01       	movw	r26, r24
    21b0:	cb 01       	movw	r24, r22
    21b2:	9f 83       	std	Y+7, r25	; 0x07
    21b4:	8e 83       	std	Y+6, r24	; 0x06
    21b6:	0f c0       	rjmp	.+30     	; 0x21d6 <LCD_write_data_4bit+0x760>
    21b8:	88 ec       	ldi	r24, 0xC8	; 200
    21ba:	90 e0       	ldi	r25, 0x00	; 0
    21bc:	9d 83       	std	Y+5, r25	; 0x05
    21be:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    21c0:	8c 81       	ldd	r24, Y+4	; 0x04
    21c2:	9d 81       	ldd	r25, Y+5	; 0x05
    21c4:	01 97       	sbiw	r24, 0x01	; 1
    21c6:	f1 f7       	brne	.-4      	; 0x21c4 <LCD_write_data_4bit+0x74e>
    21c8:	9d 83       	std	Y+5, r25	; 0x05
    21ca:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    21cc:	8e 81       	ldd	r24, Y+6	; 0x06
    21ce:	9f 81       	ldd	r25, Y+7	; 0x07
    21d0:	01 97       	sbiw	r24, 0x01	; 1
    21d2:	9f 83       	std	Y+7, r25	; 0x07
    21d4:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    21d6:	8e 81       	ldd	r24, Y+6	; 0x06
    21d8:	9f 81       	ldd	r25, Y+7	; 0x07
    21da:	00 97       	sbiw	r24, 0x00	; 0
    21dc:	69 f7       	brne	.-38     	; 0x21b8 <LCD_write_data_4bit+0x742>
    21de:	24 c0       	rjmp	.+72     	; 0x2228 <LCD_write_data_4bit+0x7b2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    21e0:	68 85       	ldd	r22, Y+8	; 0x08
    21e2:	79 85       	ldd	r23, Y+9	; 0x09
    21e4:	8a 85       	ldd	r24, Y+10	; 0x0a
    21e6:	9b 85       	ldd	r25, Y+11	; 0x0b
    21e8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    21ec:	dc 01       	movw	r26, r24
    21ee:	cb 01       	movw	r24, r22
    21f0:	9f 83       	std	Y+7, r25	; 0x07
    21f2:	8e 83       	std	Y+6, r24	; 0x06
    21f4:	8e 81       	ldd	r24, Y+6	; 0x06
    21f6:	9f 81       	ldd	r25, Y+7	; 0x07
    21f8:	9b 83       	std	Y+3, r25	; 0x03
    21fa:	8a 83       	std	Y+2, r24	; 0x02
    21fc:	8a 81       	ldd	r24, Y+2	; 0x02
    21fe:	9b 81       	ldd	r25, Y+3	; 0x03
    2200:	01 97       	sbiw	r24, 0x01	; 1
    2202:	f1 f7       	brne	.-4      	; 0x2200 <LCD_write_data_4bit+0x78a>
    2204:	9b 83       	std	Y+3, r25	; 0x03
    2206:	8a 83       	std	Y+2, r24	; 0x02
    2208:	0f c0       	rjmp	.+30     	; 0x2228 <LCD_write_data_4bit+0x7b2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    220a:	69 89       	ldd	r22, Y+17	; 0x11
    220c:	7a 89       	ldd	r23, Y+18	; 0x12
    220e:	8b 89       	ldd	r24, Y+19	; 0x13
    2210:	9c 89       	ldd	r25, Y+20	; 0x14
    2212:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2216:	dc 01       	movw	r26, r24
    2218:	cb 01       	movw	r24, r22
    221a:	88 8b       	std	Y+16, r24	; 0x10
    221c:	88 89       	ldd	r24, Y+16	; 0x10
    221e:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2220:	89 81       	ldd	r24, Y+1	; 0x01
    2222:	8a 95       	dec	r24
    2224:	f1 f7       	brne	.-4      	; 0x2222 <LCD_write_data_4bit+0x7ac>
    2226:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1);
	//send lower nibble
	for(u8 i = 4; i < 8; i++){
    2228:	fe 01       	movw	r30, r28
    222a:	ef 59       	subi	r30, 0x9F	; 159
    222c:	ff 4f       	sbci	r31, 0xFF	; 255
    222e:	84 e0       	ldi	r24, 0x04	; 4
    2230:	80 83       	st	Z, r24
    2232:	27 c0       	rjmp	.+78     	; 0x2282 <LCD_write_data_4bit+0x80c>

			DIO_void_assign_pin(lcd_data_port, i, get_Bit(copy_data_4bit,i-4));
    2234:	fe 01       	movw	r30, r28
    2236:	ed 59       	subi	r30, 0x9D	; 157
    2238:	ff 4f       	sbci	r31, 0xFF	; 255
    223a:	80 81       	ld	r24, Z
    223c:	28 2f       	mov	r18, r24
    223e:	30 e0       	ldi	r19, 0x00	; 0
    2240:	fe 01       	movw	r30, r28
    2242:	ef 59       	subi	r30, 0x9F	; 159
    2244:	ff 4f       	sbci	r31, 0xFF	; 255
    2246:	80 81       	ld	r24, Z
    2248:	88 2f       	mov	r24, r24
    224a:	90 e0       	ldi	r25, 0x00	; 0
    224c:	04 97       	sbiw	r24, 0x04	; 4
    224e:	f9 01       	movw	r30, r18
    2250:	02 c0       	rjmp	.+4      	; 0x2256 <LCD_write_data_4bit+0x7e0>
    2252:	f5 95       	asr	r31
    2254:	e7 95       	ror	r30
    2256:	8a 95       	dec	r24
    2258:	e2 f7       	brpl	.-8      	; 0x2252 <LCD_write_data_4bit+0x7dc>
    225a:	cf 01       	movw	r24, r30
    225c:	98 2f       	mov	r25, r24
    225e:	91 70       	andi	r25, 0x01	; 1
    2260:	fe 01       	movw	r30, r28
    2262:	ef 59       	subi	r30, 0x9F	; 159
    2264:	ff 4f       	sbci	r31, 0xFF	; 255
    2266:	82 e0       	ldi	r24, 0x02	; 2
    2268:	60 81       	ld	r22, Z
    226a:	49 2f       	mov	r20, r25
    226c:	0e 94 b1 08 	call	0x1162	; 0x1162 <DIO_void_assign_pin>
	_delay_us(10);
	//enable HIGH
	DIO_void_set_pin(lcd_control_port, lcd_enable);
	_delay_us(1);
	//send lower nibble
	for(u8 i = 4; i < 8; i++){
    2270:	de 01       	movw	r26, r28
    2272:	af 59       	subi	r26, 0x9F	; 159
    2274:	bf 4f       	sbci	r27, 0xFF	; 255
    2276:	fe 01       	movw	r30, r28
    2278:	ef 59       	subi	r30, 0x9F	; 159
    227a:	ff 4f       	sbci	r31, 0xFF	; 255
    227c:	80 81       	ld	r24, Z
    227e:	8f 5f       	subi	r24, 0xFF	; 255
    2280:	8c 93       	st	X, r24
    2282:	fe 01       	movw	r30, r28
    2284:	ef 59       	subi	r30, 0x9F	; 159
    2286:	ff 4f       	sbci	r31, 0xFF	; 255
    2288:	80 81       	ld	r24, Z
    228a:	88 30       	cpi	r24, 0x08	; 8
    228c:	98 f2       	brcs	.-90     	; 0x2234 <LCD_write_data_4bit+0x7be>
			// the for loop assigns the data value in the function input
			// by starting by the least significant 4 bits b0-b3

		}
	//enable low
	DIO_void_clear_pin(lcd_control_port, lcd_enable);
    228e:	83 e0       	ldi	r24, 0x03	; 3
    2290:	60 e0       	ldi	r22, 0x00	; 0
    2292:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>


}
    2296:	cd 59       	subi	r28, 0x9D	; 157
    2298:	df 4f       	sbci	r29, 0xFF	; 255
    229a:	0f b6       	in	r0, 0x3f	; 63
    229c:	f8 94       	cli
    229e:	de bf       	out	0x3e, r29	; 62
    22a0:	0f be       	out	0x3f, r0	; 63
    22a2:	cd bf       	out	0x3d, r28	; 61
    22a4:	cf 91       	pop	r28
    22a6:	df 91       	pop	r29
    22a8:	1f 91       	pop	r17
    22aa:	0f 91       	pop	r16
    22ac:	08 95       	ret

000022ae <LCD_write_command_4bit>:

static void LCD_write_command_4bit(u8 copy_command_4bit){
    22ae:	0f 93       	push	r16
    22b0:	1f 93       	push	r17
    22b2:	df 93       	push	r29
    22b4:	cf 93       	push	r28
    22b6:	cd b7       	in	r28, 0x3d	; 61
    22b8:	de b7       	in	r29, 0x3e	; 62
    22ba:	c3 56       	subi	r28, 0x63	; 99
    22bc:	d0 40       	sbci	r29, 0x00	; 0
    22be:	0f b6       	in	r0, 0x3f	; 63
    22c0:	f8 94       	cli
    22c2:	de bf       	out	0x3e, r29	; 62
    22c4:	0f be       	out	0x3f, r0	; 63
    22c6:	cd bf       	out	0x3d, r28	; 61
    22c8:	fe 01       	movw	r30, r28
    22ca:	ed 59       	subi	r30, 0x9D	; 157
    22cc:	ff 4f       	sbci	r31, 0xFF	; 255
    22ce:	80 83       	st	Z, r24
		 *  function will only be used inside this source file
		 *  do you not use it in your code!
		 *
		 */

	DIO_void_clear_pin(lcd_control_port, lcd_RS); // set RS pin high select data register
    22d0:	83 e0       	ldi	r24, 0x03	; 3
    22d2:	62 e0       	ldi	r22, 0x02	; 2
    22d4:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>
	DIO_void_clear_pin(lcd_control_port, lcd_RW); // clear RW pin  0 for writing operation
    22d8:	83 e0       	ldi	r24, 0x03	; 3
    22da:	61 e0       	ldi	r22, 0x01	; 1
    22dc:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>
    22e0:	fe 01       	movw	r30, r28
    22e2:	e3 5a       	subi	r30, 0xA3	; 163
    22e4:	ff 4f       	sbci	r31, 0xFF	; 255
    22e6:	80 e0       	ldi	r24, 0x00	; 0
    22e8:	90 e0       	ldi	r25, 0x00	; 0
    22ea:	a0 e8       	ldi	r26, 0x80	; 128
    22ec:	bf e3       	ldi	r27, 0x3F	; 63
    22ee:	80 83       	st	Z, r24
    22f0:	91 83       	std	Z+1, r25	; 0x01
    22f2:	a2 83       	std	Z+2, r26	; 0x02
    22f4:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    22f6:	8e 01       	movw	r16, r28
    22f8:	07 5a       	subi	r16, 0xA7	; 167
    22fa:	1f 4f       	sbci	r17, 0xFF	; 255
    22fc:	fe 01       	movw	r30, r28
    22fe:	e3 5a       	subi	r30, 0xA3	; 163
    2300:	ff 4f       	sbci	r31, 0xFF	; 255
    2302:	60 81       	ld	r22, Z
    2304:	71 81       	ldd	r23, Z+1	; 0x01
    2306:	82 81       	ldd	r24, Z+2	; 0x02
    2308:	93 81       	ldd	r25, Z+3	; 0x03
    230a:	2b ea       	ldi	r18, 0xAB	; 171
    230c:	3a ea       	ldi	r19, 0xAA	; 170
    230e:	4a e2       	ldi	r20, 0x2A	; 42
    2310:	50 e4       	ldi	r21, 0x40	; 64
    2312:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2316:	dc 01       	movw	r26, r24
    2318:	cb 01       	movw	r24, r22
    231a:	f8 01       	movw	r30, r16
    231c:	80 83       	st	Z, r24
    231e:	91 83       	std	Z+1, r25	; 0x01
    2320:	a2 83       	std	Z+2, r26	; 0x02
    2322:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    2324:	fe 01       	movw	r30, r28
    2326:	e7 5a       	subi	r30, 0xA7	; 167
    2328:	ff 4f       	sbci	r31, 0xFF	; 255
    232a:	60 81       	ld	r22, Z
    232c:	71 81       	ldd	r23, Z+1	; 0x01
    232e:	82 81       	ldd	r24, Z+2	; 0x02
    2330:	93 81       	ldd	r25, Z+3	; 0x03
    2332:	20 e0       	ldi	r18, 0x00	; 0
    2334:	30 e0       	ldi	r19, 0x00	; 0
    2336:	40 e8       	ldi	r20, 0x80	; 128
    2338:	5f e3       	ldi	r21, 0x3F	; 63
    233a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    233e:	88 23       	and	r24, r24
    2340:	34 f4       	brge	.+12     	; 0x234e <LCD_write_command_4bit+0xa0>
		__ticks = 1;
    2342:	fe 01       	movw	r30, r28
    2344:	e8 5a       	subi	r30, 0xA8	; 168
    2346:	ff 4f       	sbci	r31, 0xFF	; 255
    2348:	81 e0       	ldi	r24, 0x01	; 1
    234a:	80 83       	st	Z, r24
    234c:	e0 c0       	rjmp	.+448    	; 0x250e <LCD_write_command_4bit+0x260>
	else if (__tmp > 255)
    234e:	fe 01       	movw	r30, r28
    2350:	e7 5a       	subi	r30, 0xA7	; 167
    2352:	ff 4f       	sbci	r31, 0xFF	; 255
    2354:	60 81       	ld	r22, Z
    2356:	71 81       	ldd	r23, Z+1	; 0x01
    2358:	82 81       	ldd	r24, Z+2	; 0x02
    235a:	93 81       	ldd	r25, Z+3	; 0x03
    235c:	20 e0       	ldi	r18, 0x00	; 0
    235e:	30 e0       	ldi	r19, 0x00	; 0
    2360:	4f e7       	ldi	r20, 0x7F	; 127
    2362:	53 e4       	ldi	r21, 0x43	; 67
    2364:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2368:	18 16       	cp	r1, r24
    236a:	0c f0       	brlt	.+2      	; 0x236e <LCD_write_command_4bit+0xc0>
    236c:	c0 c0       	rjmp	.+384    	; 0x24ee <LCD_write_command_4bit+0x240>
	{
		_delay_ms(__us / 1000.0);
    236e:	fe 01       	movw	r30, r28
    2370:	e3 5a       	subi	r30, 0xA3	; 163
    2372:	ff 4f       	sbci	r31, 0xFF	; 255
    2374:	60 81       	ld	r22, Z
    2376:	71 81       	ldd	r23, Z+1	; 0x01
    2378:	82 81       	ldd	r24, Z+2	; 0x02
    237a:	93 81       	ldd	r25, Z+3	; 0x03
    237c:	20 e0       	ldi	r18, 0x00	; 0
    237e:	30 e0       	ldi	r19, 0x00	; 0
    2380:	4a e7       	ldi	r20, 0x7A	; 122
    2382:	54 e4       	ldi	r21, 0x44	; 68
    2384:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2388:	dc 01       	movw	r26, r24
    238a:	cb 01       	movw	r24, r22
    238c:	fe 01       	movw	r30, r28
    238e:	ec 5a       	subi	r30, 0xAC	; 172
    2390:	ff 4f       	sbci	r31, 0xFF	; 255
    2392:	80 83       	st	Z, r24
    2394:	91 83       	std	Z+1, r25	; 0x01
    2396:	a2 83       	std	Z+2, r26	; 0x02
    2398:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    239a:	8e 01       	movw	r16, r28
    239c:	00 5b       	subi	r16, 0xB0	; 176
    239e:	1f 4f       	sbci	r17, 0xFF	; 255
    23a0:	fe 01       	movw	r30, r28
    23a2:	ec 5a       	subi	r30, 0xAC	; 172
    23a4:	ff 4f       	sbci	r31, 0xFF	; 255
    23a6:	60 81       	ld	r22, Z
    23a8:	71 81       	ldd	r23, Z+1	; 0x01
    23aa:	82 81       	ldd	r24, Z+2	; 0x02
    23ac:	93 81       	ldd	r25, Z+3	; 0x03
    23ae:	20 e0       	ldi	r18, 0x00	; 0
    23b0:	30 e0       	ldi	r19, 0x00	; 0
    23b2:	4a ef       	ldi	r20, 0xFA	; 250
    23b4:	54 e4       	ldi	r21, 0x44	; 68
    23b6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    23ba:	dc 01       	movw	r26, r24
    23bc:	cb 01       	movw	r24, r22
    23be:	f8 01       	movw	r30, r16
    23c0:	80 83       	st	Z, r24
    23c2:	91 83       	std	Z+1, r25	; 0x01
    23c4:	a2 83       	std	Z+2, r26	; 0x02
    23c6:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    23c8:	fe 01       	movw	r30, r28
    23ca:	e0 5b       	subi	r30, 0xB0	; 176
    23cc:	ff 4f       	sbci	r31, 0xFF	; 255
    23ce:	60 81       	ld	r22, Z
    23d0:	71 81       	ldd	r23, Z+1	; 0x01
    23d2:	82 81       	ldd	r24, Z+2	; 0x02
    23d4:	93 81       	ldd	r25, Z+3	; 0x03
    23d6:	20 e0       	ldi	r18, 0x00	; 0
    23d8:	30 e0       	ldi	r19, 0x00	; 0
    23da:	40 e8       	ldi	r20, 0x80	; 128
    23dc:	5f e3       	ldi	r21, 0x3F	; 63
    23de:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    23e2:	88 23       	and	r24, r24
    23e4:	44 f4       	brge	.+16     	; 0x23f6 <LCD_write_command_4bit+0x148>
		__ticks = 1;
    23e6:	fe 01       	movw	r30, r28
    23e8:	e2 5b       	subi	r30, 0xB2	; 178
    23ea:	ff 4f       	sbci	r31, 0xFF	; 255
    23ec:	81 e0       	ldi	r24, 0x01	; 1
    23ee:	90 e0       	ldi	r25, 0x00	; 0
    23f0:	91 83       	std	Z+1, r25	; 0x01
    23f2:	80 83       	st	Z, r24
    23f4:	64 c0       	rjmp	.+200    	; 0x24be <LCD_write_command_4bit+0x210>
	else if (__tmp > 65535)
    23f6:	fe 01       	movw	r30, r28
    23f8:	e0 5b       	subi	r30, 0xB0	; 176
    23fa:	ff 4f       	sbci	r31, 0xFF	; 255
    23fc:	60 81       	ld	r22, Z
    23fe:	71 81       	ldd	r23, Z+1	; 0x01
    2400:	82 81       	ldd	r24, Z+2	; 0x02
    2402:	93 81       	ldd	r25, Z+3	; 0x03
    2404:	20 e0       	ldi	r18, 0x00	; 0
    2406:	3f ef       	ldi	r19, 0xFF	; 255
    2408:	4f e7       	ldi	r20, 0x7F	; 127
    240a:	57 e4       	ldi	r21, 0x47	; 71
    240c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2410:	18 16       	cp	r1, r24
    2412:	0c f0       	brlt	.+2      	; 0x2416 <LCD_write_command_4bit+0x168>
    2414:	43 c0       	rjmp	.+134    	; 0x249c <LCD_write_command_4bit+0x1ee>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2416:	fe 01       	movw	r30, r28
    2418:	ec 5a       	subi	r30, 0xAC	; 172
    241a:	ff 4f       	sbci	r31, 0xFF	; 255
    241c:	60 81       	ld	r22, Z
    241e:	71 81       	ldd	r23, Z+1	; 0x01
    2420:	82 81       	ldd	r24, Z+2	; 0x02
    2422:	93 81       	ldd	r25, Z+3	; 0x03
    2424:	20 e0       	ldi	r18, 0x00	; 0
    2426:	30 e0       	ldi	r19, 0x00	; 0
    2428:	40 e2       	ldi	r20, 0x20	; 32
    242a:	51 e4       	ldi	r21, 0x41	; 65
    242c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2430:	dc 01       	movw	r26, r24
    2432:	cb 01       	movw	r24, r22
    2434:	8e 01       	movw	r16, r28
    2436:	02 5b       	subi	r16, 0xB2	; 178
    2438:	1f 4f       	sbci	r17, 0xFF	; 255
    243a:	bc 01       	movw	r22, r24
    243c:	cd 01       	movw	r24, r26
    243e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2442:	dc 01       	movw	r26, r24
    2444:	cb 01       	movw	r24, r22
    2446:	f8 01       	movw	r30, r16
    2448:	91 83       	std	Z+1, r25	; 0x01
    244a:	80 83       	st	Z, r24
    244c:	1f c0       	rjmp	.+62     	; 0x248c <LCD_write_command_4bit+0x1de>
    244e:	fe 01       	movw	r30, r28
    2450:	e4 5b       	subi	r30, 0xB4	; 180
    2452:	ff 4f       	sbci	r31, 0xFF	; 255
    2454:	88 ec       	ldi	r24, 0xC8	; 200
    2456:	90 e0       	ldi	r25, 0x00	; 0
    2458:	91 83       	std	Z+1, r25	; 0x01
    245a:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    245c:	fe 01       	movw	r30, r28
    245e:	e4 5b       	subi	r30, 0xB4	; 180
    2460:	ff 4f       	sbci	r31, 0xFF	; 255
    2462:	80 81       	ld	r24, Z
    2464:	91 81       	ldd	r25, Z+1	; 0x01
    2466:	01 97       	sbiw	r24, 0x01	; 1
    2468:	f1 f7       	brne	.-4      	; 0x2466 <LCD_write_command_4bit+0x1b8>
    246a:	fe 01       	movw	r30, r28
    246c:	e4 5b       	subi	r30, 0xB4	; 180
    246e:	ff 4f       	sbci	r31, 0xFF	; 255
    2470:	91 83       	std	Z+1, r25	; 0x01
    2472:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2474:	de 01       	movw	r26, r28
    2476:	a2 5b       	subi	r26, 0xB2	; 178
    2478:	bf 4f       	sbci	r27, 0xFF	; 255
    247a:	fe 01       	movw	r30, r28
    247c:	e2 5b       	subi	r30, 0xB2	; 178
    247e:	ff 4f       	sbci	r31, 0xFF	; 255
    2480:	80 81       	ld	r24, Z
    2482:	91 81       	ldd	r25, Z+1	; 0x01
    2484:	01 97       	sbiw	r24, 0x01	; 1
    2486:	11 96       	adiw	r26, 0x01	; 1
    2488:	9c 93       	st	X, r25
    248a:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    248c:	fe 01       	movw	r30, r28
    248e:	e2 5b       	subi	r30, 0xB2	; 178
    2490:	ff 4f       	sbci	r31, 0xFF	; 255
    2492:	80 81       	ld	r24, Z
    2494:	91 81       	ldd	r25, Z+1	; 0x01
    2496:	00 97       	sbiw	r24, 0x00	; 0
    2498:	d1 f6       	brne	.-76     	; 0x244e <LCD_write_command_4bit+0x1a0>
    249a:	4b c0       	rjmp	.+150    	; 0x2532 <LCD_write_command_4bit+0x284>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    249c:	8e 01       	movw	r16, r28
    249e:	02 5b       	subi	r16, 0xB2	; 178
    24a0:	1f 4f       	sbci	r17, 0xFF	; 255
    24a2:	fe 01       	movw	r30, r28
    24a4:	e0 5b       	subi	r30, 0xB0	; 176
    24a6:	ff 4f       	sbci	r31, 0xFF	; 255
    24a8:	60 81       	ld	r22, Z
    24aa:	71 81       	ldd	r23, Z+1	; 0x01
    24ac:	82 81       	ldd	r24, Z+2	; 0x02
    24ae:	93 81       	ldd	r25, Z+3	; 0x03
    24b0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    24b4:	dc 01       	movw	r26, r24
    24b6:	cb 01       	movw	r24, r22
    24b8:	f8 01       	movw	r30, r16
    24ba:	91 83       	std	Z+1, r25	; 0x01
    24bc:	80 83       	st	Z, r24
    24be:	de 01       	movw	r26, r28
    24c0:	a6 5b       	subi	r26, 0xB6	; 182
    24c2:	bf 4f       	sbci	r27, 0xFF	; 255
    24c4:	fe 01       	movw	r30, r28
    24c6:	e2 5b       	subi	r30, 0xB2	; 178
    24c8:	ff 4f       	sbci	r31, 0xFF	; 255
    24ca:	80 81       	ld	r24, Z
    24cc:	91 81       	ldd	r25, Z+1	; 0x01
    24ce:	11 96       	adiw	r26, 0x01	; 1
    24d0:	9c 93       	st	X, r25
    24d2:	8e 93       	st	-X, r24
    24d4:	fe 01       	movw	r30, r28
    24d6:	e6 5b       	subi	r30, 0xB6	; 182
    24d8:	ff 4f       	sbci	r31, 0xFF	; 255
    24da:	80 81       	ld	r24, Z
    24dc:	91 81       	ldd	r25, Z+1	; 0x01
    24de:	01 97       	sbiw	r24, 0x01	; 1
    24e0:	f1 f7       	brne	.-4      	; 0x24de <LCD_write_command_4bit+0x230>
    24e2:	fe 01       	movw	r30, r28
    24e4:	e6 5b       	subi	r30, 0xB6	; 182
    24e6:	ff 4f       	sbci	r31, 0xFF	; 255
    24e8:	91 83       	std	Z+1, r25	; 0x01
    24ea:	80 83       	st	Z, r24
    24ec:	22 c0       	rjmp	.+68     	; 0x2532 <LCD_write_command_4bit+0x284>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    24ee:	8e 01       	movw	r16, r28
    24f0:	08 5a       	subi	r16, 0xA8	; 168
    24f2:	1f 4f       	sbci	r17, 0xFF	; 255
    24f4:	fe 01       	movw	r30, r28
    24f6:	e7 5a       	subi	r30, 0xA7	; 167
    24f8:	ff 4f       	sbci	r31, 0xFF	; 255
    24fa:	60 81       	ld	r22, Z
    24fc:	71 81       	ldd	r23, Z+1	; 0x01
    24fe:	82 81       	ldd	r24, Z+2	; 0x02
    2500:	93 81       	ldd	r25, Z+3	; 0x03
    2502:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2506:	dc 01       	movw	r26, r24
    2508:	cb 01       	movw	r24, r22
    250a:	f8 01       	movw	r30, r16
    250c:	80 83       	st	Z, r24
    250e:	de 01       	movw	r26, r28
    2510:	a7 5b       	subi	r26, 0xB7	; 183
    2512:	bf 4f       	sbci	r27, 0xFF	; 255
    2514:	fe 01       	movw	r30, r28
    2516:	e8 5a       	subi	r30, 0xA8	; 168
    2518:	ff 4f       	sbci	r31, 0xFF	; 255
    251a:	80 81       	ld	r24, Z
    251c:	8c 93       	st	X, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    251e:	fe 01       	movw	r30, r28
    2520:	e7 5b       	subi	r30, 0xB7	; 183
    2522:	ff 4f       	sbci	r31, 0xFF	; 255
    2524:	80 81       	ld	r24, Z
    2526:	8a 95       	dec	r24
    2528:	f1 f7       	brne	.-4      	; 0x2526 <LCD_write_command_4bit+0x278>
    252a:	fe 01       	movw	r30, r28
    252c:	e7 5b       	subi	r30, 0xB7	; 183
    252e:	ff 4f       	sbci	r31, 0xFF	; 255
    2530:	80 83       	st	Z, r24

	_delay_us(1);
	//enable pin high
	DIO_void_set_pin(lcd_control_port, lcd_enable);
    2532:	83 e0       	ldi	r24, 0x03	; 3
    2534:	60 e0       	ldi	r22, 0x00	; 0
    2536:	0e 94 50 08 	call	0x10a0	; 0x10a0 <DIO_void_set_pin>
    253a:	fe 01       	movw	r30, r28
    253c:	eb 5b       	subi	r30, 0xBB	; 187
    253e:	ff 4f       	sbci	r31, 0xFF	; 255
    2540:	80 e0       	ldi	r24, 0x00	; 0
    2542:	90 e0       	ldi	r25, 0x00	; 0
    2544:	a0 e8       	ldi	r26, 0x80	; 128
    2546:	bf e3       	ldi	r27, 0x3F	; 63
    2548:	80 83       	st	Z, r24
    254a:	91 83       	std	Z+1, r25	; 0x01
    254c:	a2 83       	std	Z+2, r26	; 0x02
    254e:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    2550:	8e 01       	movw	r16, r28
    2552:	0f 5b       	subi	r16, 0xBF	; 191
    2554:	1f 4f       	sbci	r17, 0xFF	; 255
    2556:	fe 01       	movw	r30, r28
    2558:	eb 5b       	subi	r30, 0xBB	; 187
    255a:	ff 4f       	sbci	r31, 0xFF	; 255
    255c:	60 81       	ld	r22, Z
    255e:	71 81       	ldd	r23, Z+1	; 0x01
    2560:	82 81       	ldd	r24, Z+2	; 0x02
    2562:	93 81       	ldd	r25, Z+3	; 0x03
    2564:	2b ea       	ldi	r18, 0xAB	; 171
    2566:	3a ea       	ldi	r19, 0xAA	; 170
    2568:	4a e2       	ldi	r20, 0x2A	; 42
    256a:	50 e4       	ldi	r21, 0x40	; 64
    256c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2570:	dc 01       	movw	r26, r24
    2572:	cb 01       	movw	r24, r22
    2574:	f8 01       	movw	r30, r16
    2576:	80 83       	st	Z, r24
    2578:	91 83       	std	Z+1, r25	; 0x01
    257a:	a2 83       	std	Z+2, r26	; 0x02
    257c:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    257e:	fe 01       	movw	r30, r28
    2580:	ef 5b       	subi	r30, 0xBF	; 191
    2582:	ff 4f       	sbci	r31, 0xFF	; 255
    2584:	60 81       	ld	r22, Z
    2586:	71 81       	ldd	r23, Z+1	; 0x01
    2588:	82 81       	ldd	r24, Z+2	; 0x02
    258a:	93 81       	ldd	r25, Z+3	; 0x03
    258c:	20 e0       	ldi	r18, 0x00	; 0
    258e:	30 e0       	ldi	r19, 0x00	; 0
    2590:	40 e8       	ldi	r20, 0x80	; 128
    2592:	5f e3       	ldi	r21, 0x3F	; 63
    2594:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2598:	88 23       	and	r24, r24
    259a:	34 f4       	brge	.+12     	; 0x25a8 <LCD_write_command_4bit+0x2fa>
		__ticks = 1;
    259c:	81 e0       	ldi	r24, 0x01	; 1
    259e:	fe 01       	movw	r30, r28
    25a0:	e0 5c       	subi	r30, 0xC0	; 192
    25a2:	ff 4f       	sbci	r31, 0xFF	; 255
    25a4:	80 83       	st	Z, r24
    25a6:	9d c0       	rjmp	.+314    	; 0x26e2 <LCD_write_command_4bit+0x434>
	else if (__tmp > 255)
    25a8:	fe 01       	movw	r30, r28
    25aa:	ef 5b       	subi	r30, 0xBF	; 191
    25ac:	ff 4f       	sbci	r31, 0xFF	; 255
    25ae:	60 81       	ld	r22, Z
    25b0:	71 81       	ldd	r23, Z+1	; 0x01
    25b2:	82 81       	ldd	r24, Z+2	; 0x02
    25b4:	93 81       	ldd	r25, Z+3	; 0x03
    25b6:	20 e0       	ldi	r18, 0x00	; 0
    25b8:	30 e0       	ldi	r19, 0x00	; 0
    25ba:	4f e7       	ldi	r20, 0x7F	; 127
    25bc:	53 e4       	ldi	r21, 0x43	; 67
    25be:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    25c2:	18 16       	cp	r1, r24
    25c4:	0c f0       	brlt	.+2      	; 0x25c8 <LCD_write_command_4bit+0x31a>
    25c6:	7e c0       	rjmp	.+252    	; 0x26c4 <LCD_write_command_4bit+0x416>
	{
		_delay_ms(__us / 1000.0);
    25c8:	fe 01       	movw	r30, r28
    25ca:	eb 5b       	subi	r30, 0xBB	; 187
    25cc:	ff 4f       	sbci	r31, 0xFF	; 255
    25ce:	60 81       	ld	r22, Z
    25d0:	71 81       	ldd	r23, Z+1	; 0x01
    25d2:	82 81       	ldd	r24, Z+2	; 0x02
    25d4:	93 81       	ldd	r25, Z+3	; 0x03
    25d6:	20 e0       	ldi	r18, 0x00	; 0
    25d8:	30 e0       	ldi	r19, 0x00	; 0
    25da:	4a e7       	ldi	r20, 0x7A	; 122
    25dc:	54 e4       	ldi	r21, 0x44	; 68
    25de:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    25e2:	dc 01       	movw	r26, r24
    25e4:	cb 01       	movw	r24, r22
    25e6:	8c af       	std	Y+60, r24	; 0x3c
    25e8:	9d af       	std	Y+61, r25	; 0x3d
    25ea:	ae af       	std	Y+62, r26	; 0x3e
    25ec:	bf af       	std	Y+63, r27	; 0x3f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    25ee:	6c ad       	ldd	r22, Y+60	; 0x3c
    25f0:	7d ad       	ldd	r23, Y+61	; 0x3d
    25f2:	8e ad       	ldd	r24, Y+62	; 0x3e
    25f4:	9f ad       	ldd	r25, Y+63	; 0x3f
    25f6:	20 e0       	ldi	r18, 0x00	; 0
    25f8:	30 e0       	ldi	r19, 0x00	; 0
    25fa:	4a ef       	ldi	r20, 0xFA	; 250
    25fc:	54 e4       	ldi	r21, 0x44	; 68
    25fe:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2602:	dc 01       	movw	r26, r24
    2604:	cb 01       	movw	r24, r22
    2606:	88 af       	std	Y+56, r24	; 0x38
    2608:	99 af       	std	Y+57, r25	; 0x39
    260a:	aa af       	std	Y+58, r26	; 0x3a
    260c:	bb af       	std	Y+59, r27	; 0x3b
	if (__tmp < 1.0)
    260e:	68 ad       	ldd	r22, Y+56	; 0x38
    2610:	79 ad       	ldd	r23, Y+57	; 0x39
    2612:	8a ad       	ldd	r24, Y+58	; 0x3a
    2614:	9b ad       	ldd	r25, Y+59	; 0x3b
    2616:	20 e0       	ldi	r18, 0x00	; 0
    2618:	30 e0       	ldi	r19, 0x00	; 0
    261a:	40 e8       	ldi	r20, 0x80	; 128
    261c:	5f e3       	ldi	r21, 0x3F	; 63
    261e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2622:	88 23       	and	r24, r24
    2624:	2c f4       	brge	.+10     	; 0x2630 <LCD_write_command_4bit+0x382>
		__ticks = 1;
    2626:	81 e0       	ldi	r24, 0x01	; 1
    2628:	90 e0       	ldi	r25, 0x00	; 0
    262a:	9f ab       	std	Y+55, r25	; 0x37
    262c:	8e ab       	std	Y+54, r24	; 0x36
    262e:	3f c0       	rjmp	.+126    	; 0x26ae <LCD_write_command_4bit+0x400>
	else if (__tmp > 65535)
    2630:	68 ad       	ldd	r22, Y+56	; 0x38
    2632:	79 ad       	ldd	r23, Y+57	; 0x39
    2634:	8a ad       	ldd	r24, Y+58	; 0x3a
    2636:	9b ad       	ldd	r25, Y+59	; 0x3b
    2638:	20 e0       	ldi	r18, 0x00	; 0
    263a:	3f ef       	ldi	r19, 0xFF	; 255
    263c:	4f e7       	ldi	r20, 0x7F	; 127
    263e:	57 e4       	ldi	r21, 0x47	; 71
    2640:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2644:	18 16       	cp	r1, r24
    2646:	4c f5       	brge	.+82     	; 0x269a <LCD_write_command_4bit+0x3ec>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2648:	6c ad       	ldd	r22, Y+60	; 0x3c
    264a:	7d ad       	ldd	r23, Y+61	; 0x3d
    264c:	8e ad       	ldd	r24, Y+62	; 0x3e
    264e:	9f ad       	ldd	r25, Y+63	; 0x3f
    2650:	20 e0       	ldi	r18, 0x00	; 0
    2652:	30 e0       	ldi	r19, 0x00	; 0
    2654:	40 e2       	ldi	r20, 0x20	; 32
    2656:	51 e4       	ldi	r21, 0x41	; 65
    2658:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    265c:	dc 01       	movw	r26, r24
    265e:	cb 01       	movw	r24, r22
    2660:	bc 01       	movw	r22, r24
    2662:	cd 01       	movw	r24, r26
    2664:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2668:	dc 01       	movw	r26, r24
    266a:	cb 01       	movw	r24, r22
    266c:	9f ab       	std	Y+55, r25	; 0x37
    266e:	8e ab       	std	Y+54, r24	; 0x36
    2670:	0f c0       	rjmp	.+30     	; 0x2690 <LCD_write_command_4bit+0x3e2>
    2672:	88 ec       	ldi	r24, 0xC8	; 200
    2674:	90 e0       	ldi	r25, 0x00	; 0
    2676:	9d ab       	std	Y+53, r25	; 0x35
    2678:	8c ab       	std	Y+52, r24	; 0x34
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    267a:	8c a9       	ldd	r24, Y+52	; 0x34
    267c:	9d a9       	ldd	r25, Y+53	; 0x35
    267e:	01 97       	sbiw	r24, 0x01	; 1
    2680:	f1 f7       	brne	.-4      	; 0x267e <LCD_write_command_4bit+0x3d0>
    2682:	9d ab       	std	Y+53, r25	; 0x35
    2684:	8c ab       	std	Y+52, r24	; 0x34
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2686:	8e a9       	ldd	r24, Y+54	; 0x36
    2688:	9f a9       	ldd	r25, Y+55	; 0x37
    268a:	01 97       	sbiw	r24, 0x01	; 1
    268c:	9f ab       	std	Y+55, r25	; 0x37
    268e:	8e ab       	std	Y+54, r24	; 0x36
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2690:	8e a9       	ldd	r24, Y+54	; 0x36
    2692:	9f a9       	ldd	r25, Y+55	; 0x37
    2694:	00 97       	sbiw	r24, 0x00	; 0
    2696:	69 f7       	brne	.-38     	; 0x2672 <LCD_write_command_4bit+0x3c4>
    2698:	2d c0       	rjmp	.+90     	; 0x26f4 <LCD_write_command_4bit+0x446>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    269a:	68 ad       	ldd	r22, Y+56	; 0x38
    269c:	79 ad       	ldd	r23, Y+57	; 0x39
    269e:	8a ad       	ldd	r24, Y+58	; 0x3a
    26a0:	9b ad       	ldd	r25, Y+59	; 0x3b
    26a2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    26a6:	dc 01       	movw	r26, r24
    26a8:	cb 01       	movw	r24, r22
    26aa:	9f ab       	std	Y+55, r25	; 0x37
    26ac:	8e ab       	std	Y+54, r24	; 0x36
    26ae:	8e a9       	ldd	r24, Y+54	; 0x36
    26b0:	9f a9       	ldd	r25, Y+55	; 0x37
    26b2:	9b ab       	std	Y+51, r25	; 0x33
    26b4:	8a ab       	std	Y+50, r24	; 0x32
    26b6:	8a a9       	ldd	r24, Y+50	; 0x32
    26b8:	9b a9       	ldd	r25, Y+51	; 0x33
    26ba:	01 97       	sbiw	r24, 0x01	; 1
    26bc:	f1 f7       	brne	.-4      	; 0x26ba <LCD_write_command_4bit+0x40c>
    26be:	9b ab       	std	Y+51, r25	; 0x33
    26c0:	8a ab       	std	Y+50, r24	; 0x32
    26c2:	18 c0       	rjmp	.+48     	; 0x26f4 <LCD_write_command_4bit+0x446>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    26c4:	fe 01       	movw	r30, r28
    26c6:	ef 5b       	subi	r30, 0xBF	; 191
    26c8:	ff 4f       	sbci	r31, 0xFF	; 255
    26ca:	60 81       	ld	r22, Z
    26cc:	71 81       	ldd	r23, Z+1	; 0x01
    26ce:	82 81       	ldd	r24, Z+2	; 0x02
    26d0:	93 81       	ldd	r25, Z+3	; 0x03
    26d2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    26d6:	dc 01       	movw	r26, r24
    26d8:	cb 01       	movw	r24, r22
    26da:	fe 01       	movw	r30, r28
    26dc:	e0 5c       	subi	r30, 0xC0	; 192
    26de:	ff 4f       	sbci	r31, 0xFF	; 255
    26e0:	80 83       	st	Z, r24
    26e2:	fe 01       	movw	r30, r28
    26e4:	e0 5c       	subi	r30, 0xC0	; 192
    26e6:	ff 4f       	sbci	r31, 0xFF	; 255
    26e8:	80 81       	ld	r24, Z
    26ea:	89 ab       	std	Y+49, r24	; 0x31
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    26ec:	89 a9       	ldd	r24, Y+49	; 0x31
    26ee:	8a 95       	dec	r24
    26f0:	f1 f7       	brne	.-4      	; 0x26ee <LCD_write_command_4bit+0x440>
    26f2:	89 ab       	std	Y+49, r24	; 0x31
	 *  any change in this sequence will result in a wrong behavior
	 *  i will try to make it more generic in the next versions
	 *
	 */

	for(u8 i = 4; i < 8; i++){
    26f4:	fe 01       	movw	r30, r28
    26f6:	ee 59       	subi	r30, 0x9E	; 158
    26f8:	ff 4f       	sbci	r31, 0xFF	; 255
    26fa:	84 e0       	ldi	r24, 0x04	; 4
    26fc:	80 83       	st	Z, r24
    26fe:	26 c0       	rjmp	.+76     	; 0x274c <LCD_write_command_4bit+0x49e>

		DIO_void_assign_pin(lcd_data_port, i, get_Bit(copy_command_4bit,i));
    2700:	fe 01       	movw	r30, r28
    2702:	ed 59       	subi	r30, 0x9D	; 157
    2704:	ff 4f       	sbci	r31, 0xFF	; 255
    2706:	80 81       	ld	r24, Z
    2708:	28 2f       	mov	r18, r24
    270a:	30 e0       	ldi	r19, 0x00	; 0
    270c:	fe 01       	movw	r30, r28
    270e:	ee 59       	subi	r30, 0x9E	; 158
    2710:	ff 4f       	sbci	r31, 0xFF	; 255
    2712:	80 81       	ld	r24, Z
    2714:	88 2f       	mov	r24, r24
    2716:	90 e0       	ldi	r25, 0x00	; 0
    2718:	a9 01       	movw	r20, r18
    271a:	02 c0       	rjmp	.+4      	; 0x2720 <LCD_write_command_4bit+0x472>
    271c:	55 95       	asr	r21
    271e:	47 95       	ror	r20
    2720:	8a 95       	dec	r24
    2722:	e2 f7       	brpl	.-8      	; 0x271c <LCD_write_command_4bit+0x46e>
    2724:	ca 01       	movw	r24, r20
    2726:	98 2f       	mov	r25, r24
    2728:	91 70       	andi	r25, 0x01	; 1
    272a:	fe 01       	movw	r30, r28
    272c:	ee 59       	subi	r30, 0x9E	; 158
    272e:	ff 4f       	sbci	r31, 0xFF	; 255
    2730:	82 e0       	ldi	r24, 0x02	; 2
    2732:	60 81       	ld	r22, Z
    2734:	49 2f       	mov	r20, r25
    2736:	0e 94 b1 08 	call	0x1162	; 0x1162 <DIO_void_assign_pin>
	 *  any change in this sequence will result in a wrong behavior
	 *  i will try to make it more generic in the next versions
	 *
	 */

	for(u8 i = 4; i < 8; i++){
    273a:	de 01       	movw	r26, r28
    273c:	ae 59       	subi	r26, 0x9E	; 158
    273e:	bf 4f       	sbci	r27, 0xFF	; 255
    2740:	fe 01       	movw	r30, r28
    2742:	ee 59       	subi	r30, 0x9E	; 158
    2744:	ff 4f       	sbci	r31, 0xFF	; 255
    2746:	80 81       	ld	r24, Z
    2748:	8f 5f       	subi	r24, 0xFF	; 255
    274a:	8c 93       	st	X, r24
    274c:	fe 01       	movw	r30, r28
    274e:	ee 59       	subi	r30, 0x9E	; 158
    2750:	ff 4f       	sbci	r31, 0xFF	; 255
    2752:	80 81       	ld	r24, Z
    2754:	88 30       	cpi	r24, 0x08	; 8
    2756:	a0 f2       	brcs	.-88     	; 0x2700 <LCD_write_command_4bit+0x452>
		// the for loop assigns the data value in the function input
		// by starting by the most significant 4 bits b4-b7

	}
	// set enable to low to send the lower nibble
	DIO_void_clear_pin(lcd_control_port, lcd_enable);
    2758:	83 e0       	ldi	r24, 0x03	; 3
    275a:	60 e0       	ldi	r22, 0x00	; 0
    275c:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>
    2760:	80 e0       	ldi	r24, 0x00	; 0
    2762:	90 e0       	ldi	r25, 0x00	; 0
    2764:	a0 e2       	ldi	r26, 0x20	; 32
    2766:	b1 e4       	ldi	r27, 0x41	; 65
    2768:	8d a7       	std	Y+45, r24	; 0x2d
    276a:	9e a7       	std	Y+46, r25	; 0x2e
    276c:	af a7       	std	Y+47, r26	; 0x2f
    276e:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    2770:	6d a5       	ldd	r22, Y+45	; 0x2d
    2772:	7e a5       	ldd	r23, Y+46	; 0x2e
    2774:	8f a5       	ldd	r24, Y+47	; 0x2f
    2776:	98 a9       	ldd	r25, Y+48	; 0x30
    2778:	2b ea       	ldi	r18, 0xAB	; 171
    277a:	3a ea       	ldi	r19, 0xAA	; 170
    277c:	4a e2       	ldi	r20, 0x2A	; 42
    277e:	50 e4       	ldi	r21, 0x40	; 64
    2780:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2784:	dc 01       	movw	r26, r24
    2786:	cb 01       	movw	r24, r22
    2788:	89 a7       	std	Y+41, r24	; 0x29
    278a:	9a a7       	std	Y+42, r25	; 0x2a
    278c:	ab a7       	std	Y+43, r26	; 0x2b
    278e:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    2790:	69 a5       	ldd	r22, Y+41	; 0x29
    2792:	7a a5       	ldd	r23, Y+42	; 0x2a
    2794:	8b a5       	ldd	r24, Y+43	; 0x2b
    2796:	9c a5       	ldd	r25, Y+44	; 0x2c
    2798:	20 e0       	ldi	r18, 0x00	; 0
    279a:	30 e0       	ldi	r19, 0x00	; 0
    279c:	40 e8       	ldi	r20, 0x80	; 128
    279e:	5f e3       	ldi	r21, 0x3F	; 63
    27a0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    27a4:	88 23       	and	r24, r24
    27a6:	1c f4       	brge	.+6      	; 0x27ae <LCD_write_command_4bit+0x500>
		__ticks = 1;
    27a8:	81 e0       	ldi	r24, 0x01	; 1
    27aa:	88 a7       	std	Y+40, r24	; 0x28
    27ac:	91 c0       	rjmp	.+290    	; 0x28d0 <LCD_write_command_4bit+0x622>
	else if (__tmp > 255)
    27ae:	69 a5       	ldd	r22, Y+41	; 0x29
    27b0:	7a a5       	ldd	r23, Y+42	; 0x2a
    27b2:	8b a5       	ldd	r24, Y+43	; 0x2b
    27b4:	9c a5       	ldd	r25, Y+44	; 0x2c
    27b6:	20 e0       	ldi	r18, 0x00	; 0
    27b8:	30 e0       	ldi	r19, 0x00	; 0
    27ba:	4f e7       	ldi	r20, 0x7F	; 127
    27bc:	53 e4       	ldi	r21, 0x43	; 67
    27be:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    27c2:	18 16       	cp	r1, r24
    27c4:	0c f0       	brlt	.+2      	; 0x27c8 <LCD_write_command_4bit+0x51a>
    27c6:	7b c0       	rjmp	.+246    	; 0x28be <LCD_write_command_4bit+0x610>
	{
		_delay_ms(__us / 1000.0);
    27c8:	6d a5       	ldd	r22, Y+45	; 0x2d
    27ca:	7e a5       	ldd	r23, Y+46	; 0x2e
    27cc:	8f a5       	ldd	r24, Y+47	; 0x2f
    27ce:	98 a9       	ldd	r25, Y+48	; 0x30
    27d0:	20 e0       	ldi	r18, 0x00	; 0
    27d2:	30 e0       	ldi	r19, 0x00	; 0
    27d4:	4a e7       	ldi	r20, 0x7A	; 122
    27d6:	54 e4       	ldi	r21, 0x44	; 68
    27d8:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    27dc:	dc 01       	movw	r26, r24
    27de:	cb 01       	movw	r24, r22
    27e0:	8c a3       	std	Y+36, r24	; 0x24
    27e2:	9d a3       	std	Y+37, r25	; 0x25
    27e4:	ae a3       	std	Y+38, r26	; 0x26
    27e6:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    27e8:	6c a1       	ldd	r22, Y+36	; 0x24
    27ea:	7d a1       	ldd	r23, Y+37	; 0x25
    27ec:	8e a1       	ldd	r24, Y+38	; 0x26
    27ee:	9f a1       	ldd	r25, Y+39	; 0x27
    27f0:	20 e0       	ldi	r18, 0x00	; 0
    27f2:	30 e0       	ldi	r19, 0x00	; 0
    27f4:	4a ef       	ldi	r20, 0xFA	; 250
    27f6:	54 e4       	ldi	r21, 0x44	; 68
    27f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    27fc:	dc 01       	movw	r26, r24
    27fe:	cb 01       	movw	r24, r22
    2800:	88 a3       	std	Y+32, r24	; 0x20
    2802:	99 a3       	std	Y+33, r25	; 0x21
    2804:	aa a3       	std	Y+34, r26	; 0x22
    2806:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    2808:	68 a1       	ldd	r22, Y+32	; 0x20
    280a:	79 a1       	ldd	r23, Y+33	; 0x21
    280c:	8a a1       	ldd	r24, Y+34	; 0x22
    280e:	9b a1       	ldd	r25, Y+35	; 0x23
    2810:	20 e0       	ldi	r18, 0x00	; 0
    2812:	30 e0       	ldi	r19, 0x00	; 0
    2814:	40 e8       	ldi	r20, 0x80	; 128
    2816:	5f e3       	ldi	r21, 0x3F	; 63
    2818:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    281c:	88 23       	and	r24, r24
    281e:	2c f4       	brge	.+10     	; 0x282a <LCD_write_command_4bit+0x57c>
		__ticks = 1;
    2820:	81 e0       	ldi	r24, 0x01	; 1
    2822:	90 e0       	ldi	r25, 0x00	; 0
    2824:	9f 8f       	std	Y+31, r25	; 0x1f
    2826:	8e 8f       	std	Y+30, r24	; 0x1e
    2828:	3f c0       	rjmp	.+126    	; 0x28a8 <LCD_write_command_4bit+0x5fa>
	else if (__tmp > 65535)
    282a:	68 a1       	ldd	r22, Y+32	; 0x20
    282c:	79 a1       	ldd	r23, Y+33	; 0x21
    282e:	8a a1       	ldd	r24, Y+34	; 0x22
    2830:	9b a1       	ldd	r25, Y+35	; 0x23
    2832:	20 e0       	ldi	r18, 0x00	; 0
    2834:	3f ef       	ldi	r19, 0xFF	; 255
    2836:	4f e7       	ldi	r20, 0x7F	; 127
    2838:	57 e4       	ldi	r21, 0x47	; 71
    283a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    283e:	18 16       	cp	r1, r24
    2840:	4c f5       	brge	.+82     	; 0x2894 <LCD_write_command_4bit+0x5e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2842:	6c a1       	ldd	r22, Y+36	; 0x24
    2844:	7d a1       	ldd	r23, Y+37	; 0x25
    2846:	8e a1       	ldd	r24, Y+38	; 0x26
    2848:	9f a1       	ldd	r25, Y+39	; 0x27
    284a:	20 e0       	ldi	r18, 0x00	; 0
    284c:	30 e0       	ldi	r19, 0x00	; 0
    284e:	40 e2       	ldi	r20, 0x20	; 32
    2850:	51 e4       	ldi	r21, 0x41	; 65
    2852:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2856:	dc 01       	movw	r26, r24
    2858:	cb 01       	movw	r24, r22
    285a:	bc 01       	movw	r22, r24
    285c:	cd 01       	movw	r24, r26
    285e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2862:	dc 01       	movw	r26, r24
    2864:	cb 01       	movw	r24, r22
    2866:	9f 8f       	std	Y+31, r25	; 0x1f
    2868:	8e 8f       	std	Y+30, r24	; 0x1e
    286a:	0f c0       	rjmp	.+30     	; 0x288a <LCD_write_command_4bit+0x5dc>
    286c:	88 ec       	ldi	r24, 0xC8	; 200
    286e:	90 e0       	ldi	r25, 0x00	; 0
    2870:	9d 8f       	std	Y+29, r25	; 0x1d
    2872:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2874:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2876:	9d 8d       	ldd	r25, Y+29	; 0x1d
    2878:	01 97       	sbiw	r24, 0x01	; 1
    287a:	f1 f7       	brne	.-4      	; 0x2878 <LCD_write_command_4bit+0x5ca>
    287c:	9d 8f       	std	Y+29, r25	; 0x1d
    287e:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2880:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2882:	9f 8d       	ldd	r25, Y+31	; 0x1f
    2884:	01 97       	sbiw	r24, 0x01	; 1
    2886:	9f 8f       	std	Y+31, r25	; 0x1f
    2888:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    288a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    288c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    288e:	00 97       	sbiw	r24, 0x00	; 0
    2890:	69 f7       	brne	.-38     	; 0x286c <LCD_write_command_4bit+0x5be>
    2892:	24 c0       	rjmp	.+72     	; 0x28dc <LCD_write_command_4bit+0x62e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2894:	68 a1       	ldd	r22, Y+32	; 0x20
    2896:	79 a1       	ldd	r23, Y+33	; 0x21
    2898:	8a a1       	ldd	r24, Y+34	; 0x22
    289a:	9b a1       	ldd	r25, Y+35	; 0x23
    289c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    28a0:	dc 01       	movw	r26, r24
    28a2:	cb 01       	movw	r24, r22
    28a4:	9f 8f       	std	Y+31, r25	; 0x1f
    28a6:	8e 8f       	std	Y+30, r24	; 0x1e
    28a8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    28aa:	9f 8d       	ldd	r25, Y+31	; 0x1f
    28ac:	9b 8f       	std	Y+27, r25	; 0x1b
    28ae:	8a 8f       	std	Y+26, r24	; 0x1a
    28b0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    28b2:	9b 8d       	ldd	r25, Y+27	; 0x1b
    28b4:	01 97       	sbiw	r24, 0x01	; 1
    28b6:	f1 f7       	brne	.-4      	; 0x28b4 <LCD_write_command_4bit+0x606>
    28b8:	9b 8f       	std	Y+27, r25	; 0x1b
    28ba:	8a 8f       	std	Y+26, r24	; 0x1a
    28bc:	0f c0       	rjmp	.+30     	; 0x28dc <LCD_write_command_4bit+0x62e>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    28be:	69 a5       	ldd	r22, Y+41	; 0x29
    28c0:	7a a5       	ldd	r23, Y+42	; 0x2a
    28c2:	8b a5       	ldd	r24, Y+43	; 0x2b
    28c4:	9c a5       	ldd	r25, Y+44	; 0x2c
    28c6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    28ca:	dc 01       	movw	r26, r24
    28cc:	cb 01       	movw	r24, r22
    28ce:	88 a7       	std	Y+40, r24	; 0x28
    28d0:	88 a5       	ldd	r24, Y+40	; 0x28
    28d2:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    28d4:	89 8d       	ldd	r24, Y+25	; 0x19
    28d6:	8a 95       	dec	r24
    28d8:	f1 f7       	brne	.-4      	; 0x28d6 <LCD_write_command_4bit+0x628>
    28da:	89 8f       	std	Y+25, r24	; 0x19
	//delay to smooth things out
	_delay_us(10);
	//enable HIGH
	DIO_void_set_pin(lcd_control_port, lcd_enable);
    28dc:	83 e0       	ldi	r24, 0x03	; 3
    28de:	60 e0       	ldi	r22, 0x00	; 0
    28e0:	0e 94 50 08 	call	0x10a0	; 0x10a0 <DIO_void_set_pin>
    28e4:	80 e0       	ldi	r24, 0x00	; 0
    28e6:	90 e0       	ldi	r25, 0x00	; 0
    28e8:	a0 e8       	ldi	r26, 0x80	; 128
    28ea:	bf e3       	ldi	r27, 0x3F	; 63
    28ec:	8d 8b       	std	Y+21, r24	; 0x15
    28ee:	9e 8b       	std	Y+22, r25	; 0x16
    28f0:	af 8b       	std	Y+23, r26	; 0x17
    28f2:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    28f4:	6d 89       	ldd	r22, Y+21	; 0x15
    28f6:	7e 89       	ldd	r23, Y+22	; 0x16
    28f8:	8f 89       	ldd	r24, Y+23	; 0x17
    28fa:	98 8d       	ldd	r25, Y+24	; 0x18
    28fc:	2b ea       	ldi	r18, 0xAB	; 171
    28fe:	3a ea       	ldi	r19, 0xAA	; 170
    2900:	4a e2       	ldi	r20, 0x2A	; 42
    2902:	50 e4       	ldi	r21, 0x40	; 64
    2904:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2908:	dc 01       	movw	r26, r24
    290a:	cb 01       	movw	r24, r22
    290c:	89 8b       	std	Y+17, r24	; 0x11
    290e:	9a 8b       	std	Y+18, r25	; 0x12
    2910:	ab 8b       	std	Y+19, r26	; 0x13
    2912:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    2914:	69 89       	ldd	r22, Y+17	; 0x11
    2916:	7a 89       	ldd	r23, Y+18	; 0x12
    2918:	8b 89       	ldd	r24, Y+19	; 0x13
    291a:	9c 89       	ldd	r25, Y+20	; 0x14
    291c:	20 e0       	ldi	r18, 0x00	; 0
    291e:	30 e0       	ldi	r19, 0x00	; 0
    2920:	40 e8       	ldi	r20, 0x80	; 128
    2922:	5f e3       	ldi	r21, 0x3F	; 63
    2924:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2928:	88 23       	and	r24, r24
    292a:	1c f4       	brge	.+6      	; 0x2932 <LCD_write_command_4bit+0x684>
		__ticks = 1;
    292c:	81 e0       	ldi	r24, 0x01	; 1
    292e:	88 8b       	std	Y+16, r24	; 0x10
    2930:	91 c0       	rjmp	.+290    	; 0x2a54 <LCD_write_command_4bit+0x7a6>
	else if (__tmp > 255)
    2932:	69 89       	ldd	r22, Y+17	; 0x11
    2934:	7a 89       	ldd	r23, Y+18	; 0x12
    2936:	8b 89       	ldd	r24, Y+19	; 0x13
    2938:	9c 89       	ldd	r25, Y+20	; 0x14
    293a:	20 e0       	ldi	r18, 0x00	; 0
    293c:	30 e0       	ldi	r19, 0x00	; 0
    293e:	4f e7       	ldi	r20, 0x7F	; 127
    2940:	53 e4       	ldi	r21, 0x43	; 67
    2942:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2946:	18 16       	cp	r1, r24
    2948:	0c f0       	brlt	.+2      	; 0x294c <LCD_write_command_4bit+0x69e>
    294a:	7b c0       	rjmp	.+246    	; 0x2a42 <LCD_write_command_4bit+0x794>
	{
		_delay_ms(__us / 1000.0);
    294c:	6d 89       	ldd	r22, Y+21	; 0x15
    294e:	7e 89       	ldd	r23, Y+22	; 0x16
    2950:	8f 89       	ldd	r24, Y+23	; 0x17
    2952:	98 8d       	ldd	r25, Y+24	; 0x18
    2954:	20 e0       	ldi	r18, 0x00	; 0
    2956:	30 e0       	ldi	r19, 0x00	; 0
    2958:	4a e7       	ldi	r20, 0x7A	; 122
    295a:	54 e4       	ldi	r21, 0x44	; 68
    295c:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2960:	dc 01       	movw	r26, r24
    2962:	cb 01       	movw	r24, r22
    2964:	8c 87       	std	Y+12, r24	; 0x0c
    2966:	9d 87       	std	Y+13, r25	; 0x0d
    2968:	ae 87       	std	Y+14, r26	; 0x0e
    296a:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    296c:	6c 85       	ldd	r22, Y+12	; 0x0c
    296e:	7d 85       	ldd	r23, Y+13	; 0x0d
    2970:	8e 85       	ldd	r24, Y+14	; 0x0e
    2972:	9f 85       	ldd	r25, Y+15	; 0x0f
    2974:	20 e0       	ldi	r18, 0x00	; 0
    2976:	30 e0       	ldi	r19, 0x00	; 0
    2978:	4a ef       	ldi	r20, 0xFA	; 250
    297a:	54 e4       	ldi	r21, 0x44	; 68
    297c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2980:	dc 01       	movw	r26, r24
    2982:	cb 01       	movw	r24, r22
    2984:	88 87       	std	Y+8, r24	; 0x08
    2986:	99 87       	std	Y+9, r25	; 0x09
    2988:	aa 87       	std	Y+10, r26	; 0x0a
    298a:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    298c:	68 85       	ldd	r22, Y+8	; 0x08
    298e:	79 85       	ldd	r23, Y+9	; 0x09
    2990:	8a 85       	ldd	r24, Y+10	; 0x0a
    2992:	9b 85       	ldd	r25, Y+11	; 0x0b
    2994:	20 e0       	ldi	r18, 0x00	; 0
    2996:	30 e0       	ldi	r19, 0x00	; 0
    2998:	40 e8       	ldi	r20, 0x80	; 128
    299a:	5f e3       	ldi	r21, 0x3F	; 63
    299c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    29a0:	88 23       	and	r24, r24
    29a2:	2c f4       	brge	.+10     	; 0x29ae <LCD_write_command_4bit+0x700>
		__ticks = 1;
    29a4:	81 e0       	ldi	r24, 0x01	; 1
    29a6:	90 e0       	ldi	r25, 0x00	; 0
    29a8:	9f 83       	std	Y+7, r25	; 0x07
    29aa:	8e 83       	std	Y+6, r24	; 0x06
    29ac:	3f c0       	rjmp	.+126    	; 0x2a2c <LCD_write_command_4bit+0x77e>
	else if (__tmp > 65535)
    29ae:	68 85       	ldd	r22, Y+8	; 0x08
    29b0:	79 85       	ldd	r23, Y+9	; 0x09
    29b2:	8a 85       	ldd	r24, Y+10	; 0x0a
    29b4:	9b 85       	ldd	r25, Y+11	; 0x0b
    29b6:	20 e0       	ldi	r18, 0x00	; 0
    29b8:	3f ef       	ldi	r19, 0xFF	; 255
    29ba:	4f e7       	ldi	r20, 0x7F	; 127
    29bc:	57 e4       	ldi	r21, 0x47	; 71
    29be:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    29c2:	18 16       	cp	r1, r24
    29c4:	4c f5       	brge	.+82     	; 0x2a18 <LCD_write_command_4bit+0x76a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    29c6:	6c 85       	ldd	r22, Y+12	; 0x0c
    29c8:	7d 85       	ldd	r23, Y+13	; 0x0d
    29ca:	8e 85       	ldd	r24, Y+14	; 0x0e
    29cc:	9f 85       	ldd	r25, Y+15	; 0x0f
    29ce:	20 e0       	ldi	r18, 0x00	; 0
    29d0:	30 e0       	ldi	r19, 0x00	; 0
    29d2:	40 e2       	ldi	r20, 0x20	; 32
    29d4:	51 e4       	ldi	r21, 0x41	; 65
    29d6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    29da:	dc 01       	movw	r26, r24
    29dc:	cb 01       	movw	r24, r22
    29de:	bc 01       	movw	r22, r24
    29e0:	cd 01       	movw	r24, r26
    29e2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    29e6:	dc 01       	movw	r26, r24
    29e8:	cb 01       	movw	r24, r22
    29ea:	9f 83       	std	Y+7, r25	; 0x07
    29ec:	8e 83       	std	Y+6, r24	; 0x06
    29ee:	0f c0       	rjmp	.+30     	; 0x2a0e <LCD_write_command_4bit+0x760>
    29f0:	88 ec       	ldi	r24, 0xC8	; 200
    29f2:	90 e0       	ldi	r25, 0x00	; 0
    29f4:	9d 83       	std	Y+5, r25	; 0x05
    29f6:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    29f8:	8c 81       	ldd	r24, Y+4	; 0x04
    29fa:	9d 81       	ldd	r25, Y+5	; 0x05
    29fc:	01 97       	sbiw	r24, 0x01	; 1
    29fe:	f1 f7       	brne	.-4      	; 0x29fc <LCD_write_command_4bit+0x74e>
    2a00:	9d 83       	std	Y+5, r25	; 0x05
    2a02:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2a04:	8e 81       	ldd	r24, Y+6	; 0x06
    2a06:	9f 81       	ldd	r25, Y+7	; 0x07
    2a08:	01 97       	sbiw	r24, 0x01	; 1
    2a0a:	9f 83       	std	Y+7, r25	; 0x07
    2a0c:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2a0e:	8e 81       	ldd	r24, Y+6	; 0x06
    2a10:	9f 81       	ldd	r25, Y+7	; 0x07
    2a12:	00 97       	sbiw	r24, 0x00	; 0
    2a14:	69 f7       	brne	.-38     	; 0x29f0 <LCD_write_command_4bit+0x742>
    2a16:	24 c0       	rjmp	.+72     	; 0x2a60 <LCD_write_command_4bit+0x7b2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2a18:	68 85       	ldd	r22, Y+8	; 0x08
    2a1a:	79 85       	ldd	r23, Y+9	; 0x09
    2a1c:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a1e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2a20:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2a24:	dc 01       	movw	r26, r24
    2a26:	cb 01       	movw	r24, r22
    2a28:	9f 83       	std	Y+7, r25	; 0x07
    2a2a:	8e 83       	std	Y+6, r24	; 0x06
    2a2c:	8e 81       	ldd	r24, Y+6	; 0x06
    2a2e:	9f 81       	ldd	r25, Y+7	; 0x07
    2a30:	9b 83       	std	Y+3, r25	; 0x03
    2a32:	8a 83       	std	Y+2, r24	; 0x02
    2a34:	8a 81       	ldd	r24, Y+2	; 0x02
    2a36:	9b 81       	ldd	r25, Y+3	; 0x03
    2a38:	01 97       	sbiw	r24, 0x01	; 1
    2a3a:	f1 f7       	brne	.-4      	; 0x2a38 <LCD_write_command_4bit+0x78a>
    2a3c:	9b 83       	std	Y+3, r25	; 0x03
    2a3e:	8a 83       	std	Y+2, r24	; 0x02
    2a40:	0f c0       	rjmp	.+30     	; 0x2a60 <LCD_write_command_4bit+0x7b2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2a42:	69 89       	ldd	r22, Y+17	; 0x11
    2a44:	7a 89       	ldd	r23, Y+18	; 0x12
    2a46:	8b 89       	ldd	r24, Y+19	; 0x13
    2a48:	9c 89       	ldd	r25, Y+20	; 0x14
    2a4a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2a4e:	dc 01       	movw	r26, r24
    2a50:	cb 01       	movw	r24, r22
    2a52:	88 8b       	std	Y+16, r24	; 0x10
    2a54:	88 89       	ldd	r24, Y+16	; 0x10
    2a56:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2a58:	89 81       	ldd	r24, Y+1	; 0x01
    2a5a:	8a 95       	dec	r24
    2a5c:	f1 f7       	brne	.-4      	; 0x2a5a <LCD_write_command_4bit+0x7ac>
    2a5e:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(1);
	//send lower nibble
	for(u8 i = 4; i < 8; i++){
    2a60:	fe 01       	movw	r30, r28
    2a62:	ef 59       	subi	r30, 0x9F	; 159
    2a64:	ff 4f       	sbci	r31, 0xFF	; 255
    2a66:	84 e0       	ldi	r24, 0x04	; 4
    2a68:	80 83       	st	Z, r24
    2a6a:	27 c0       	rjmp	.+78     	; 0x2aba <LCD_write_command_4bit+0x80c>

			DIO_void_assign_pin(lcd_data_port, i, get_Bit(copy_command_4bit,i-4));
    2a6c:	fe 01       	movw	r30, r28
    2a6e:	ed 59       	subi	r30, 0x9D	; 157
    2a70:	ff 4f       	sbci	r31, 0xFF	; 255
    2a72:	80 81       	ld	r24, Z
    2a74:	28 2f       	mov	r18, r24
    2a76:	30 e0       	ldi	r19, 0x00	; 0
    2a78:	fe 01       	movw	r30, r28
    2a7a:	ef 59       	subi	r30, 0x9F	; 159
    2a7c:	ff 4f       	sbci	r31, 0xFF	; 255
    2a7e:	80 81       	ld	r24, Z
    2a80:	88 2f       	mov	r24, r24
    2a82:	90 e0       	ldi	r25, 0x00	; 0
    2a84:	04 97       	sbiw	r24, 0x04	; 4
    2a86:	f9 01       	movw	r30, r18
    2a88:	02 c0       	rjmp	.+4      	; 0x2a8e <LCD_write_command_4bit+0x7e0>
    2a8a:	f5 95       	asr	r31
    2a8c:	e7 95       	ror	r30
    2a8e:	8a 95       	dec	r24
    2a90:	e2 f7       	brpl	.-8      	; 0x2a8a <LCD_write_command_4bit+0x7dc>
    2a92:	cf 01       	movw	r24, r30
    2a94:	98 2f       	mov	r25, r24
    2a96:	91 70       	andi	r25, 0x01	; 1
    2a98:	fe 01       	movw	r30, r28
    2a9a:	ef 59       	subi	r30, 0x9F	; 159
    2a9c:	ff 4f       	sbci	r31, 0xFF	; 255
    2a9e:	82 e0       	ldi	r24, 0x02	; 2
    2aa0:	60 81       	ld	r22, Z
    2aa2:	49 2f       	mov	r20, r25
    2aa4:	0e 94 b1 08 	call	0x1162	; 0x1162 <DIO_void_assign_pin>
	_delay_us(10);
	//enable HIGH
	DIO_void_set_pin(lcd_control_port, lcd_enable);
	_delay_us(1);
	//send lower nibble
	for(u8 i = 4; i < 8; i++){
    2aa8:	de 01       	movw	r26, r28
    2aaa:	af 59       	subi	r26, 0x9F	; 159
    2aac:	bf 4f       	sbci	r27, 0xFF	; 255
    2aae:	fe 01       	movw	r30, r28
    2ab0:	ef 59       	subi	r30, 0x9F	; 159
    2ab2:	ff 4f       	sbci	r31, 0xFF	; 255
    2ab4:	80 81       	ld	r24, Z
    2ab6:	8f 5f       	subi	r24, 0xFF	; 255
    2ab8:	8c 93       	st	X, r24
    2aba:	fe 01       	movw	r30, r28
    2abc:	ef 59       	subi	r30, 0x9F	; 159
    2abe:	ff 4f       	sbci	r31, 0xFF	; 255
    2ac0:	80 81       	ld	r24, Z
    2ac2:	88 30       	cpi	r24, 0x08	; 8
    2ac4:	98 f2       	brcs	.-90     	; 0x2a6c <LCD_write_command_4bit+0x7be>
			// the for loop assigns the data value in the function input
			// by starting by the least significant 4 bits b0-b3

		}
	//enable low
	DIO_void_clear_pin(lcd_control_port, lcd_enable);
    2ac6:	83 e0       	ldi	r24, 0x03	; 3
    2ac8:	60 e0       	ldi	r22, 0x00	; 0
    2aca:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>


}
    2ace:	cd 59       	subi	r28, 0x9D	; 157
    2ad0:	df 4f       	sbci	r29, 0xFF	; 255
    2ad2:	0f b6       	in	r0, 0x3f	; 63
    2ad4:	f8 94       	cli
    2ad6:	de bf       	out	0x3e, r29	; 62
    2ad8:	0f be       	out	0x3f, r0	; 63
    2ada:	cd bf       	out	0x3d, r28	; 61
    2adc:	cf 91       	pop	r28
    2ade:	df 91       	pop	r29
    2ae0:	1f 91       	pop	r17
    2ae2:	0f 91       	pop	r16
    2ae4:	08 95       	ret

00002ae6 <LCD_function_Set_4bit>:

static void LCD_function_Set_4bit(){
    2ae6:	0f 93       	push	r16
    2ae8:	1f 93       	push	r17
    2aea:	df 93       	push	r29
    2aec:	cf 93       	push	r28
    2aee:	cd b7       	in	r28, 0x3d	; 61
    2af0:	de b7       	in	r29, 0x3e	; 62
    2af2:	cb 5a       	subi	r28, 0xAB	; 171
    2af4:	d0 40       	sbci	r29, 0x00	; 0
    2af6:	0f b6       	in	r0, 0x3f	; 63
    2af8:	f8 94       	cli
    2afa:	de bf       	out	0x3e, r29	; 62
    2afc:	0f be       	out	0x3f, r0	; 63
    2afe:	cd bf       	out	0x3d, r28	; 61
			 *
			 */



	DIO_void_clear_pin(lcd_control_port, lcd_RS);// RS:0 to select instruction register
    2b00:	83 e0       	ldi	r24, 0x03	; 3
    2b02:	62 e0       	ldi	r22, 0x02	; 2
    2b04:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>
	DIO_void_clear_pin(lcd_control_port, lcd_RW);// RW:0 write operation
    2b08:	83 e0       	ldi	r24, 0x03	; 3
    2b0a:	61 e0       	ldi	r22, 0x01	; 1
    2b0c:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>
    2b10:	fe 01       	movw	r30, r28
    2b12:	eb 55       	subi	r30, 0x5B	; 91
    2b14:	ff 4f       	sbci	r31, 0xFF	; 255
    2b16:	80 e0       	ldi	r24, 0x00	; 0
    2b18:	90 e0       	ldi	r25, 0x00	; 0
    2b1a:	a0 e8       	ldi	r26, 0x80	; 128
    2b1c:	bf e3       	ldi	r27, 0x3F	; 63
    2b1e:	80 83       	st	Z, r24
    2b20:	91 83       	std	Z+1, r25	; 0x01
    2b22:	a2 83       	std	Z+2, r26	; 0x02
    2b24:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    2b26:	8e 01       	movw	r16, r28
    2b28:	0f 55       	subi	r16, 0x5F	; 95
    2b2a:	1f 4f       	sbci	r17, 0xFF	; 255
    2b2c:	fe 01       	movw	r30, r28
    2b2e:	eb 55       	subi	r30, 0x5B	; 91
    2b30:	ff 4f       	sbci	r31, 0xFF	; 255
    2b32:	60 81       	ld	r22, Z
    2b34:	71 81       	ldd	r23, Z+1	; 0x01
    2b36:	82 81       	ldd	r24, Z+2	; 0x02
    2b38:	93 81       	ldd	r25, Z+3	; 0x03
    2b3a:	2b ea       	ldi	r18, 0xAB	; 171
    2b3c:	3a ea       	ldi	r19, 0xAA	; 170
    2b3e:	4a e2       	ldi	r20, 0x2A	; 42
    2b40:	50 e4       	ldi	r21, 0x40	; 64
    2b42:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2b46:	dc 01       	movw	r26, r24
    2b48:	cb 01       	movw	r24, r22
    2b4a:	f8 01       	movw	r30, r16
    2b4c:	80 83       	st	Z, r24
    2b4e:	91 83       	std	Z+1, r25	; 0x01
    2b50:	a2 83       	std	Z+2, r26	; 0x02
    2b52:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    2b54:	fe 01       	movw	r30, r28
    2b56:	ef 55       	subi	r30, 0x5F	; 95
    2b58:	ff 4f       	sbci	r31, 0xFF	; 255
    2b5a:	60 81       	ld	r22, Z
    2b5c:	71 81       	ldd	r23, Z+1	; 0x01
    2b5e:	82 81       	ldd	r24, Z+2	; 0x02
    2b60:	93 81       	ldd	r25, Z+3	; 0x03
    2b62:	20 e0       	ldi	r18, 0x00	; 0
    2b64:	30 e0       	ldi	r19, 0x00	; 0
    2b66:	40 e8       	ldi	r20, 0x80	; 128
    2b68:	5f e3       	ldi	r21, 0x3F	; 63
    2b6a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2b6e:	88 23       	and	r24, r24
    2b70:	34 f4       	brge	.+12     	; 0x2b7e <LCD_function_Set_4bit+0x98>
		__ticks = 1;
    2b72:	fe 01       	movw	r30, r28
    2b74:	e0 56       	subi	r30, 0x60	; 96
    2b76:	ff 4f       	sbci	r31, 0xFF	; 255
    2b78:	81 e0       	ldi	r24, 0x01	; 1
    2b7a:	80 83       	st	Z, r24
    2b7c:	e0 c0       	rjmp	.+448    	; 0x2d3e <LCD_function_Set_4bit+0x258>
	else if (__tmp > 255)
    2b7e:	fe 01       	movw	r30, r28
    2b80:	ef 55       	subi	r30, 0x5F	; 95
    2b82:	ff 4f       	sbci	r31, 0xFF	; 255
    2b84:	60 81       	ld	r22, Z
    2b86:	71 81       	ldd	r23, Z+1	; 0x01
    2b88:	82 81       	ldd	r24, Z+2	; 0x02
    2b8a:	93 81       	ldd	r25, Z+3	; 0x03
    2b8c:	20 e0       	ldi	r18, 0x00	; 0
    2b8e:	30 e0       	ldi	r19, 0x00	; 0
    2b90:	4f e7       	ldi	r20, 0x7F	; 127
    2b92:	53 e4       	ldi	r21, 0x43	; 67
    2b94:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2b98:	18 16       	cp	r1, r24
    2b9a:	0c f0       	brlt	.+2      	; 0x2b9e <LCD_function_Set_4bit+0xb8>
    2b9c:	c0 c0       	rjmp	.+384    	; 0x2d1e <LCD_function_Set_4bit+0x238>
	{
		_delay_ms(__us / 1000.0);
    2b9e:	fe 01       	movw	r30, r28
    2ba0:	eb 55       	subi	r30, 0x5B	; 91
    2ba2:	ff 4f       	sbci	r31, 0xFF	; 255
    2ba4:	60 81       	ld	r22, Z
    2ba6:	71 81       	ldd	r23, Z+1	; 0x01
    2ba8:	82 81       	ldd	r24, Z+2	; 0x02
    2baa:	93 81       	ldd	r25, Z+3	; 0x03
    2bac:	20 e0       	ldi	r18, 0x00	; 0
    2bae:	30 e0       	ldi	r19, 0x00	; 0
    2bb0:	4a e7       	ldi	r20, 0x7A	; 122
    2bb2:	54 e4       	ldi	r21, 0x44	; 68
    2bb4:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2bb8:	dc 01       	movw	r26, r24
    2bba:	cb 01       	movw	r24, r22
    2bbc:	fe 01       	movw	r30, r28
    2bbe:	e4 56       	subi	r30, 0x64	; 100
    2bc0:	ff 4f       	sbci	r31, 0xFF	; 255
    2bc2:	80 83       	st	Z, r24
    2bc4:	91 83       	std	Z+1, r25	; 0x01
    2bc6:	a2 83       	std	Z+2, r26	; 0x02
    2bc8:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2bca:	8e 01       	movw	r16, r28
    2bcc:	08 56       	subi	r16, 0x68	; 104
    2bce:	1f 4f       	sbci	r17, 0xFF	; 255
    2bd0:	fe 01       	movw	r30, r28
    2bd2:	e4 56       	subi	r30, 0x64	; 100
    2bd4:	ff 4f       	sbci	r31, 0xFF	; 255
    2bd6:	60 81       	ld	r22, Z
    2bd8:	71 81       	ldd	r23, Z+1	; 0x01
    2bda:	82 81       	ldd	r24, Z+2	; 0x02
    2bdc:	93 81       	ldd	r25, Z+3	; 0x03
    2bde:	20 e0       	ldi	r18, 0x00	; 0
    2be0:	30 e0       	ldi	r19, 0x00	; 0
    2be2:	4a ef       	ldi	r20, 0xFA	; 250
    2be4:	54 e4       	ldi	r21, 0x44	; 68
    2be6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2bea:	dc 01       	movw	r26, r24
    2bec:	cb 01       	movw	r24, r22
    2bee:	f8 01       	movw	r30, r16
    2bf0:	80 83       	st	Z, r24
    2bf2:	91 83       	std	Z+1, r25	; 0x01
    2bf4:	a2 83       	std	Z+2, r26	; 0x02
    2bf6:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    2bf8:	fe 01       	movw	r30, r28
    2bfa:	e8 56       	subi	r30, 0x68	; 104
    2bfc:	ff 4f       	sbci	r31, 0xFF	; 255
    2bfe:	60 81       	ld	r22, Z
    2c00:	71 81       	ldd	r23, Z+1	; 0x01
    2c02:	82 81       	ldd	r24, Z+2	; 0x02
    2c04:	93 81       	ldd	r25, Z+3	; 0x03
    2c06:	20 e0       	ldi	r18, 0x00	; 0
    2c08:	30 e0       	ldi	r19, 0x00	; 0
    2c0a:	40 e8       	ldi	r20, 0x80	; 128
    2c0c:	5f e3       	ldi	r21, 0x3F	; 63
    2c0e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2c12:	88 23       	and	r24, r24
    2c14:	44 f4       	brge	.+16     	; 0x2c26 <LCD_function_Set_4bit+0x140>
		__ticks = 1;
    2c16:	fe 01       	movw	r30, r28
    2c18:	ea 56       	subi	r30, 0x6A	; 106
    2c1a:	ff 4f       	sbci	r31, 0xFF	; 255
    2c1c:	81 e0       	ldi	r24, 0x01	; 1
    2c1e:	90 e0       	ldi	r25, 0x00	; 0
    2c20:	91 83       	std	Z+1, r25	; 0x01
    2c22:	80 83       	st	Z, r24
    2c24:	64 c0       	rjmp	.+200    	; 0x2cee <LCD_function_Set_4bit+0x208>
	else if (__tmp > 65535)
    2c26:	fe 01       	movw	r30, r28
    2c28:	e8 56       	subi	r30, 0x68	; 104
    2c2a:	ff 4f       	sbci	r31, 0xFF	; 255
    2c2c:	60 81       	ld	r22, Z
    2c2e:	71 81       	ldd	r23, Z+1	; 0x01
    2c30:	82 81       	ldd	r24, Z+2	; 0x02
    2c32:	93 81       	ldd	r25, Z+3	; 0x03
    2c34:	20 e0       	ldi	r18, 0x00	; 0
    2c36:	3f ef       	ldi	r19, 0xFF	; 255
    2c38:	4f e7       	ldi	r20, 0x7F	; 127
    2c3a:	57 e4       	ldi	r21, 0x47	; 71
    2c3c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2c40:	18 16       	cp	r1, r24
    2c42:	0c f0       	brlt	.+2      	; 0x2c46 <LCD_function_Set_4bit+0x160>
    2c44:	43 c0       	rjmp	.+134    	; 0x2ccc <LCD_function_Set_4bit+0x1e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2c46:	fe 01       	movw	r30, r28
    2c48:	e4 56       	subi	r30, 0x64	; 100
    2c4a:	ff 4f       	sbci	r31, 0xFF	; 255
    2c4c:	60 81       	ld	r22, Z
    2c4e:	71 81       	ldd	r23, Z+1	; 0x01
    2c50:	82 81       	ldd	r24, Z+2	; 0x02
    2c52:	93 81       	ldd	r25, Z+3	; 0x03
    2c54:	20 e0       	ldi	r18, 0x00	; 0
    2c56:	30 e0       	ldi	r19, 0x00	; 0
    2c58:	40 e2       	ldi	r20, 0x20	; 32
    2c5a:	51 e4       	ldi	r21, 0x41	; 65
    2c5c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2c60:	dc 01       	movw	r26, r24
    2c62:	cb 01       	movw	r24, r22
    2c64:	8e 01       	movw	r16, r28
    2c66:	0a 56       	subi	r16, 0x6A	; 106
    2c68:	1f 4f       	sbci	r17, 0xFF	; 255
    2c6a:	bc 01       	movw	r22, r24
    2c6c:	cd 01       	movw	r24, r26
    2c6e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2c72:	dc 01       	movw	r26, r24
    2c74:	cb 01       	movw	r24, r22
    2c76:	f8 01       	movw	r30, r16
    2c78:	91 83       	std	Z+1, r25	; 0x01
    2c7a:	80 83       	st	Z, r24
    2c7c:	1f c0       	rjmp	.+62     	; 0x2cbc <LCD_function_Set_4bit+0x1d6>
    2c7e:	fe 01       	movw	r30, r28
    2c80:	ec 56       	subi	r30, 0x6C	; 108
    2c82:	ff 4f       	sbci	r31, 0xFF	; 255
    2c84:	88 ec       	ldi	r24, 0xC8	; 200
    2c86:	90 e0       	ldi	r25, 0x00	; 0
    2c88:	91 83       	std	Z+1, r25	; 0x01
    2c8a:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2c8c:	fe 01       	movw	r30, r28
    2c8e:	ec 56       	subi	r30, 0x6C	; 108
    2c90:	ff 4f       	sbci	r31, 0xFF	; 255
    2c92:	80 81       	ld	r24, Z
    2c94:	91 81       	ldd	r25, Z+1	; 0x01
    2c96:	01 97       	sbiw	r24, 0x01	; 1
    2c98:	f1 f7       	brne	.-4      	; 0x2c96 <LCD_function_Set_4bit+0x1b0>
    2c9a:	fe 01       	movw	r30, r28
    2c9c:	ec 56       	subi	r30, 0x6C	; 108
    2c9e:	ff 4f       	sbci	r31, 0xFF	; 255
    2ca0:	91 83       	std	Z+1, r25	; 0x01
    2ca2:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2ca4:	de 01       	movw	r26, r28
    2ca6:	aa 56       	subi	r26, 0x6A	; 106
    2ca8:	bf 4f       	sbci	r27, 0xFF	; 255
    2caa:	fe 01       	movw	r30, r28
    2cac:	ea 56       	subi	r30, 0x6A	; 106
    2cae:	ff 4f       	sbci	r31, 0xFF	; 255
    2cb0:	80 81       	ld	r24, Z
    2cb2:	91 81       	ldd	r25, Z+1	; 0x01
    2cb4:	01 97       	sbiw	r24, 0x01	; 1
    2cb6:	11 96       	adiw	r26, 0x01	; 1
    2cb8:	9c 93       	st	X, r25
    2cba:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2cbc:	fe 01       	movw	r30, r28
    2cbe:	ea 56       	subi	r30, 0x6A	; 106
    2cc0:	ff 4f       	sbci	r31, 0xFF	; 255
    2cc2:	80 81       	ld	r24, Z
    2cc4:	91 81       	ldd	r25, Z+1	; 0x01
    2cc6:	00 97       	sbiw	r24, 0x00	; 0
    2cc8:	d1 f6       	brne	.-76     	; 0x2c7e <LCD_function_Set_4bit+0x198>
    2cca:	4b c0       	rjmp	.+150    	; 0x2d62 <LCD_function_Set_4bit+0x27c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2ccc:	8e 01       	movw	r16, r28
    2cce:	0a 56       	subi	r16, 0x6A	; 106
    2cd0:	1f 4f       	sbci	r17, 0xFF	; 255
    2cd2:	fe 01       	movw	r30, r28
    2cd4:	e8 56       	subi	r30, 0x68	; 104
    2cd6:	ff 4f       	sbci	r31, 0xFF	; 255
    2cd8:	60 81       	ld	r22, Z
    2cda:	71 81       	ldd	r23, Z+1	; 0x01
    2cdc:	82 81       	ldd	r24, Z+2	; 0x02
    2cde:	93 81       	ldd	r25, Z+3	; 0x03
    2ce0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2ce4:	dc 01       	movw	r26, r24
    2ce6:	cb 01       	movw	r24, r22
    2ce8:	f8 01       	movw	r30, r16
    2cea:	91 83       	std	Z+1, r25	; 0x01
    2cec:	80 83       	st	Z, r24
    2cee:	de 01       	movw	r26, r28
    2cf0:	ae 56       	subi	r26, 0x6E	; 110
    2cf2:	bf 4f       	sbci	r27, 0xFF	; 255
    2cf4:	fe 01       	movw	r30, r28
    2cf6:	ea 56       	subi	r30, 0x6A	; 106
    2cf8:	ff 4f       	sbci	r31, 0xFF	; 255
    2cfa:	80 81       	ld	r24, Z
    2cfc:	91 81       	ldd	r25, Z+1	; 0x01
    2cfe:	11 96       	adiw	r26, 0x01	; 1
    2d00:	9c 93       	st	X, r25
    2d02:	8e 93       	st	-X, r24
    2d04:	fe 01       	movw	r30, r28
    2d06:	ee 56       	subi	r30, 0x6E	; 110
    2d08:	ff 4f       	sbci	r31, 0xFF	; 255
    2d0a:	80 81       	ld	r24, Z
    2d0c:	91 81       	ldd	r25, Z+1	; 0x01
    2d0e:	01 97       	sbiw	r24, 0x01	; 1
    2d10:	f1 f7       	brne	.-4      	; 0x2d0e <LCD_function_Set_4bit+0x228>
    2d12:	fe 01       	movw	r30, r28
    2d14:	ee 56       	subi	r30, 0x6E	; 110
    2d16:	ff 4f       	sbci	r31, 0xFF	; 255
    2d18:	91 83       	std	Z+1, r25	; 0x01
    2d1a:	80 83       	st	Z, r24
    2d1c:	22 c0       	rjmp	.+68     	; 0x2d62 <LCD_function_Set_4bit+0x27c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2d1e:	8e 01       	movw	r16, r28
    2d20:	00 56       	subi	r16, 0x60	; 96
    2d22:	1f 4f       	sbci	r17, 0xFF	; 255
    2d24:	fe 01       	movw	r30, r28
    2d26:	ef 55       	subi	r30, 0x5F	; 95
    2d28:	ff 4f       	sbci	r31, 0xFF	; 255
    2d2a:	60 81       	ld	r22, Z
    2d2c:	71 81       	ldd	r23, Z+1	; 0x01
    2d2e:	82 81       	ldd	r24, Z+2	; 0x02
    2d30:	93 81       	ldd	r25, Z+3	; 0x03
    2d32:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2d36:	dc 01       	movw	r26, r24
    2d38:	cb 01       	movw	r24, r22
    2d3a:	f8 01       	movw	r30, r16
    2d3c:	80 83       	st	Z, r24
    2d3e:	de 01       	movw	r26, r28
    2d40:	af 56       	subi	r26, 0x6F	; 111
    2d42:	bf 4f       	sbci	r27, 0xFF	; 255
    2d44:	fe 01       	movw	r30, r28
    2d46:	e0 56       	subi	r30, 0x60	; 96
    2d48:	ff 4f       	sbci	r31, 0xFF	; 255
    2d4a:	80 81       	ld	r24, Z
    2d4c:	8c 93       	st	X, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2d4e:	fe 01       	movw	r30, r28
    2d50:	ef 56       	subi	r30, 0x6F	; 111
    2d52:	ff 4f       	sbci	r31, 0xFF	; 255
    2d54:	80 81       	ld	r24, Z
    2d56:	8a 95       	dec	r24
    2d58:	f1 f7       	brne	.-4      	; 0x2d56 <LCD_function_Set_4bit+0x270>
    2d5a:	fe 01       	movw	r30, r28
    2d5c:	ef 56       	subi	r30, 0x6F	; 111
    2d5e:	ff 4f       	sbci	r31, 0xFF	; 255
    2d60:	80 83       	st	Z, r24
	_delay_us(1);
	DIO_void_set_pin(lcd_control_port, lcd_enable); // enable high
    2d62:	83 e0       	ldi	r24, 0x03	; 3
    2d64:	60 e0       	ldi	r22, 0x00	; 0
    2d66:	0e 94 50 08 	call	0x10a0	; 0x10a0 <DIO_void_set_pin>
    2d6a:	fe 01       	movw	r30, r28
    2d6c:	e3 57       	subi	r30, 0x73	; 115
    2d6e:	ff 4f       	sbci	r31, 0xFF	; 255
    2d70:	80 e0       	ldi	r24, 0x00	; 0
    2d72:	90 e0       	ldi	r25, 0x00	; 0
    2d74:	a0 e8       	ldi	r26, 0x80	; 128
    2d76:	bf e3       	ldi	r27, 0x3F	; 63
    2d78:	80 83       	st	Z, r24
    2d7a:	91 83       	std	Z+1, r25	; 0x01
    2d7c:	a2 83       	std	Z+2, r26	; 0x02
    2d7e:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    2d80:	8e 01       	movw	r16, r28
    2d82:	07 57       	subi	r16, 0x77	; 119
    2d84:	1f 4f       	sbci	r17, 0xFF	; 255
    2d86:	fe 01       	movw	r30, r28
    2d88:	e3 57       	subi	r30, 0x73	; 115
    2d8a:	ff 4f       	sbci	r31, 0xFF	; 255
    2d8c:	60 81       	ld	r22, Z
    2d8e:	71 81       	ldd	r23, Z+1	; 0x01
    2d90:	82 81       	ldd	r24, Z+2	; 0x02
    2d92:	93 81       	ldd	r25, Z+3	; 0x03
    2d94:	2b ea       	ldi	r18, 0xAB	; 171
    2d96:	3a ea       	ldi	r19, 0xAA	; 170
    2d98:	4a e2       	ldi	r20, 0x2A	; 42
    2d9a:	50 e4       	ldi	r21, 0x40	; 64
    2d9c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2da0:	dc 01       	movw	r26, r24
    2da2:	cb 01       	movw	r24, r22
    2da4:	f8 01       	movw	r30, r16
    2da6:	80 83       	st	Z, r24
    2da8:	91 83       	std	Z+1, r25	; 0x01
    2daa:	a2 83       	std	Z+2, r26	; 0x02
    2dac:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    2dae:	fe 01       	movw	r30, r28
    2db0:	e7 57       	subi	r30, 0x77	; 119
    2db2:	ff 4f       	sbci	r31, 0xFF	; 255
    2db4:	60 81       	ld	r22, Z
    2db6:	71 81       	ldd	r23, Z+1	; 0x01
    2db8:	82 81       	ldd	r24, Z+2	; 0x02
    2dba:	93 81       	ldd	r25, Z+3	; 0x03
    2dbc:	20 e0       	ldi	r18, 0x00	; 0
    2dbe:	30 e0       	ldi	r19, 0x00	; 0
    2dc0:	40 e8       	ldi	r20, 0x80	; 128
    2dc2:	5f e3       	ldi	r21, 0x3F	; 63
    2dc4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2dc8:	88 23       	and	r24, r24
    2dca:	34 f4       	brge	.+12     	; 0x2dd8 <LCD_function_Set_4bit+0x2f2>
		__ticks = 1;
    2dcc:	fe 01       	movw	r30, r28
    2dce:	e8 57       	subi	r30, 0x78	; 120
    2dd0:	ff 4f       	sbci	r31, 0xFF	; 255
    2dd2:	81 e0       	ldi	r24, 0x01	; 1
    2dd4:	80 83       	st	Z, r24
    2dd6:	e0 c0       	rjmp	.+448    	; 0x2f98 <LCD_function_Set_4bit+0x4b2>
	else if (__tmp > 255)
    2dd8:	fe 01       	movw	r30, r28
    2dda:	e7 57       	subi	r30, 0x77	; 119
    2ddc:	ff 4f       	sbci	r31, 0xFF	; 255
    2dde:	60 81       	ld	r22, Z
    2de0:	71 81       	ldd	r23, Z+1	; 0x01
    2de2:	82 81       	ldd	r24, Z+2	; 0x02
    2de4:	93 81       	ldd	r25, Z+3	; 0x03
    2de6:	20 e0       	ldi	r18, 0x00	; 0
    2de8:	30 e0       	ldi	r19, 0x00	; 0
    2dea:	4f e7       	ldi	r20, 0x7F	; 127
    2dec:	53 e4       	ldi	r21, 0x43	; 67
    2dee:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2df2:	18 16       	cp	r1, r24
    2df4:	0c f0       	brlt	.+2      	; 0x2df8 <LCD_function_Set_4bit+0x312>
    2df6:	c0 c0       	rjmp	.+384    	; 0x2f78 <LCD_function_Set_4bit+0x492>
	{
		_delay_ms(__us / 1000.0);
    2df8:	fe 01       	movw	r30, r28
    2dfa:	e3 57       	subi	r30, 0x73	; 115
    2dfc:	ff 4f       	sbci	r31, 0xFF	; 255
    2dfe:	60 81       	ld	r22, Z
    2e00:	71 81       	ldd	r23, Z+1	; 0x01
    2e02:	82 81       	ldd	r24, Z+2	; 0x02
    2e04:	93 81       	ldd	r25, Z+3	; 0x03
    2e06:	20 e0       	ldi	r18, 0x00	; 0
    2e08:	30 e0       	ldi	r19, 0x00	; 0
    2e0a:	4a e7       	ldi	r20, 0x7A	; 122
    2e0c:	54 e4       	ldi	r21, 0x44	; 68
    2e0e:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    2e12:	dc 01       	movw	r26, r24
    2e14:	cb 01       	movw	r24, r22
    2e16:	fe 01       	movw	r30, r28
    2e18:	ec 57       	subi	r30, 0x7C	; 124
    2e1a:	ff 4f       	sbci	r31, 0xFF	; 255
    2e1c:	80 83       	st	Z, r24
    2e1e:	91 83       	std	Z+1, r25	; 0x01
    2e20:	a2 83       	std	Z+2, r26	; 0x02
    2e22:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2e24:	8e 01       	movw	r16, r28
    2e26:	00 58       	subi	r16, 0x80	; 128
    2e28:	1f 4f       	sbci	r17, 0xFF	; 255
    2e2a:	fe 01       	movw	r30, r28
    2e2c:	ec 57       	subi	r30, 0x7C	; 124
    2e2e:	ff 4f       	sbci	r31, 0xFF	; 255
    2e30:	60 81       	ld	r22, Z
    2e32:	71 81       	ldd	r23, Z+1	; 0x01
    2e34:	82 81       	ldd	r24, Z+2	; 0x02
    2e36:	93 81       	ldd	r25, Z+3	; 0x03
    2e38:	20 e0       	ldi	r18, 0x00	; 0
    2e3a:	30 e0       	ldi	r19, 0x00	; 0
    2e3c:	4a ef       	ldi	r20, 0xFA	; 250
    2e3e:	54 e4       	ldi	r21, 0x44	; 68
    2e40:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2e44:	dc 01       	movw	r26, r24
    2e46:	cb 01       	movw	r24, r22
    2e48:	f8 01       	movw	r30, r16
    2e4a:	80 83       	st	Z, r24
    2e4c:	91 83       	std	Z+1, r25	; 0x01
    2e4e:	a2 83       	std	Z+2, r26	; 0x02
    2e50:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    2e52:	fe 01       	movw	r30, r28
    2e54:	e0 58       	subi	r30, 0x80	; 128
    2e56:	ff 4f       	sbci	r31, 0xFF	; 255
    2e58:	60 81       	ld	r22, Z
    2e5a:	71 81       	ldd	r23, Z+1	; 0x01
    2e5c:	82 81       	ldd	r24, Z+2	; 0x02
    2e5e:	93 81       	ldd	r25, Z+3	; 0x03
    2e60:	20 e0       	ldi	r18, 0x00	; 0
    2e62:	30 e0       	ldi	r19, 0x00	; 0
    2e64:	40 e8       	ldi	r20, 0x80	; 128
    2e66:	5f e3       	ldi	r21, 0x3F	; 63
    2e68:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    2e6c:	88 23       	and	r24, r24
    2e6e:	44 f4       	brge	.+16     	; 0x2e80 <LCD_function_Set_4bit+0x39a>
		__ticks = 1;
    2e70:	fe 01       	movw	r30, r28
    2e72:	e2 58       	subi	r30, 0x82	; 130
    2e74:	ff 4f       	sbci	r31, 0xFF	; 255
    2e76:	81 e0       	ldi	r24, 0x01	; 1
    2e78:	90 e0       	ldi	r25, 0x00	; 0
    2e7a:	91 83       	std	Z+1, r25	; 0x01
    2e7c:	80 83       	st	Z, r24
    2e7e:	64 c0       	rjmp	.+200    	; 0x2f48 <LCD_function_Set_4bit+0x462>
	else if (__tmp > 65535)
    2e80:	fe 01       	movw	r30, r28
    2e82:	e0 58       	subi	r30, 0x80	; 128
    2e84:	ff 4f       	sbci	r31, 0xFF	; 255
    2e86:	60 81       	ld	r22, Z
    2e88:	71 81       	ldd	r23, Z+1	; 0x01
    2e8a:	82 81       	ldd	r24, Z+2	; 0x02
    2e8c:	93 81       	ldd	r25, Z+3	; 0x03
    2e8e:	20 e0       	ldi	r18, 0x00	; 0
    2e90:	3f ef       	ldi	r19, 0xFF	; 255
    2e92:	4f e7       	ldi	r20, 0x7F	; 127
    2e94:	57 e4       	ldi	r21, 0x47	; 71
    2e96:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    2e9a:	18 16       	cp	r1, r24
    2e9c:	0c f0       	brlt	.+2      	; 0x2ea0 <LCD_function_Set_4bit+0x3ba>
    2e9e:	43 c0       	rjmp	.+134    	; 0x2f26 <LCD_function_Set_4bit+0x440>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2ea0:	fe 01       	movw	r30, r28
    2ea2:	ec 57       	subi	r30, 0x7C	; 124
    2ea4:	ff 4f       	sbci	r31, 0xFF	; 255
    2ea6:	60 81       	ld	r22, Z
    2ea8:	71 81       	ldd	r23, Z+1	; 0x01
    2eaa:	82 81       	ldd	r24, Z+2	; 0x02
    2eac:	93 81       	ldd	r25, Z+3	; 0x03
    2eae:	20 e0       	ldi	r18, 0x00	; 0
    2eb0:	30 e0       	ldi	r19, 0x00	; 0
    2eb2:	40 e2       	ldi	r20, 0x20	; 32
    2eb4:	51 e4       	ldi	r21, 0x41	; 65
    2eb6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2eba:	dc 01       	movw	r26, r24
    2ebc:	cb 01       	movw	r24, r22
    2ebe:	8e 01       	movw	r16, r28
    2ec0:	02 58       	subi	r16, 0x82	; 130
    2ec2:	1f 4f       	sbci	r17, 0xFF	; 255
    2ec4:	bc 01       	movw	r22, r24
    2ec6:	cd 01       	movw	r24, r26
    2ec8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2ecc:	dc 01       	movw	r26, r24
    2ece:	cb 01       	movw	r24, r22
    2ed0:	f8 01       	movw	r30, r16
    2ed2:	91 83       	std	Z+1, r25	; 0x01
    2ed4:	80 83       	st	Z, r24
    2ed6:	1f c0       	rjmp	.+62     	; 0x2f16 <LCD_function_Set_4bit+0x430>
    2ed8:	fe 01       	movw	r30, r28
    2eda:	e4 58       	subi	r30, 0x84	; 132
    2edc:	ff 4f       	sbci	r31, 0xFF	; 255
    2ede:	88 ec       	ldi	r24, 0xC8	; 200
    2ee0:	90 e0       	ldi	r25, 0x00	; 0
    2ee2:	91 83       	std	Z+1, r25	; 0x01
    2ee4:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2ee6:	fe 01       	movw	r30, r28
    2ee8:	e4 58       	subi	r30, 0x84	; 132
    2eea:	ff 4f       	sbci	r31, 0xFF	; 255
    2eec:	80 81       	ld	r24, Z
    2eee:	91 81       	ldd	r25, Z+1	; 0x01
    2ef0:	01 97       	sbiw	r24, 0x01	; 1
    2ef2:	f1 f7       	brne	.-4      	; 0x2ef0 <LCD_function_Set_4bit+0x40a>
    2ef4:	fe 01       	movw	r30, r28
    2ef6:	e4 58       	subi	r30, 0x84	; 132
    2ef8:	ff 4f       	sbci	r31, 0xFF	; 255
    2efa:	91 83       	std	Z+1, r25	; 0x01
    2efc:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2efe:	de 01       	movw	r26, r28
    2f00:	a2 58       	subi	r26, 0x82	; 130
    2f02:	bf 4f       	sbci	r27, 0xFF	; 255
    2f04:	fe 01       	movw	r30, r28
    2f06:	e2 58       	subi	r30, 0x82	; 130
    2f08:	ff 4f       	sbci	r31, 0xFF	; 255
    2f0a:	80 81       	ld	r24, Z
    2f0c:	91 81       	ldd	r25, Z+1	; 0x01
    2f0e:	01 97       	sbiw	r24, 0x01	; 1
    2f10:	11 96       	adiw	r26, 0x01	; 1
    2f12:	9c 93       	st	X, r25
    2f14:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2f16:	fe 01       	movw	r30, r28
    2f18:	e2 58       	subi	r30, 0x82	; 130
    2f1a:	ff 4f       	sbci	r31, 0xFF	; 255
    2f1c:	80 81       	ld	r24, Z
    2f1e:	91 81       	ldd	r25, Z+1	; 0x01
    2f20:	00 97       	sbiw	r24, 0x00	; 0
    2f22:	d1 f6       	brne	.-76     	; 0x2ed8 <LCD_function_Set_4bit+0x3f2>
    2f24:	4b c0       	rjmp	.+150    	; 0x2fbc <LCD_function_Set_4bit+0x4d6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2f26:	8e 01       	movw	r16, r28
    2f28:	02 58       	subi	r16, 0x82	; 130
    2f2a:	1f 4f       	sbci	r17, 0xFF	; 255
    2f2c:	fe 01       	movw	r30, r28
    2f2e:	e0 58       	subi	r30, 0x80	; 128
    2f30:	ff 4f       	sbci	r31, 0xFF	; 255
    2f32:	60 81       	ld	r22, Z
    2f34:	71 81       	ldd	r23, Z+1	; 0x01
    2f36:	82 81       	ldd	r24, Z+2	; 0x02
    2f38:	93 81       	ldd	r25, Z+3	; 0x03
    2f3a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2f3e:	dc 01       	movw	r26, r24
    2f40:	cb 01       	movw	r24, r22
    2f42:	f8 01       	movw	r30, r16
    2f44:	91 83       	std	Z+1, r25	; 0x01
    2f46:	80 83       	st	Z, r24
    2f48:	de 01       	movw	r26, r28
    2f4a:	a6 58       	subi	r26, 0x86	; 134
    2f4c:	bf 4f       	sbci	r27, 0xFF	; 255
    2f4e:	fe 01       	movw	r30, r28
    2f50:	e2 58       	subi	r30, 0x82	; 130
    2f52:	ff 4f       	sbci	r31, 0xFF	; 255
    2f54:	80 81       	ld	r24, Z
    2f56:	91 81       	ldd	r25, Z+1	; 0x01
    2f58:	11 96       	adiw	r26, 0x01	; 1
    2f5a:	9c 93       	st	X, r25
    2f5c:	8e 93       	st	-X, r24
    2f5e:	fe 01       	movw	r30, r28
    2f60:	e6 58       	subi	r30, 0x86	; 134
    2f62:	ff 4f       	sbci	r31, 0xFF	; 255
    2f64:	80 81       	ld	r24, Z
    2f66:	91 81       	ldd	r25, Z+1	; 0x01
    2f68:	01 97       	sbiw	r24, 0x01	; 1
    2f6a:	f1 f7       	brne	.-4      	; 0x2f68 <LCD_function_Set_4bit+0x482>
    2f6c:	fe 01       	movw	r30, r28
    2f6e:	e6 58       	subi	r30, 0x86	; 134
    2f70:	ff 4f       	sbci	r31, 0xFF	; 255
    2f72:	91 83       	std	Z+1, r25	; 0x01
    2f74:	80 83       	st	Z, r24
    2f76:	22 c0       	rjmp	.+68     	; 0x2fbc <LCD_function_Set_4bit+0x4d6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    2f78:	8e 01       	movw	r16, r28
    2f7a:	08 57       	subi	r16, 0x78	; 120
    2f7c:	1f 4f       	sbci	r17, 0xFF	; 255
    2f7e:	fe 01       	movw	r30, r28
    2f80:	e7 57       	subi	r30, 0x77	; 119
    2f82:	ff 4f       	sbci	r31, 0xFF	; 255
    2f84:	60 81       	ld	r22, Z
    2f86:	71 81       	ldd	r23, Z+1	; 0x01
    2f88:	82 81       	ldd	r24, Z+2	; 0x02
    2f8a:	93 81       	ldd	r25, Z+3	; 0x03
    2f8c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    2f90:	dc 01       	movw	r26, r24
    2f92:	cb 01       	movw	r24, r22
    2f94:	f8 01       	movw	r30, r16
    2f96:	80 83       	st	Z, r24
    2f98:	de 01       	movw	r26, r28
    2f9a:	a7 58       	subi	r26, 0x87	; 135
    2f9c:	bf 4f       	sbci	r27, 0xFF	; 255
    2f9e:	fe 01       	movw	r30, r28
    2fa0:	e8 57       	subi	r30, 0x78	; 120
    2fa2:	ff 4f       	sbci	r31, 0xFF	; 255
    2fa4:	80 81       	ld	r24, Z
    2fa6:	8c 93       	st	X, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2fa8:	fe 01       	movw	r30, r28
    2faa:	e7 58       	subi	r30, 0x87	; 135
    2fac:	ff 4f       	sbci	r31, 0xFF	; 255
    2fae:	80 81       	ld	r24, Z
    2fb0:	8a 95       	dec	r24
    2fb2:	f1 f7       	brne	.-4      	; 0x2fb0 <LCD_function_Set_4bit+0x4ca>
    2fb4:	fe 01       	movw	r30, r28
    2fb6:	e7 58       	subi	r30, 0x87	; 135
    2fb8:	ff 4f       	sbci	r31, 0xFF	; 255
    2fba:	80 83       	st	Z, r24
	_delay_us(1);
	//send the high nibble

	for(u8 i=0; i<4;i++){
    2fbc:	fe 01       	movw	r30, r28
    2fbe:	e5 55       	subi	r30, 0x55	; 85
    2fc0:	ff 4f       	sbci	r31, 0xFF	; 255
    2fc2:	10 82       	st	Z, r1
    2fc4:	23 c0       	rjmp	.+70     	; 0x300c <LCD_function_Set_4bit+0x526>

		DIO_void_assign_pin(lcd_data_port, i+4, get_Bit(0b0010,i));
    2fc6:	fe 01       	movw	r30, r28
    2fc8:	e5 55       	subi	r30, 0x55	; 85
    2fca:	ff 4f       	sbci	r31, 0xFF	; 255
    2fcc:	80 81       	ld	r24, Z
    2fce:	48 2f       	mov	r20, r24
    2fd0:	4c 5f       	subi	r20, 0xFC	; 252
    2fd2:	fe 01       	movw	r30, r28
    2fd4:	e5 55       	subi	r30, 0x55	; 85
    2fd6:	ff 4f       	sbci	r31, 0xFF	; 255
    2fd8:	80 81       	ld	r24, Z
    2fda:	28 2f       	mov	r18, r24
    2fdc:	30 e0       	ldi	r19, 0x00	; 0
    2fde:	82 e0       	ldi	r24, 0x02	; 2
    2fe0:	90 e0       	ldi	r25, 0x00	; 0
    2fe2:	02 c0       	rjmp	.+4      	; 0x2fe8 <LCD_function_Set_4bit+0x502>
    2fe4:	95 95       	asr	r25
    2fe6:	87 95       	ror	r24
    2fe8:	2a 95       	dec	r18
    2fea:	e2 f7       	brpl	.-8      	; 0x2fe4 <LCD_function_Set_4bit+0x4fe>
    2fec:	98 2f       	mov	r25, r24
    2fee:	91 70       	andi	r25, 0x01	; 1
    2ff0:	82 e0       	ldi	r24, 0x02	; 2
    2ff2:	64 2f       	mov	r22, r20
    2ff4:	49 2f       	mov	r20, r25
    2ff6:	0e 94 b1 08 	call	0x1162	; 0x1162 <DIO_void_assign_pin>
	_delay_us(1);
	DIO_void_set_pin(lcd_control_port, lcd_enable); // enable high
	_delay_us(1);
	//send the high nibble

	for(u8 i=0; i<4;i++){
    2ffa:	de 01       	movw	r26, r28
    2ffc:	a5 55       	subi	r26, 0x55	; 85
    2ffe:	bf 4f       	sbci	r27, 0xFF	; 255
    3000:	fe 01       	movw	r30, r28
    3002:	e5 55       	subi	r30, 0x55	; 85
    3004:	ff 4f       	sbci	r31, 0xFF	; 255
    3006:	80 81       	ld	r24, Z
    3008:	8f 5f       	subi	r24, 0xFF	; 255
    300a:	8c 93       	st	X, r24
    300c:	fe 01       	movw	r30, r28
    300e:	e5 55       	subi	r30, 0x55	; 85
    3010:	ff 4f       	sbci	r31, 0xFF	; 255
    3012:	80 81       	ld	r24, Z
    3014:	84 30       	cpi	r24, 0x04	; 4
    3016:	b8 f2       	brcs	.-82     	; 0x2fc6 <LCD_function_Set_4bit+0x4e0>

		DIO_void_assign_pin(lcd_data_port, i+4, get_Bit(0b0010,i));
	}
	//enable pin low
	DIO_void_clear_pin(lcd_control_port, lcd_enable);
    3018:	83 e0       	ldi	r24, 0x03	; 3
    301a:	60 e0       	ldi	r22, 0x00	; 0
    301c:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>
    3020:	fe 01       	movw	r30, r28
    3022:	eb 58       	subi	r30, 0x8B	; 139
    3024:	ff 4f       	sbci	r31, 0xFF	; 255
    3026:	80 e0       	ldi	r24, 0x00	; 0
    3028:	90 e0       	ldi	r25, 0x00	; 0
    302a:	a0 e2       	ldi	r26, 0x20	; 32
    302c:	b1 e4       	ldi	r27, 0x41	; 65
    302e:	80 83       	st	Z, r24
    3030:	91 83       	std	Z+1, r25	; 0x01
    3032:	a2 83       	std	Z+2, r26	; 0x02
    3034:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3036:	8e 01       	movw	r16, r28
    3038:	0f 58       	subi	r16, 0x8F	; 143
    303a:	1f 4f       	sbci	r17, 0xFF	; 255
    303c:	fe 01       	movw	r30, r28
    303e:	eb 58       	subi	r30, 0x8B	; 139
    3040:	ff 4f       	sbci	r31, 0xFF	; 255
    3042:	60 81       	ld	r22, Z
    3044:	71 81       	ldd	r23, Z+1	; 0x01
    3046:	82 81       	ldd	r24, Z+2	; 0x02
    3048:	93 81       	ldd	r25, Z+3	; 0x03
    304a:	2b ea       	ldi	r18, 0xAB	; 171
    304c:	3a ea       	ldi	r19, 0xAA	; 170
    304e:	4a e2       	ldi	r20, 0x2A	; 42
    3050:	50 e4       	ldi	r21, 0x40	; 64
    3052:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3056:	dc 01       	movw	r26, r24
    3058:	cb 01       	movw	r24, r22
    305a:	f8 01       	movw	r30, r16
    305c:	80 83       	st	Z, r24
    305e:	91 83       	std	Z+1, r25	; 0x01
    3060:	a2 83       	std	Z+2, r26	; 0x02
    3062:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3064:	fe 01       	movw	r30, r28
    3066:	ef 58       	subi	r30, 0x8F	; 143
    3068:	ff 4f       	sbci	r31, 0xFF	; 255
    306a:	60 81       	ld	r22, Z
    306c:	71 81       	ldd	r23, Z+1	; 0x01
    306e:	82 81       	ldd	r24, Z+2	; 0x02
    3070:	93 81       	ldd	r25, Z+3	; 0x03
    3072:	20 e0       	ldi	r18, 0x00	; 0
    3074:	30 e0       	ldi	r19, 0x00	; 0
    3076:	40 e8       	ldi	r20, 0x80	; 128
    3078:	5f e3       	ldi	r21, 0x3F	; 63
    307a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    307e:	88 23       	and	r24, r24
    3080:	34 f4       	brge	.+12     	; 0x308e <LCD_function_Set_4bit+0x5a8>
		__ticks = 1;
    3082:	fe 01       	movw	r30, r28
    3084:	e0 59       	subi	r30, 0x90	; 144
    3086:	ff 4f       	sbci	r31, 0xFF	; 255
    3088:	81 e0       	ldi	r24, 0x01	; 1
    308a:	80 83       	st	Z, r24
    308c:	e0 c0       	rjmp	.+448    	; 0x324e <LCD_function_Set_4bit+0x768>
	else if (__tmp > 255)
    308e:	fe 01       	movw	r30, r28
    3090:	ef 58       	subi	r30, 0x8F	; 143
    3092:	ff 4f       	sbci	r31, 0xFF	; 255
    3094:	60 81       	ld	r22, Z
    3096:	71 81       	ldd	r23, Z+1	; 0x01
    3098:	82 81       	ldd	r24, Z+2	; 0x02
    309a:	93 81       	ldd	r25, Z+3	; 0x03
    309c:	20 e0       	ldi	r18, 0x00	; 0
    309e:	30 e0       	ldi	r19, 0x00	; 0
    30a0:	4f e7       	ldi	r20, 0x7F	; 127
    30a2:	53 e4       	ldi	r21, 0x43	; 67
    30a4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    30a8:	18 16       	cp	r1, r24
    30aa:	0c f0       	brlt	.+2      	; 0x30ae <LCD_function_Set_4bit+0x5c8>
    30ac:	c0 c0       	rjmp	.+384    	; 0x322e <LCD_function_Set_4bit+0x748>
	{
		_delay_ms(__us / 1000.0);
    30ae:	fe 01       	movw	r30, r28
    30b0:	eb 58       	subi	r30, 0x8B	; 139
    30b2:	ff 4f       	sbci	r31, 0xFF	; 255
    30b4:	60 81       	ld	r22, Z
    30b6:	71 81       	ldd	r23, Z+1	; 0x01
    30b8:	82 81       	ldd	r24, Z+2	; 0x02
    30ba:	93 81       	ldd	r25, Z+3	; 0x03
    30bc:	20 e0       	ldi	r18, 0x00	; 0
    30be:	30 e0       	ldi	r19, 0x00	; 0
    30c0:	4a e7       	ldi	r20, 0x7A	; 122
    30c2:	54 e4       	ldi	r21, 0x44	; 68
    30c4:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    30c8:	dc 01       	movw	r26, r24
    30ca:	cb 01       	movw	r24, r22
    30cc:	fe 01       	movw	r30, r28
    30ce:	e4 59       	subi	r30, 0x94	; 148
    30d0:	ff 4f       	sbci	r31, 0xFF	; 255
    30d2:	80 83       	st	Z, r24
    30d4:	91 83       	std	Z+1, r25	; 0x01
    30d6:	a2 83       	std	Z+2, r26	; 0x02
    30d8:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    30da:	8e 01       	movw	r16, r28
    30dc:	08 59       	subi	r16, 0x98	; 152
    30de:	1f 4f       	sbci	r17, 0xFF	; 255
    30e0:	fe 01       	movw	r30, r28
    30e2:	e4 59       	subi	r30, 0x94	; 148
    30e4:	ff 4f       	sbci	r31, 0xFF	; 255
    30e6:	60 81       	ld	r22, Z
    30e8:	71 81       	ldd	r23, Z+1	; 0x01
    30ea:	82 81       	ldd	r24, Z+2	; 0x02
    30ec:	93 81       	ldd	r25, Z+3	; 0x03
    30ee:	20 e0       	ldi	r18, 0x00	; 0
    30f0:	30 e0       	ldi	r19, 0x00	; 0
    30f2:	4a ef       	ldi	r20, 0xFA	; 250
    30f4:	54 e4       	ldi	r21, 0x44	; 68
    30f6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    30fa:	dc 01       	movw	r26, r24
    30fc:	cb 01       	movw	r24, r22
    30fe:	f8 01       	movw	r30, r16
    3100:	80 83       	st	Z, r24
    3102:	91 83       	std	Z+1, r25	; 0x01
    3104:	a2 83       	std	Z+2, r26	; 0x02
    3106:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3108:	fe 01       	movw	r30, r28
    310a:	e8 59       	subi	r30, 0x98	; 152
    310c:	ff 4f       	sbci	r31, 0xFF	; 255
    310e:	60 81       	ld	r22, Z
    3110:	71 81       	ldd	r23, Z+1	; 0x01
    3112:	82 81       	ldd	r24, Z+2	; 0x02
    3114:	93 81       	ldd	r25, Z+3	; 0x03
    3116:	20 e0       	ldi	r18, 0x00	; 0
    3118:	30 e0       	ldi	r19, 0x00	; 0
    311a:	40 e8       	ldi	r20, 0x80	; 128
    311c:	5f e3       	ldi	r21, 0x3F	; 63
    311e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3122:	88 23       	and	r24, r24
    3124:	44 f4       	brge	.+16     	; 0x3136 <LCD_function_Set_4bit+0x650>
		__ticks = 1;
    3126:	fe 01       	movw	r30, r28
    3128:	ea 59       	subi	r30, 0x9A	; 154
    312a:	ff 4f       	sbci	r31, 0xFF	; 255
    312c:	81 e0       	ldi	r24, 0x01	; 1
    312e:	90 e0       	ldi	r25, 0x00	; 0
    3130:	91 83       	std	Z+1, r25	; 0x01
    3132:	80 83       	st	Z, r24
    3134:	64 c0       	rjmp	.+200    	; 0x31fe <LCD_function_Set_4bit+0x718>
	else if (__tmp > 65535)
    3136:	fe 01       	movw	r30, r28
    3138:	e8 59       	subi	r30, 0x98	; 152
    313a:	ff 4f       	sbci	r31, 0xFF	; 255
    313c:	60 81       	ld	r22, Z
    313e:	71 81       	ldd	r23, Z+1	; 0x01
    3140:	82 81       	ldd	r24, Z+2	; 0x02
    3142:	93 81       	ldd	r25, Z+3	; 0x03
    3144:	20 e0       	ldi	r18, 0x00	; 0
    3146:	3f ef       	ldi	r19, 0xFF	; 255
    3148:	4f e7       	ldi	r20, 0x7F	; 127
    314a:	57 e4       	ldi	r21, 0x47	; 71
    314c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3150:	18 16       	cp	r1, r24
    3152:	0c f0       	brlt	.+2      	; 0x3156 <LCD_function_Set_4bit+0x670>
    3154:	43 c0       	rjmp	.+134    	; 0x31dc <LCD_function_Set_4bit+0x6f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3156:	fe 01       	movw	r30, r28
    3158:	e4 59       	subi	r30, 0x94	; 148
    315a:	ff 4f       	sbci	r31, 0xFF	; 255
    315c:	60 81       	ld	r22, Z
    315e:	71 81       	ldd	r23, Z+1	; 0x01
    3160:	82 81       	ldd	r24, Z+2	; 0x02
    3162:	93 81       	ldd	r25, Z+3	; 0x03
    3164:	20 e0       	ldi	r18, 0x00	; 0
    3166:	30 e0       	ldi	r19, 0x00	; 0
    3168:	40 e2       	ldi	r20, 0x20	; 32
    316a:	51 e4       	ldi	r21, 0x41	; 65
    316c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3170:	dc 01       	movw	r26, r24
    3172:	cb 01       	movw	r24, r22
    3174:	8e 01       	movw	r16, r28
    3176:	0a 59       	subi	r16, 0x9A	; 154
    3178:	1f 4f       	sbci	r17, 0xFF	; 255
    317a:	bc 01       	movw	r22, r24
    317c:	cd 01       	movw	r24, r26
    317e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3182:	dc 01       	movw	r26, r24
    3184:	cb 01       	movw	r24, r22
    3186:	f8 01       	movw	r30, r16
    3188:	91 83       	std	Z+1, r25	; 0x01
    318a:	80 83       	st	Z, r24
    318c:	1f c0       	rjmp	.+62     	; 0x31cc <LCD_function_Set_4bit+0x6e6>
    318e:	fe 01       	movw	r30, r28
    3190:	ec 59       	subi	r30, 0x9C	; 156
    3192:	ff 4f       	sbci	r31, 0xFF	; 255
    3194:	88 ec       	ldi	r24, 0xC8	; 200
    3196:	90 e0       	ldi	r25, 0x00	; 0
    3198:	91 83       	std	Z+1, r25	; 0x01
    319a:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    319c:	fe 01       	movw	r30, r28
    319e:	ec 59       	subi	r30, 0x9C	; 156
    31a0:	ff 4f       	sbci	r31, 0xFF	; 255
    31a2:	80 81       	ld	r24, Z
    31a4:	91 81       	ldd	r25, Z+1	; 0x01
    31a6:	01 97       	sbiw	r24, 0x01	; 1
    31a8:	f1 f7       	brne	.-4      	; 0x31a6 <LCD_function_Set_4bit+0x6c0>
    31aa:	fe 01       	movw	r30, r28
    31ac:	ec 59       	subi	r30, 0x9C	; 156
    31ae:	ff 4f       	sbci	r31, 0xFF	; 255
    31b0:	91 83       	std	Z+1, r25	; 0x01
    31b2:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    31b4:	de 01       	movw	r26, r28
    31b6:	aa 59       	subi	r26, 0x9A	; 154
    31b8:	bf 4f       	sbci	r27, 0xFF	; 255
    31ba:	fe 01       	movw	r30, r28
    31bc:	ea 59       	subi	r30, 0x9A	; 154
    31be:	ff 4f       	sbci	r31, 0xFF	; 255
    31c0:	80 81       	ld	r24, Z
    31c2:	91 81       	ldd	r25, Z+1	; 0x01
    31c4:	01 97       	sbiw	r24, 0x01	; 1
    31c6:	11 96       	adiw	r26, 0x01	; 1
    31c8:	9c 93       	st	X, r25
    31ca:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    31cc:	fe 01       	movw	r30, r28
    31ce:	ea 59       	subi	r30, 0x9A	; 154
    31d0:	ff 4f       	sbci	r31, 0xFF	; 255
    31d2:	80 81       	ld	r24, Z
    31d4:	91 81       	ldd	r25, Z+1	; 0x01
    31d6:	00 97       	sbiw	r24, 0x00	; 0
    31d8:	d1 f6       	brne	.-76     	; 0x318e <LCD_function_Set_4bit+0x6a8>
    31da:	4b c0       	rjmp	.+150    	; 0x3272 <LCD_function_Set_4bit+0x78c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    31dc:	8e 01       	movw	r16, r28
    31de:	0a 59       	subi	r16, 0x9A	; 154
    31e0:	1f 4f       	sbci	r17, 0xFF	; 255
    31e2:	fe 01       	movw	r30, r28
    31e4:	e8 59       	subi	r30, 0x98	; 152
    31e6:	ff 4f       	sbci	r31, 0xFF	; 255
    31e8:	60 81       	ld	r22, Z
    31ea:	71 81       	ldd	r23, Z+1	; 0x01
    31ec:	82 81       	ldd	r24, Z+2	; 0x02
    31ee:	93 81       	ldd	r25, Z+3	; 0x03
    31f0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    31f4:	dc 01       	movw	r26, r24
    31f6:	cb 01       	movw	r24, r22
    31f8:	f8 01       	movw	r30, r16
    31fa:	91 83       	std	Z+1, r25	; 0x01
    31fc:	80 83       	st	Z, r24
    31fe:	de 01       	movw	r26, r28
    3200:	ae 59       	subi	r26, 0x9E	; 158
    3202:	bf 4f       	sbci	r27, 0xFF	; 255
    3204:	fe 01       	movw	r30, r28
    3206:	ea 59       	subi	r30, 0x9A	; 154
    3208:	ff 4f       	sbci	r31, 0xFF	; 255
    320a:	80 81       	ld	r24, Z
    320c:	91 81       	ldd	r25, Z+1	; 0x01
    320e:	11 96       	adiw	r26, 0x01	; 1
    3210:	9c 93       	st	X, r25
    3212:	8e 93       	st	-X, r24
    3214:	fe 01       	movw	r30, r28
    3216:	ee 59       	subi	r30, 0x9E	; 158
    3218:	ff 4f       	sbci	r31, 0xFF	; 255
    321a:	80 81       	ld	r24, Z
    321c:	91 81       	ldd	r25, Z+1	; 0x01
    321e:	01 97       	sbiw	r24, 0x01	; 1
    3220:	f1 f7       	brne	.-4      	; 0x321e <LCD_function_Set_4bit+0x738>
    3222:	fe 01       	movw	r30, r28
    3224:	ee 59       	subi	r30, 0x9E	; 158
    3226:	ff 4f       	sbci	r31, 0xFF	; 255
    3228:	91 83       	std	Z+1, r25	; 0x01
    322a:	80 83       	st	Z, r24
    322c:	22 c0       	rjmp	.+68     	; 0x3272 <LCD_function_Set_4bit+0x78c>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    322e:	8e 01       	movw	r16, r28
    3230:	00 59       	subi	r16, 0x90	; 144
    3232:	1f 4f       	sbci	r17, 0xFF	; 255
    3234:	fe 01       	movw	r30, r28
    3236:	ef 58       	subi	r30, 0x8F	; 143
    3238:	ff 4f       	sbci	r31, 0xFF	; 255
    323a:	60 81       	ld	r22, Z
    323c:	71 81       	ldd	r23, Z+1	; 0x01
    323e:	82 81       	ldd	r24, Z+2	; 0x02
    3240:	93 81       	ldd	r25, Z+3	; 0x03
    3242:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3246:	dc 01       	movw	r26, r24
    3248:	cb 01       	movw	r24, r22
    324a:	f8 01       	movw	r30, r16
    324c:	80 83       	st	Z, r24
    324e:	de 01       	movw	r26, r28
    3250:	af 59       	subi	r26, 0x9F	; 159
    3252:	bf 4f       	sbci	r27, 0xFF	; 255
    3254:	fe 01       	movw	r30, r28
    3256:	e0 59       	subi	r30, 0x90	; 144
    3258:	ff 4f       	sbci	r31, 0xFF	; 255
    325a:	80 81       	ld	r24, Z
    325c:	8c 93       	st	X, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    325e:	fe 01       	movw	r30, r28
    3260:	ef 59       	subi	r30, 0x9F	; 159
    3262:	ff 4f       	sbci	r31, 0xFF	; 255
    3264:	80 81       	ld	r24, Z
    3266:	8a 95       	dec	r24
    3268:	f1 f7       	brne	.-4      	; 0x3266 <LCD_function_Set_4bit+0x780>
    326a:	fe 01       	movw	r30, r28
    326c:	ef 59       	subi	r30, 0x9F	; 159
    326e:	ff 4f       	sbci	r31, 0xFF	; 255
    3270:	80 83       	st	Z, r24
	_delay_us(10);
	//send again high nibble to make sure
	DIO_void_set_pin(lcd_control_port, lcd_enable); // enable high
    3272:	83 e0       	ldi	r24, 0x03	; 3
    3274:	60 e0       	ldi	r22, 0x00	; 0
    3276:	0e 94 50 08 	call	0x10a0	; 0x10a0 <DIO_void_set_pin>
    327a:	fe 01       	movw	r30, r28
    327c:	e3 5a       	subi	r30, 0xA3	; 163
    327e:	ff 4f       	sbci	r31, 0xFF	; 255
    3280:	80 e0       	ldi	r24, 0x00	; 0
    3282:	90 e0       	ldi	r25, 0x00	; 0
    3284:	a0 e8       	ldi	r26, 0x80	; 128
    3286:	bf e3       	ldi	r27, 0x3F	; 63
    3288:	80 83       	st	Z, r24
    328a:	91 83       	std	Z+1, r25	; 0x01
    328c:	a2 83       	std	Z+2, r26	; 0x02
    328e:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3290:	8e 01       	movw	r16, r28
    3292:	07 5a       	subi	r16, 0xA7	; 167
    3294:	1f 4f       	sbci	r17, 0xFF	; 255
    3296:	fe 01       	movw	r30, r28
    3298:	e3 5a       	subi	r30, 0xA3	; 163
    329a:	ff 4f       	sbci	r31, 0xFF	; 255
    329c:	60 81       	ld	r22, Z
    329e:	71 81       	ldd	r23, Z+1	; 0x01
    32a0:	82 81       	ldd	r24, Z+2	; 0x02
    32a2:	93 81       	ldd	r25, Z+3	; 0x03
    32a4:	2b ea       	ldi	r18, 0xAB	; 171
    32a6:	3a ea       	ldi	r19, 0xAA	; 170
    32a8:	4a e2       	ldi	r20, 0x2A	; 42
    32aa:	50 e4       	ldi	r21, 0x40	; 64
    32ac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    32b0:	dc 01       	movw	r26, r24
    32b2:	cb 01       	movw	r24, r22
    32b4:	f8 01       	movw	r30, r16
    32b6:	80 83       	st	Z, r24
    32b8:	91 83       	std	Z+1, r25	; 0x01
    32ba:	a2 83       	std	Z+2, r26	; 0x02
    32bc:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    32be:	fe 01       	movw	r30, r28
    32c0:	e7 5a       	subi	r30, 0xA7	; 167
    32c2:	ff 4f       	sbci	r31, 0xFF	; 255
    32c4:	60 81       	ld	r22, Z
    32c6:	71 81       	ldd	r23, Z+1	; 0x01
    32c8:	82 81       	ldd	r24, Z+2	; 0x02
    32ca:	93 81       	ldd	r25, Z+3	; 0x03
    32cc:	20 e0       	ldi	r18, 0x00	; 0
    32ce:	30 e0       	ldi	r19, 0x00	; 0
    32d0:	40 e8       	ldi	r20, 0x80	; 128
    32d2:	5f e3       	ldi	r21, 0x3F	; 63
    32d4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    32d8:	88 23       	and	r24, r24
    32da:	34 f4       	brge	.+12     	; 0x32e8 <LCD_function_Set_4bit+0x802>
		__ticks = 1;
    32dc:	fe 01       	movw	r30, r28
    32de:	e8 5a       	subi	r30, 0xA8	; 168
    32e0:	ff 4f       	sbci	r31, 0xFF	; 255
    32e2:	81 e0       	ldi	r24, 0x01	; 1
    32e4:	80 83       	st	Z, r24
    32e6:	e0 c0       	rjmp	.+448    	; 0x34a8 <LCD_function_Set_4bit+0x9c2>
	else if (__tmp > 255)
    32e8:	fe 01       	movw	r30, r28
    32ea:	e7 5a       	subi	r30, 0xA7	; 167
    32ec:	ff 4f       	sbci	r31, 0xFF	; 255
    32ee:	60 81       	ld	r22, Z
    32f0:	71 81       	ldd	r23, Z+1	; 0x01
    32f2:	82 81       	ldd	r24, Z+2	; 0x02
    32f4:	93 81       	ldd	r25, Z+3	; 0x03
    32f6:	20 e0       	ldi	r18, 0x00	; 0
    32f8:	30 e0       	ldi	r19, 0x00	; 0
    32fa:	4f e7       	ldi	r20, 0x7F	; 127
    32fc:	53 e4       	ldi	r21, 0x43	; 67
    32fe:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3302:	18 16       	cp	r1, r24
    3304:	0c f0       	brlt	.+2      	; 0x3308 <LCD_function_Set_4bit+0x822>
    3306:	c0 c0       	rjmp	.+384    	; 0x3488 <LCD_function_Set_4bit+0x9a2>
	{
		_delay_ms(__us / 1000.0);
    3308:	fe 01       	movw	r30, r28
    330a:	e3 5a       	subi	r30, 0xA3	; 163
    330c:	ff 4f       	sbci	r31, 0xFF	; 255
    330e:	60 81       	ld	r22, Z
    3310:	71 81       	ldd	r23, Z+1	; 0x01
    3312:	82 81       	ldd	r24, Z+2	; 0x02
    3314:	93 81       	ldd	r25, Z+3	; 0x03
    3316:	20 e0       	ldi	r18, 0x00	; 0
    3318:	30 e0       	ldi	r19, 0x00	; 0
    331a:	4a e7       	ldi	r20, 0x7A	; 122
    331c:	54 e4       	ldi	r21, 0x44	; 68
    331e:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3322:	dc 01       	movw	r26, r24
    3324:	cb 01       	movw	r24, r22
    3326:	fe 01       	movw	r30, r28
    3328:	ec 5a       	subi	r30, 0xAC	; 172
    332a:	ff 4f       	sbci	r31, 0xFF	; 255
    332c:	80 83       	st	Z, r24
    332e:	91 83       	std	Z+1, r25	; 0x01
    3330:	a2 83       	std	Z+2, r26	; 0x02
    3332:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3334:	8e 01       	movw	r16, r28
    3336:	00 5b       	subi	r16, 0xB0	; 176
    3338:	1f 4f       	sbci	r17, 0xFF	; 255
    333a:	fe 01       	movw	r30, r28
    333c:	ec 5a       	subi	r30, 0xAC	; 172
    333e:	ff 4f       	sbci	r31, 0xFF	; 255
    3340:	60 81       	ld	r22, Z
    3342:	71 81       	ldd	r23, Z+1	; 0x01
    3344:	82 81       	ldd	r24, Z+2	; 0x02
    3346:	93 81       	ldd	r25, Z+3	; 0x03
    3348:	20 e0       	ldi	r18, 0x00	; 0
    334a:	30 e0       	ldi	r19, 0x00	; 0
    334c:	4a ef       	ldi	r20, 0xFA	; 250
    334e:	54 e4       	ldi	r21, 0x44	; 68
    3350:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3354:	dc 01       	movw	r26, r24
    3356:	cb 01       	movw	r24, r22
    3358:	f8 01       	movw	r30, r16
    335a:	80 83       	st	Z, r24
    335c:	91 83       	std	Z+1, r25	; 0x01
    335e:	a2 83       	std	Z+2, r26	; 0x02
    3360:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3362:	fe 01       	movw	r30, r28
    3364:	e0 5b       	subi	r30, 0xB0	; 176
    3366:	ff 4f       	sbci	r31, 0xFF	; 255
    3368:	60 81       	ld	r22, Z
    336a:	71 81       	ldd	r23, Z+1	; 0x01
    336c:	82 81       	ldd	r24, Z+2	; 0x02
    336e:	93 81       	ldd	r25, Z+3	; 0x03
    3370:	20 e0       	ldi	r18, 0x00	; 0
    3372:	30 e0       	ldi	r19, 0x00	; 0
    3374:	40 e8       	ldi	r20, 0x80	; 128
    3376:	5f e3       	ldi	r21, 0x3F	; 63
    3378:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    337c:	88 23       	and	r24, r24
    337e:	44 f4       	brge	.+16     	; 0x3390 <LCD_function_Set_4bit+0x8aa>
		__ticks = 1;
    3380:	fe 01       	movw	r30, r28
    3382:	e2 5b       	subi	r30, 0xB2	; 178
    3384:	ff 4f       	sbci	r31, 0xFF	; 255
    3386:	81 e0       	ldi	r24, 0x01	; 1
    3388:	90 e0       	ldi	r25, 0x00	; 0
    338a:	91 83       	std	Z+1, r25	; 0x01
    338c:	80 83       	st	Z, r24
    338e:	64 c0       	rjmp	.+200    	; 0x3458 <LCD_function_Set_4bit+0x972>
	else if (__tmp > 65535)
    3390:	fe 01       	movw	r30, r28
    3392:	e0 5b       	subi	r30, 0xB0	; 176
    3394:	ff 4f       	sbci	r31, 0xFF	; 255
    3396:	60 81       	ld	r22, Z
    3398:	71 81       	ldd	r23, Z+1	; 0x01
    339a:	82 81       	ldd	r24, Z+2	; 0x02
    339c:	93 81       	ldd	r25, Z+3	; 0x03
    339e:	20 e0       	ldi	r18, 0x00	; 0
    33a0:	3f ef       	ldi	r19, 0xFF	; 255
    33a2:	4f e7       	ldi	r20, 0x7F	; 127
    33a4:	57 e4       	ldi	r21, 0x47	; 71
    33a6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    33aa:	18 16       	cp	r1, r24
    33ac:	0c f0       	brlt	.+2      	; 0x33b0 <LCD_function_Set_4bit+0x8ca>
    33ae:	43 c0       	rjmp	.+134    	; 0x3436 <LCD_function_Set_4bit+0x950>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    33b0:	fe 01       	movw	r30, r28
    33b2:	ec 5a       	subi	r30, 0xAC	; 172
    33b4:	ff 4f       	sbci	r31, 0xFF	; 255
    33b6:	60 81       	ld	r22, Z
    33b8:	71 81       	ldd	r23, Z+1	; 0x01
    33ba:	82 81       	ldd	r24, Z+2	; 0x02
    33bc:	93 81       	ldd	r25, Z+3	; 0x03
    33be:	20 e0       	ldi	r18, 0x00	; 0
    33c0:	30 e0       	ldi	r19, 0x00	; 0
    33c2:	40 e2       	ldi	r20, 0x20	; 32
    33c4:	51 e4       	ldi	r21, 0x41	; 65
    33c6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    33ca:	dc 01       	movw	r26, r24
    33cc:	cb 01       	movw	r24, r22
    33ce:	8e 01       	movw	r16, r28
    33d0:	02 5b       	subi	r16, 0xB2	; 178
    33d2:	1f 4f       	sbci	r17, 0xFF	; 255
    33d4:	bc 01       	movw	r22, r24
    33d6:	cd 01       	movw	r24, r26
    33d8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    33dc:	dc 01       	movw	r26, r24
    33de:	cb 01       	movw	r24, r22
    33e0:	f8 01       	movw	r30, r16
    33e2:	91 83       	std	Z+1, r25	; 0x01
    33e4:	80 83       	st	Z, r24
    33e6:	1f c0       	rjmp	.+62     	; 0x3426 <LCD_function_Set_4bit+0x940>
    33e8:	fe 01       	movw	r30, r28
    33ea:	e4 5b       	subi	r30, 0xB4	; 180
    33ec:	ff 4f       	sbci	r31, 0xFF	; 255
    33ee:	88 ec       	ldi	r24, 0xC8	; 200
    33f0:	90 e0       	ldi	r25, 0x00	; 0
    33f2:	91 83       	std	Z+1, r25	; 0x01
    33f4:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    33f6:	fe 01       	movw	r30, r28
    33f8:	e4 5b       	subi	r30, 0xB4	; 180
    33fa:	ff 4f       	sbci	r31, 0xFF	; 255
    33fc:	80 81       	ld	r24, Z
    33fe:	91 81       	ldd	r25, Z+1	; 0x01
    3400:	01 97       	sbiw	r24, 0x01	; 1
    3402:	f1 f7       	brne	.-4      	; 0x3400 <LCD_function_Set_4bit+0x91a>
    3404:	fe 01       	movw	r30, r28
    3406:	e4 5b       	subi	r30, 0xB4	; 180
    3408:	ff 4f       	sbci	r31, 0xFF	; 255
    340a:	91 83       	std	Z+1, r25	; 0x01
    340c:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    340e:	de 01       	movw	r26, r28
    3410:	a2 5b       	subi	r26, 0xB2	; 178
    3412:	bf 4f       	sbci	r27, 0xFF	; 255
    3414:	fe 01       	movw	r30, r28
    3416:	e2 5b       	subi	r30, 0xB2	; 178
    3418:	ff 4f       	sbci	r31, 0xFF	; 255
    341a:	80 81       	ld	r24, Z
    341c:	91 81       	ldd	r25, Z+1	; 0x01
    341e:	01 97       	sbiw	r24, 0x01	; 1
    3420:	11 96       	adiw	r26, 0x01	; 1
    3422:	9c 93       	st	X, r25
    3424:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3426:	fe 01       	movw	r30, r28
    3428:	e2 5b       	subi	r30, 0xB2	; 178
    342a:	ff 4f       	sbci	r31, 0xFF	; 255
    342c:	80 81       	ld	r24, Z
    342e:	91 81       	ldd	r25, Z+1	; 0x01
    3430:	00 97       	sbiw	r24, 0x00	; 0
    3432:	d1 f6       	brne	.-76     	; 0x33e8 <LCD_function_Set_4bit+0x902>
    3434:	4b c0       	rjmp	.+150    	; 0x34cc <LCD_function_Set_4bit+0x9e6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3436:	8e 01       	movw	r16, r28
    3438:	02 5b       	subi	r16, 0xB2	; 178
    343a:	1f 4f       	sbci	r17, 0xFF	; 255
    343c:	fe 01       	movw	r30, r28
    343e:	e0 5b       	subi	r30, 0xB0	; 176
    3440:	ff 4f       	sbci	r31, 0xFF	; 255
    3442:	60 81       	ld	r22, Z
    3444:	71 81       	ldd	r23, Z+1	; 0x01
    3446:	82 81       	ldd	r24, Z+2	; 0x02
    3448:	93 81       	ldd	r25, Z+3	; 0x03
    344a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    344e:	dc 01       	movw	r26, r24
    3450:	cb 01       	movw	r24, r22
    3452:	f8 01       	movw	r30, r16
    3454:	91 83       	std	Z+1, r25	; 0x01
    3456:	80 83       	st	Z, r24
    3458:	de 01       	movw	r26, r28
    345a:	a6 5b       	subi	r26, 0xB6	; 182
    345c:	bf 4f       	sbci	r27, 0xFF	; 255
    345e:	fe 01       	movw	r30, r28
    3460:	e2 5b       	subi	r30, 0xB2	; 178
    3462:	ff 4f       	sbci	r31, 0xFF	; 255
    3464:	80 81       	ld	r24, Z
    3466:	91 81       	ldd	r25, Z+1	; 0x01
    3468:	11 96       	adiw	r26, 0x01	; 1
    346a:	9c 93       	st	X, r25
    346c:	8e 93       	st	-X, r24
    346e:	fe 01       	movw	r30, r28
    3470:	e6 5b       	subi	r30, 0xB6	; 182
    3472:	ff 4f       	sbci	r31, 0xFF	; 255
    3474:	80 81       	ld	r24, Z
    3476:	91 81       	ldd	r25, Z+1	; 0x01
    3478:	01 97       	sbiw	r24, 0x01	; 1
    347a:	f1 f7       	brne	.-4      	; 0x3478 <LCD_function_Set_4bit+0x992>
    347c:	fe 01       	movw	r30, r28
    347e:	e6 5b       	subi	r30, 0xB6	; 182
    3480:	ff 4f       	sbci	r31, 0xFF	; 255
    3482:	91 83       	std	Z+1, r25	; 0x01
    3484:	80 83       	st	Z, r24
    3486:	22 c0       	rjmp	.+68     	; 0x34cc <LCD_function_Set_4bit+0x9e6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3488:	8e 01       	movw	r16, r28
    348a:	08 5a       	subi	r16, 0xA8	; 168
    348c:	1f 4f       	sbci	r17, 0xFF	; 255
    348e:	fe 01       	movw	r30, r28
    3490:	e7 5a       	subi	r30, 0xA7	; 167
    3492:	ff 4f       	sbci	r31, 0xFF	; 255
    3494:	60 81       	ld	r22, Z
    3496:	71 81       	ldd	r23, Z+1	; 0x01
    3498:	82 81       	ldd	r24, Z+2	; 0x02
    349a:	93 81       	ldd	r25, Z+3	; 0x03
    349c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    34a0:	dc 01       	movw	r26, r24
    34a2:	cb 01       	movw	r24, r22
    34a4:	f8 01       	movw	r30, r16
    34a6:	80 83       	st	Z, r24
    34a8:	de 01       	movw	r26, r28
    34aa:	a7 5b       	subi	r26, 0xB7	; 183
    34ac:	bf 4f       	sbci	r27, 0xFF	; 255
    34ae:	fe 01       	movw	r30, r28
    34b0:	e8 5a       	subi	r30, 0xA8	; 168
    34b2:	ff 4f       	sbci	r31, 0xFF	; 255
    34b4:	80 81       	ld	r24, Z
    34b6:	8c 93       	st	X, r24
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    34b8:	fe 01       	movw	r30, r28
    34ba:	e7 5b       	subi	r30, 0xB7	; 183
    34bc:	ff 4f       	sbci	r31, 0xFF	; 255
    34be:	80 81       	ld	r24, Z
    34c0:	8a 95       	dec	r24
    34c2:	f1 f7       	brne	.-4      	; 0x34c0 <LCD_function_Set_4bit+0x9da>
    34c4:	fe 01       	movw	r30, r28
    34c6:	e7 5b       	subi	r30, 0xB7	; 183
    34c8:	ff 4f       	sbci	r31, 0xFF	; 255
    34ca:	80 83       	st	Z, r24
	_delay_us(1);
	//send the high nibble

	for(u8 i=0; i<4;i++){
    34cc:	fe 01       	movw	r30, r28
    34ce:	e6 55       	subi	r30, 0x56	; 86
    34d0:	ff 4f       	sbci	r31, 0xFF	; 255
    34d2:	10 82       	st	Z, r1
    34d4:	23 c0       	rjmp	.+70     	; 0x351c <LCD_function_Set_4bit+0xa36>

		DIO_void_assign_pin(lcd_data_port, i+4, get_Bit(0b0010,i));
    34d6:	fe 01       	movw	r30, r28
    34d8:	e6 55       	subi	r30, 0x56	; 86
    34da:	ff 4f       	sbci	r31, 0xFF	; 255
    34dc:	80 81       	ld	r24, Z
    34de:	48 2f       	mov	r20, r24
    34e0:	4c 5f       	subi	r20, 0xFC	; 252
    34e2:	fe 01       	movw	r30, r28
    34e4:	e6 55       	subi	r30, 0x56	; 86
    34e6:	ff 4f       	sbci	r31, 0xFF	; 255
    34e8:	80 81       	ld	r24, Z
    34ea:	28 2f       	mov	r18, r24
    34ec:	30 e0       	ldi	r19, 0x00	; 0
    34ee:	82 e0       	ldi	r24, 0x02	; 2
    34f0:	90 e0       	ldi	r25, 0x00	; 0
    34f2:	02 c0       	rjmp	.+4      	; 0x34f8 <LCD_function_Set_4bit+0xa12>
    34f4:	95 95       	asr	r25
    34f6:	87 95       	ror	r24
    34f8:	2a 95       	dec	r18
    34fa:	e2 f7       	brpl	.-8      	; 0x34f4 <LCD_function_Set_4bit+0xa0e>
    34fc:	98 2f       	mov	r25, r24
    34fe:	91 70       	andi	r25, 0x01	; 1
    3500:	82 e0       	ldi	r24, 0x02	; 2
    3502:	64 2f       	mov	r22, r20
    3504:	49 2f       	mov	r20, r25
    3506:	0e 94 b1 08 	call	0x1162	; 0x1162 <DIO_void_assign_pin>
	//send again high nibble to make sure
	DIO_void_set_pin(lcd_control_port, lcd_enable); // enable high
	_delay_us(1);
	//send the high nibble

	for(u8 i=0; i<4;i++){
    350a:	de 01       	movw	r26, r28
    350c:	a6 55       	subi	r26, 0x56	; 86
    350e:	bf 4f       	sbci	r27, 0xFF	; 255
    3510:	fe 01       	movw	r30, r28
    3512:	e6 55       	subi	r30, 0x56	; 86
    3514:	ff 4f       	sbci	r31, 0xFF	; 255
    3516:	80 81       	ld	r24, Z
    3518:	8f 5f       	subi	r24, 0xFF	; 255
    351a:	8c 93       	st	X, r24
    351c:	fe 01       	movw	r30, r28
    351e:	e6 55       	subi	r30, 0x56	; 86
    3520:	ff 4f       	sbci	r31, 0xFF	; 255
    3522:	80 81       	ld	r24, Z
    3524:	84 30       	cpi	r24, 0x04	; 4
    3526:	b8 f2       	brcs	.-82     	; 0x34d6 <LCD_function_Set_4bit+0x9f0>

		DIO_void_assign_pin(lcd_data_port, i+4, get_Bit(0b0010,i));
	}
	//enable pin low
	DIO_void_clear_pin(lcd_control_port, lcd_enable);
    3528:	83 e0       	ldi	r24, 0x03	; 3
    352a:	60 e0       	ldi	r22, 0x00	; 0
    352c:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>
    3530:	fe 01       	movw	r30, r28
    3532:	eb 5b       	subi	r30, 0xBB	; 187
    3534:	ff 4f       	sbci	r31, 0xFF	; 255
    3536:	80 e0       	ldi	r24, 0x00	; 0
    3538:	90 e0       	ldi	r25, 0x00	; 0
    353a:	a0 e2       	ldi	r26, 0x20	; 32
    353c:	b1 e4       	ldi	r27, 0x41	; 65
    353e:	80 83       	st	Z, r24
    3540:	91 83       	std	Z+1, r25	; 0x01
    3542:	a2 83       	std	Z+2, r26	; 0x02
    3544:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3546:	8e 01       	movw	r16, r28
    3548:	0f 5b       	subi	r16, 0xBF	; 191
    354a:	1f 4f       	sbci	r17, 0xFF	; 255
    354c:	fe 01       	movw	r30, r28
    354e:	eb 5b       	subi	r30, 0xBB	; 187
    3550:	ff 4f       	sbci	r31, 0xFF	; 255
    3552:	60 81       	ld	r22, Z
    3554:	71 81       	ldd	r23, Z+1	; 0x01
    3556:	82 81       	ldd	r24, Z+2	; 0x02
    3558:	93 81       	ldd	r25, Z+3	; 0x03
    355a:	2b ea       	ldi	r18, 0xAB	; 171
    355c:	3a ea       	ldi	r19, 0xAA	; 170
    355e:	4a e2       	ldi	r20, 0x2A	; 42
    3560:	50 e4       	ldi	r21, 0x40	; 64
    3562:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3566:	dc 01       	movw	r26, r24
    3568:	cb 01       	movw	r24, r22
    356a:	f8 01       	movw	r30, r16
    356c:	80 83       	st	Z, r24
    356e:	91 83       	std	Z+1, r25	; 0x01
    3570:	a2 83       	std	Z+2, r26	; 0x02
    3572:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3574:	fe 01       	movw	r30, r28
    3576:	ef 5b       	subi	r30, 0xBF	; 191
    3578:	ff 4f       	sbci	r31, 0xFF	; 255
    357a:	60 81       	ld	r22, Z
    357c:	71 81       	ldd	r23, Z+1	; 0x01
    357e:	82 81       	ldd	r24, Z+2	; 0x02
    3580:	93 81       	ldd	r25, Z+3	; 0x03
    3582:	20 e0       	ldi	r18, 0x00	; 0
    3584:	30 e0       	ldi	r19, 0x00	; 0
    3586:	40 e8       	ldi	r20, 0x80	; 128
    3588:	5f e3       	ldi	r21, 0x3F	; 63
    358a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    358e:	88 23       	and	r24, r24
    3590:	34 f4       	brge	.+12     	; 0x359e <LCD_function_Set_4bit+0xab8>
		__ticks = 1;
    3592:	81 e0       	ldi	r24, 0x01	; 1
    3594:	fe 01       	movw	r30, r28
    3596:	e0 5c       	subi	r30, 0xC0	; 192
    3598:	ff 4f       	sbci	r31, 0xFF	; 255
    359a:	80 83       	st	Z, r24
    359c:	9d c0       	rjmp	.+314    	; 0x36d8 <LCD_function_Set_4bit+0xbf2>
	else if (__tmp > 255)
    359e:	fe 01       	movw	r30, r28
    35a0:	ef 5b       	subi	r30, 0xBF	; 191
    35a2:	ff 4f       	sbci	r31, 0xFF	; 255
    35a4:	60 81       	ld	r22, Z
    35a6:	71 81       	ldd	r23, Z+1	; 0x01
    35a8:	82 81       	ldd	r24, Z+2	; 0x02
    35aa:	93 81       	ldd	r25, Z+3	; 0x03
    35ac:	20 e0       	ldi	r18, 0x00	; 0
    35ae:	30 e0       	ldi	r19, 0x00	; 0
    35b0:	4f e7       	ldi	r20, 0x7F	; 127
    35b2:	53 e4       	ldi	r21, 0x43	; 67
    35b4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    35b8:	18 16       	cp	r1, r24
    35ba:	0c f0       	brlt	.+2      	; 0x35be <LCD_function_Set_4bit+0xad8>
    35bc:	7e c0       	rjmp	.+252    	; 0x36ba <LCD_function_Set_4bit+0xbd4>
	{
		_delay_ms(__us / 1000.0);
    35be:	fe 01       	movw	r30, r28
    35c0:	eb 5b       	subi	r30, 0xBB	; 187
    35c2:	ff 4f       	sbci	r31, 0xFF	; 255
    35c4:	60 81       	ld	r22, Z
    35c6:	71 81       	ldd	r23, Z+1	; 0x01
    35c8:	82 81       	ldd	r24, Z+2	; 0x02
    35ca:	93 81       	ldd	r25, Z+3	; 0x03
    35cc:	20 e0       	ldi	r18, 0x00	; 0
    35ce:	30 e0       	ldi	r19, 0x00	; 0
    35d0:	4a e7       	ldi	r20, 0x7A	; 122
    35d2:	54 e4       	ldi	r21, 0x44	; 68
    35d4:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    35d8:	dc 01       	movw	r26, r24
    35da:	cb 01       	movw	r24, r22
    35dc:	8c af       	std	Y+60, r24	; 0x3c
    35de:	9d af       	std	Y+61, r25	; 0x3d
    35e0:	ae af       	std	Y+62, r26	; 0x3e
    35e2:	bf af       	std	Y+63, r27	; 0x3f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    35e4:	6c ad       	ldd	r22, Y+60	; 0x3c
    35e6:	7d ad       	ldd	r23, Y+61	; 0x3d
    35e8:	8e ad       	ldd	r24, Y+62	; 0x3e
    35ea:	9f ad       	ldd	r25, Y+63	; 0x3f
    35ec:	20 e0       	ldi	r18, 0x00	; 0
    35ee:	30 e0       	ldi	r19, 0x00	; 0
    35f0:	4a ef       	ldi	r20, 0xFA	; 250
    35f2:	54 e4       	ldi	r21, 0x44	; 68
    35f4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    35f8:	dc 01       	movw	r26, r24
    35fa:	cb 01       	movw	r24, r22
    35fc:	88 af       	std	Y+56, r24	; 0x38
    35fe:	99 af       	std	Y+57, r25	; 0x39
    3600:	aa af       	std	Y+58, r26	; 0x3a
    3602:	bb af       	std	Y+59, r27	; 0x3b
	if (__tmp < 1.0)
    3604:	68 ad       	ldd	r22, Y+56	; 0x38
    3606:	79 ad       	ldd	r23, Y+57	; 0x39
    3608:	8a ad       	ldd	r24, Y+58	; 0x3a
    360a:	9b ad       	ldd	r25, Y+59	; 0x3b
    360c:	20 e0       	ldi	r18, 0x00	; 0
    360e:	30 e0       	ldi	r19, 0x00	; 0
    3610:	40 e8       	ldi	r20, 0x80	; 128
    3612:	5f e3       	ldi	r21, 0x3F	; 63
    3614:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3618:	88 23       	and	r24, r24
    361a:	2c f4       	brge	.+10     	; 0x3626 <LCD_function_Set_4bit+0xb40>
		__ticks = 1;
    361c:	81 e0       	ldi	r24, 0x01	; 1
    361e:	90 e0       	ldi	r25, 0x00	; 0
    3620:	9f ab       	std	Y+55, r25	; 0x37
    3622:	8e ab       	std	Y+54, r24	; 0x36
    3624:	3f c0       	rjmp	.+126    	; 0x36a4 <LCD_function_Set_4bit+0xbbe>
	else if (__tmp > 65535)
    3626:	68 ad       	ldd	r22, Y+56	; 0x38
    3628:	79 ad       	ldd	r23, Y+57	; 0x39
    362a:	8a ad       	ldd	r24, Y+58	; 0x3a
    362c:	9b ad       	ldd	r25, Y+59	; 0x3b
    362e:	20 e0       	ldi	r18, 0x00	; 0
    3630:	3f ef       	ldi	r19, 0xFF	; 255
    3632:	4f e7       	ldi	r20, 0x7F	; 127
    3634:	57 e4       	ldi	r21, 0x47	; 71
    3636:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    363a:	18 16       	cp	r1, r24
    363c:	4c f5       	brge	.+82     	; 0x3690 <LCD_function_Set_4bit+0xbaa>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    363e:	6c ad       	ldd	r22, Y+60	; 0x3c
    3640:	7d ad       	ldd	r23, Y+61	; 0x3d
    3642:	8e ad       	ldd	r24, Y+62	; 0x3e
    3644:	9f ad       	ldd	r25, Y+63	; 0x3f
    3646:	20 e0       	ldi	r18, 0x00	; 0
    3648:	30 e0       	ldi	r19, 0x00	; 0
    364a:	40 e2       	ldi	r20, 0x20	; 32
    364c:	51 e4       	ldi	r21, 0x41	; 65
    364e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3652:	dc 01       	movw	r26, r24
    3654:	cb 01       	movw	r24, r22
    3656:	bc 01       	movw	r22, r24
    3658:	cd 01       	movw	r24, r26
    365a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    365e:	dc 01       	movw	r26, r24
    3660:	cb 01       	movw	r24, r22
    3662:	9f ab       	std	Y+55, r25	; 0x37
    3664:	8e ab       	std	Y+54, r24	; 0x36
    3666:	0f c0       	rjmp	.+30     	; 0x3686 <LCD_function_Set_4bit+0xba0>
    3668:	88 ec       	ldi	r24, 0xC8	; 200
    366a:	90 e0       	ldi	r25, 0x00	; 0
    366c:	9d ab       	std	Y+53, r25	; 0x35
    366e:	8c ab       	std	Y+52, r24	; 0x34
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3670:	8c a9       	ldd	r24, Y+52	; 0x34
    3672:	9d a9       	ldd	r25, Y+53	; 0x35
    3674:	01 97       	sbiw	r24, 0x01	; 1
    3676:	f1 f7       	brne	.-4      	; 0x3674 <LCD_function_Set_4bit+0xb8e>
    3678:	9d ab       	std	Y+53, r25	; 0x35
    367a:	8c ab       	std	Y+52, r24	; 0x34
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    367c:	8e a9       	ldd	r24, Y+54	; 0x36
    367e:	9f a9       	ldd	r25, Y+55	; 0x37
    3680:	01 97       	sbiw	r24, 0x01	; 1
    3682:	9f ab       	std	Y+55, r25	; 0x37
    3684:	8e ab       	std	Y+54, r24	; 0x36
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3686:	8e a9       	ldd	r24, Y+54	; 0x36
    3688:	9f a9       	ldd	r25, Y+55	; 0x37
    368a:	00 97       	sbiw	r24, 0x00	; 0
    368c:	69 f7       	brne	.-38     	; 0x3668 <LCD_function_Set_4bit+0xb82>
    368e:	2d c0       	rjmp	.+90     	; 0x36ea <LCD_function_Set_4bit+0xc04>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3690:	68 ad       	ldd	r22, Y+56	; 0x38
    3692:	79 ad       	ldd	r23, Y+57	; 0x39
    3694:	8a ad       	ldd	r24, Y+58	; 0x3a
    3696:	9b ad       	ldd	r25, Y+59	; 0x3b
    3698:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    369c:	dc 01       	movw	r26, r24
    369e:	cb 01       	movw	r24, r22
    36a0:	9f ab       	std	Y+55, r25	; 0x37
    36a2:	8e ab       	std	Y+54, r24	; 0x36
    36a4:	8e a9       	ldd	r24, Y+54	; 0x36
    36a6:	9f a9       	ldd	r25, Y+55	; 0x37
    36a8:	9b ab       	std	Y+51, r25	; 0x33
    36aa:	8a ab       	std	Y+50, r24	; 0x32
    36ac:	8a a9       	ldd	r24, Y+50	; 0x32
    36ae:	9b a9       	ldd	r25, Y+51	; 0x33
    36b0:	01 97       	sbiw	r24, 0x01	; 1
    36b2:	f1 f7       	brne	.-4      	; 0x36b0 <LCD_function_Set_4bit+0xbca>
    36b4:	9b ab       	std	Y+51, r25	; 0x33
    36b6:	8a ab       	std	Y+50, r24	; 0x32
    36b8:	18 c0       	rjmp	.+48     	; 0x36ea <LCD_function_Set_4bit+0xc04>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    36ba:	fe 01       	movw	r30, r28
    36bc:	ef 5b       	subi	r30, 0xBF	; 191
    36be:	ff 4f       	sbci	r31, 0xFF	; 255
    36c0:	60 81       	ld	r22, Z
    36c2:	71 81       	ldd	r23, Z+1	; 0x01
    36c4:	82 81       	ldd	r24, Z+2	; 0x02
    36c6:	93 81       	ldd	r25, Z+3	; 0x03
    36c8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    36cc:	dc 01       	movw	r26, r24
    36ce:	cb 01       	movw	r24, r22
    36d0:	fe 01       	movw	r30, r28
    36d2:	e0 5c       	subi	r30, 0xC0	; 192
    36d4:	ff 4f       	sbci	r31, 0xFF	; 255
    36d6:	80 83       	st	Z, r24
    36d8:	fe 01       	movw	r30, r28
    36da:	e0 5c       	subi	r30, 0xC0	; 192
    36dc:	ff 4f       	sbci	r31, 0xFF	; 255
    36de:	80 81       	ld	r24, Z
    36e0:	89 ab       	std	Y+49, r24	; 0x31
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    36e2:	89 a9       	ldd	r24, Y+49	; 0x31
    36e4:	8a 95       	dec	r24
    36e6:	f1 f7       	brne	.-4      	; 0x36e4 <LCD_function_Set_4bit+0xbfe>
    36e8:	89 ab       	std	Y+49, r24	; 0x31
	_delay_us(10);
	//send the low nibble
	DIO_void_set_pin(lcd_control_port, lcd_enable); // enable high
    36ea:	83 e0       	ldi	r24, 0x03	; 3
    36ec:	60 e0       	ldi	r22, 0x00	; 0
    36ee:	0e 94 50 08 	call	0x10a0	; 0x10a0 <DIO_void_set_pin>
    36f2:	80 e0       	ldi	r24, 0x00	; 0
    36f4:	90 e0       	ldi	r25, 0x00	; 0
    36f6:	a0 e8       	ldi	r26, 0x80	; 128
    36f8:	bf e3       	ldi	r27, 0x3F	; 63
    36fa:	8d a7       	std	Y+45, r24	; 0x2d
    36fc:	9e a7       	std	Y+46, r25	; 0x2e
    36fe:	af a7       	std	Y+47, r26	; 0x2f
    3700:	b8 ab       	std	Y+48, r27	; 0x30
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3702:	6d a5       	ldd	r22, Y+45	; 0x2d
    3704:	7e a5       	ldd	r23, Y+46	; 0x2e
    3706:	8f a5       	ldd	r24, Y+47	; 0x2f
    3708:	98 a9       	ldd	r25, Y+48	; 0x30
    370a:	2b ea       	ldi	r18, 0xAB	; 171
    370c:	3a ea       	ldi	r19, 0xAA	; 170
    370e:	4a e2       	ldi	r20, 0x2A	; 42
    3710:	50 e4       	ldi	r21, 0x40	; 64
    3712:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3716:	dc 01       	movw	r26, r24
    3718:	cb 01       	movw	r24, r22
    371a:	89 a7       	std	Y+41, r24	; 0x29
    371c:	9a a7       	std	Y+42, r25	; 0x2a
    371e:	ab a7       	std	Y+43, r26	; 0x2b
    3720:	bc a7       	std	Y+44, r27	; 0x2c
	if (__tmp < 1.0)
    3722:	69 a5       	ldd	r22, Y+41	; 0x29
    3724:	7a a5       	ldd	r23, Y+42	; 0x2a
    3726:	8b a5       	ldd	r24, Y+43	; 0x2b
    3728:	9c a5       	ldd	r25, Y+44	; 0x2c
    372a:	20 e0       	ldi	r18, 0x00	; 0
    372c:	30 e0       	ldi	r19, 0x00	; 0
    372e:	40 e8       	ldi	r20, 0x80	; 128
    3730:	5f e3       	ldi	r21, 0x3F	; 63
    3732:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3736:	88 23       	and	r24, r24
    3738:	1c f4       	brge	.+6      	; 0x3740 <LCD_function_Set_4bit+0xc5a>
		__ticks = 1;
    373a:	81 e0       	ldi	r24, 0x01	; 1
    373c:	88 a7       	std	Y+40, r24	; 0x28
    373e:	91 c0       	rjmp	.+290    	; 0x3862 <LCD_function_Set_4bit+0xd7c>
	else if (__tmp > 255)
    3740:	69 a5       	ldd	r22, Y+41	; 0x29
    3742:	7a a5       	ldd	r23, Y+42	; 0x2a
    3744:	8b a5       	ldd	r24, Y+43	; 0x2b
    3746:	9c a5       	ldd	r25, Y+44	; 0x2c
    3748:	20 e0       	ldi	r18, 0x00	; 0
    374a:	30 e0       	ldi	r19, 0x00	; 0
    374c:	4f e7       	ldi	r20, 0x7F	; 127
    374e:	53 e4       	ldi	r21, 0x43	; 67
    3750:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3754:	18 16       	cp	r1, r24
    3756:	0c f0       	brlt	.+2      	; 0x375a <LCD_function_Set_4bit+0xc74>
    3758:	7b c0       	rjmp	.+246    	; 0x3850 <LCD_function_Set_4bit+0xd6a>
	{
		_delay_ms(__us / 1000.0);
    375a:	6d a5       	ldd	r22, Y+45	; 0x2d
    375c:	7e a5       	ldd	r23, Y+46	; 0x2e
    375e:	8f a5       	ldd	r24, Y+47	; 0x2f
    3760:	98 a9       	ldd	r25, Y+48	; 0x30
    3762:	20 e0       	ldi	r18, 0x00	; 0
    3764:	30 e0       	ldi	r19, 0x00	; 0
    3766:	4a e7       	ldi	r20, 0x7A	; 122
    3768:	54 e4       	ldi	r21, 0x44	; 68
    376a:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    376e:	dc 01       	movw	r26, r24
    3770:	cb 01       	movw	r24, r22
    3772:	8c a3       	std	Y+36, r24	; 0x24
    3774:	9d a3       	std	Y+37, r25	; 0x25
    3776:	ae a3       	std	Y+38, r26	; 0x26
    3778:	bf a3       	std	Y+39, r27	; 0x27
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    377a:	6c a1       	ldd	r22, Y+36	; 0x24
    377c:	7d a1       	ldd	r23, Y+37	; 0x25
    377e:	8e a1       	ldd	r24, Y+38	; 0x26
    3780:	9f a1       	ldd	r25, Y+39	; 0x27
    3782:	20 e0       	ldi	r18, 0x00	; 0
    3784:	30 e0       	ldi	r19, 0x00	; 0
    3786:	4a ef       	ldi	r20, 0xFA	; 250
    3788:	54 e4       	ldi	r21, 0x44	; 68
    378a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    378e:	dc 01       	movw	r26, r24
    3790:	cb 01       	movw	r24, r22
    3792:	88 a3       	std	Y+32, r24	; 0x20
    3794:	99 a3       	std	Y+33, r25	; 0x21
    3796:	aa a3       	std	Y+34, r26	; 0x22
    3798:	bb a3       	std	Y+35, r27	; 0x23
	if (__tmp < 1.0)
    379a:	68 a1       	ldd	r22, Y+32	; 0x20
    379c:	79 a1       	ldd	r23, Y+33	; 0x21
    379e:	8a a1       	ldd	r24, Y+34	; 0x22
    37a0:	9b a1       	ldd	r25, Y+35	; 0x23
    37a2:	20 e0       	ldi	r18, 0x00	; 0
    37a4:	30 e0       	ldi	r19, 0x00	; 0
    37a6:	40 e8       	ldi	r20, 0x80	; 128
    37a8:	5f e3       	ldi	r21, 0x3F	; 63
    37aa:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    37ae:	88 23       	and	r24, r24
    37b0:	2c f4       	brge	.+10     	; 0x37bc <LCD_function_Set_4bit+0xcd6>
		__ticks = 1;
    37b2:	81 e0       	ldi	r24, 0x01	; 1
    37b4:	90 e0       	ldi	r25, 0x00	; 0
    37b6:	9f 8f       	std	Y+31, r25	; 0x1f
    37b8:	8e 8f       	std	Y+30, r24	; 0x1e
    37ba:	3f c0       	rjmp	.+126    	; 0x383a <LCD_function_Set_4bit+0xd54>
	else if (__tmp > 65535)
    37bc:	68 a1       	ldd	r22, Y+32	; 0x20
    37be:	79 a1       	ldd	r23, Y+33	; 0x21
    37c0:	8a a1       	ldd	r24, Y+34	; 0x22
    37c2:	9b a1       	ldd	r25, Y+35	; 0x23
    37c4:	20 e0       	ldi	r18, 0x00	; 0
    37c6:	3f ef       	ldi	r19, 0xFF	; 255
    37c8:	4f e7       	ldi	r20, 0x7F	; 127
    37ca:	57 e4       	ldi	r21, 0x47	; 71
    37cc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    37d0:	18 16       	cp	r1, r24
    37d2:	4c f5       	brge	.+82     	; 0x3826 <LCD_function_Set_4bit+0xd40>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    37d4:	6c a1       	ldd	r22, Y+36	; 0x24
    37d6:	7d a1       	ldd	r23, Y+37	; 0x25
    37d8:	8e a1       	ldd	r24, Y+38	; 0x26
    37da:	9f a1       	ldd	r25, Y+39	; 0x27
    37dc:	20 e0       	ldi	r18, 0x00	; 0
    37de:	30 e0       	ldi	r19, 0x00	; 0
    37e0:	40 e2       	ldi	r20, 0x20	; 32
    37e2:	51 e4       	ldi	r21, 0x41	; 65
    37e4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    37e8:	dc 01       	movw	r26, r24
    37ea:	cb 01       	movw	r24, r22
    37ec:	bc 01       	movw	r22, r24
    37ee:	cd 01       	movw	r24, r26
    37f0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    37f4:	dc 01       	movw	r26, r24
    37f6:	cb 01       	movw	r24, r22
    37f8:	9f 8f       	std	Y+31, r25	; 0x1f
    37fa:	8e 8f       	std	Y+30, r24	; 0x1e
    37fc:	0f c0       	rjmp	.+30     	; 0x381c <LCD_function_Set_4bit+0xd36>
    37fe:	88 ec       	ldi	r24, 0xC8	; 200
    3800:	90 e0       	ldi	r25, 0x00	; 0
    3802:	9d 8f       	std	Y+29, r25	; 0x1d
    3804:	8c 8f       	std	Y+28, r24	; 0x1c
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3806:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3808:	9d 8d       	ldd	r25, Y+29	; 0x1d
    380a:	01 97       	sbiw	r24, 0x01	; 1
    380c:	f1 f7       	brne	.-4      	; 0x380a <LCD_function_Set_4bit+0xd24>
    380e:	9d 8f       	std	Y+29, r25	; 0x1d
    3810:	8c 8f       	std	Y+28, r24	; 0x1c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3812:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3814:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3816:	01 97       	sbiw	r24, 0x01	; 1
    3818:	9f 8f       	std	Y+31, r25	; 0x1f
    381a:	8e 8f       	std	Y+30, r24	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    381c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    381e:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3820:	00 97       	sbiw	r24, 0x00	; 0
    3822:	69 f7       	brne	.-38     	; 0x37fe <LCD_function_Set_4bit+0xd18>
    3824:	24 c0       	rjmp	.+72     	; 0x386e <LCD_function_Set_4bit+0xd88>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3826:	68 a1       	ldd	r22, Y+32	; 0x20
    3828:	79 a1       	ldd	r23, Y+33	; 0x21
    382a:	8a a1       	ldd	r24, Y+34	; 0x22
    382c:	9b a1       	ldd	r25, Y+35	; 0x23
    382e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3832:	dc 01       	movw	r26, r24
    3834:	cb 01       	movw	r24, r22
    3836:	9f 8f       	std	Y+31, r25	; 0x1f
    3838:	8e 8f       	std	Y+30, r24	; 0x1e
    383a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    383c:	9f 8d       	ldd	r25, Y+31	; 0x1f
    383e:	9b 8f       	std	Y+27, r25	; 0x1b
    3840:	8a 8f       	std	Y+26, r24	; 0x1a
    3842:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3844:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3846:	01 97       	sbiw	r24, 0x01	; 1
    3848:	f1 f7       	brne	.-4      	; 0x3846 <LCD_function_Set_4bit+0xd60>
    384a:	9b 8f       	std	Y+27, r25	; 0x1b
    384c:	8a 8f       	std	Y+26, r24	; 0x1a
    384e:	0f c0       	rjmp	.+30     	; 0x386e <LCD_function_Set_4bit+0xd88>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3850:	69 a5       	ldd	r22, Y+41	; 0x29
    3852:	7a a5       	ldd	r23, Y+42	; 0x2a
    3854:	8b a5       	ldd	r24, Y+43	; 0x2b
    3856:	9c a5       	ldd	r25, Y+44	; 0x2c
    3858:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    385c:	dc 01       	movw	r26, r24
    385e:	cb 01       	movw	r24, r22
    3860:	88 a7       	std	Y+40, r24	; 0x28
    3862:	88 a5       	ldd	r24, Y+40	; 0x28
    3864:	89 8f       	std	Y+25, r24	; 0x19
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3866:	89 8d       	ldd	r24, Y+25	; 0x19
    3868:	8a 95       	dec	r24
    386a:	f1 f7       	brne	.-4      	; 0x3868 <LCD_function_Set_4bit+0xd82>
    386c:	89 8f       	std	Y+25, r24	; 0x19
	_delay_us(1);
	//send the high nibble

	for(u8 i=0; i<4;i++){
    386e:	fe 01       	movw	r30, r28
    3870:	e7 55       	subi	r30, 0x57	; 87
    3872:	ff 4f       	sbci	r31, 0xFF	; 255
    3874:	10 82       	st	Z, r1
    3876:	23 c0       	rjmp	.+70     	; 0x38be <LCD_function_Set_4bit+0xdd8>

		DIO_void_assign_pin(lcd_data_port, i+4, get_Bit(0b1000,i));
    3878:	fe 01       	movw	r30, r28
    387a:	e7 55       	subi	r30, 0x57	; 87
    387c:	ff 4f       	sbci	r31, 0xFF	; 255
    387e:	80 81       	ld	r24, Z
    3880:	48 2f       	mov	r20, r24
    3882:	4c 5f       	subi	r20, 0xFC	; 252
    3884:	fe 01       	movw	r30, r28
    3886:	e7 55       	subi	r30, 0x57	; 87
    3888:	ff 4f       	sbci	r31, 0xFF	; 255
    388a:	80 81       	ld	r24, Z
    388c:	28 2f       	mov	r18, r24
    388e:	30 e0       	ldi	r19, 0x00	; 0
    3890:	88 e0       	ldi	r24, 0x08	; 8
    3892:	90 e0       	ldi	r25, 0x00	; 0
    3894:	02 c0       	rjmp	.+4      	; 0x389a <LCD_function_Set_4bit+0xdb4>
    3896:	95 95       	asr	r25
    3898:	87 95       	ror	r24
    389a:	2a 95       	dec	r18
    389c:	e2 f7       	brpl	.-8      	; 0x3896 <LCD_function_Set_4bit+0xdb0>
    389e:	98 2f       	mov	r25, r24
    38a0:	91 70       	andi	r25, 0x01	; 1
    38a2:	82 e0       	ldi	r24, 0x02	; 2
    38a4:	64 2f       	mov	r22, r20
    38a6:	49 2f       	mov	r20, r25
    38a8:	0e 94 b1 08 	call	0x1162	; 0x1162 <DIO_void_assign_pin>
	//send the low nibble
	DIO_void_set_pin(lcd_control_port, lcd_enable); // enable high
	_delay_us(1);
	//send the high nibble

	for(u8 i=0; i<4;i++){
    38ac:	de 01       	movw	r26, r28
    38ae:	a7 55       	subi	r26, 0x57	; 87
    38b0:	bf 4f       	sbci	r27, 0xFF	; 255
    38b2:	fe 01       	movw	r30, r28
    38b4:	e7 55       	subi	r30, 0x57	; 87
    38b6:	ff 4f       	sbci	r31, 0xFF	; 255
    38b8:	80 81       	ld	r24, Z
    38ba:	8f 5f       	subi	r24, 0xFF	; 255
    38bc:	8c 93       	st	X, r24
    38be:	fe 01       	movw	r30, r28
    38c0:	e7 55       	subi	r30, 0x57	; 87
    38c2:	ff 4f       	sbci	r31, 0xFF	; 255
    38c4:	80 81       	ld	r24, Z
    38c6:	84 30       	cpi	r24, 0x04	; 4
    38c8:	b8 f2       	brcs	.-82     	; 0x3878 <LCD_function_Set_4bit+0xd92>

		DIO_void_assign_pin(lcd_data_port, i+4, get_Bit(0b1000,i));
	}
	//enable pin low
	DIO_void_clear_pin(lcd_control_port, lcd_enable);
    38ca:	83 e0       	ldi	r24, 0x03	; 3
    38cc:	60 e0       	ldi	r22, 0x00	; 0
    38ce:	0e 94 80 08 	call	0x1100	; 0x1100 <DIO_void_clear_pin>
    38d2:	80 e0       	ldi	r24, 0x00	; 0
    38d4:	90 e0       	ldi	r25, 0x00	; 0
    38d6:	a0 e2       	ldi	r26, 0x20	; 32
    38d8:	b1 e4       	ldi	r27, 0x41	; 65
    38da:	8d 8b       	std	Y+21, r24	; 0x15
    38dc:	9e 8b       	std	Y+22, r25	; 0x16
    38de:	af 8b       	std	Y+23, r26	; 0x17
    38e0:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    38e2:	6d 89       	ldd	r22, Y+21	; 0x15
    38e4:	7e 89       	ldd	r23, Y+22	; 0x16
    38e6:	8f 89       	ldd	r24, Y+23	; 0x17
    38e8:	98 8d       	ldd	r25, Y+24	; 0x18
    38ea:	2b ea       	ldi	r18, 0xAB	; 171
    38ec:	3a ea       	ldi	r19, 0xAA	; 170
    38ee:	4a e2       	ldi	r20, 0x2A	; 42
    38f0:	50 e4       	ldi	r21, 0x40	; 64
    38f2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    38f6:	dc 01       	movw	r26, r24
    38f8:	cb 01       	movw	r24, r22
    38fa:	89 8b       	std	Y+17, r24	; 0x11
    38fc:	9a 8b       	std	Y+18, r25	; 0x12
    38fe:	ab 8b       	std	Y+19, r26	; 0x13
    3900:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    3902:	69 89       	ldd	r22, Y+17	; 0x11
    3904:	7a 89       	ldd	r23, Y+18	; 0x12
    3906:	8b 89       	ldd	r24, Y+19	; 0x13
    3908:	9c 89       	ldd	r25, Y+20	; 0x14
    390a:	20 e0       	ldi	r18, 0x00	; 0
    390c:	30 e0       	ldi	r19, 0x00	; 0
    390e:	40 e8       	ldi	r20, 0x80	; 128
    3910:	5f e3       	ldi	r21, 0x3F	; 63
    3912:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3916:	88 23       	and	r24, r24
    3918:	1c f4       	brge	.+6      	; 0x3920 <LCD_function_Set_4bit+0xe3a>
		__ticks = 1;
    391a:	81 e0       	ldi	r24, 0x01	; 1
    391c:	88 8b       	std	Y+16, r24	; 0x10
    391e:	91 c0       	rjmp	.+290    	; 0x3a42 <LCD_function_Set_4bit+0xf5c>
	else if (__tmp > 255)
    3920:	69 89       	ldd	r22, Y+17	; 0x11
    3922:	7a 89       	ldd	r23, Y+18	; 0x12
    3924:	8b 89       	ldd	r24, Y+19	; 0x13
    3926:	9c 89       	ldd	r25, Y+20	; 0x14
    3928:	20 e0       	ldi	r18, 0x00	; 0
    392a:	30 e0       	ldi	r19, 0x00	; 0
    392c:	4f e7       	ldi	r20, 0x7F	; 127
    392e:	53 e4       	ldi	r21, 0x43	; 67
    3930:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3934:	18 16       	cp	r1, r24
    3936:	0c f0       	brlt	.+2      	; 0x393a <LCD_function_Set_4bit+0xe54>
    3938:	7b c0       	rjmp	.+246    	; 0x3a30 <LCD_function_Set_4bit+0xf4a>
	{
		_delay_ms(__us / 1000.0);
    393a:	6d 89       	ldd	r22, Y+21	; 0x15
    393c:	7e 89       	ldd	r23, Y+22	; 0x16
    393e:	8f 89       	ldd	r24, Y+23	; 0x17
    3940:	98 8d       	ldd	r25, Y+24	; 0x18
    3942:	20 e0       	ldi	r18, 0x00	; 0
    3944:	30 e0       	ldi	r19, 0x00	; 0
    3946:	4a e7       	ldi	r20, 0x7A	; 122
    3948:	54 e4       	ldi	r21, 0x44	; 68
    394a:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    394e:	dc 01       	movw	r26, r24
    3950:	cb 01       	movw	r24, r22
    3952:	8c 87       	std	Y+12, r24	; 0x0c
    3954:	9d 87       	std	Y+13, r25	; 0x0d
    3956:	ae 87       	std	Y+14, r26	; 0x0e
    3958:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    395a:	6c 85       	ldd	r22, Y+12	; 0x0c
    395c:	7d 85       	ldd	r23, Y+13	; 0x0d
    395e:	8e 85       	ldd	r24, Y+14	; 0x0e
    3960:	9f 85       	ldd	r25, Y+15	; 0x0f
    3962:	20 e0       	ldi	r18, 0x00	; 0
    3964:	30 e0       	ldi	r19, 0x00	; 0
    3966:	4a ef       	ldi	r20, 0xFA	; 250
    3968:	54 e4       	ldi	r21, 0x44	; 68
    396a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    396e:	dc 01       	movw	r26, r24
    3970:	cb 01       	movw	r24, r22
    3972:	88 87       	std	Y+8, r24	; 0x08
    3974:	99 87       	std	Y+9, r25	; 0x09
    3976:	aa 87       	std	Y+10, r26	; 0x0a
    3978:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    397a:	68 85       	ldd	r22, Y+8	; 0x08
    397c:	79 85       	ldd	r23, Y+9	; 0x09
    397e:	8a 85       	ldd	r24, Y+10	; 0x0a
    3980:	9b 85       	ldd	r25, Y+11	; 0x0b
    3982:	20 e0       	ldi	r18, 0x00	; 0
    3984:	30 e0       	ldi	r19, 0x00	; 0
    3986:	40 e8       	ldi	r20, 0x80	; 128
    3988:	5f e3       	ldi	r21, 0x3F	; 63
    398a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    398e:	88 23       	and	r24, r24
    3990:	2c f4       	brge	.+10     	; 0x399c <LCD_function_Set_4bit+0xeb6>
		__ticks = 1;
    3992:	81 e0       	ldi	r24, 0x01	; 1
    3994:	90 e0       	ldi	r25, 0x00	; 0
    3996:	9f 83       	std	Y+7, r25	; 0x07
    3998:	8e 83       	std	Y+6, r24	; 0x06
    399a:	3f c0       	rjmp	.+126    	; 0x3a1a <LCD_function_Set_4bit+0xf34>
	else if (__tmp > 65535)
    399c:	68 85       	ldd	r22, Y+8	; 0x08
    399e:	79 85       	ldd	r23, Y+9	; 0x09
    39a0:	8a 85       	ldd	r24, Y+10	; 0x0a
    39a2:	9b 85       	ldd	r25, Y+11	; 0x0b
    39a4:	20 e0       	ldi	r18, 0x00	; 0
    39a6:	3f ef       	ldi	r19, 0xFF	; 255
    39a8:	4f e7       	ldi	r20, 0x7F	; 127
    39aa:	57 e4       	ldi	r21, 0x47	; 71
    39ac:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    39b0:	18 16       	cp	r1, r24
    39b2:	4c f5       	brge	.+82     	; 0x3a06 <LCD_function_Set_4bit+0xf20>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    39b4:	6c 85       	ldd	r22, Y+12	; 0x0c
    39b6:	7d 85       	ldd	r23, Y+13	; 0x0d
    39b8:	8e 85       	ldd	r24, Y+14	; 0x0e
    39ba:	9f 85       	ldd	r25, Y+15	; 0x0f
    39bc:	20 e0       	ldi	r18, 0x00	; 0
    39be:	30 e0       	ldi	r19, 0x00	; 0
    39c0:	40 e2       	ldi	r20, 0x20	; 32
    39c2:	51 e4       	ldi	r21, 0x41	; 65
    39c4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    39c8:	dc 01       	movw	r26, r24
    39ca:	cb 01       	movw	r24, r22
    39cc:	bc 01       	movw	r22, r24
    39ce:	cd 01       	movw	r24, r26
    39d0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    39d4:	dc 01       	movw	r26, r24
    39d6:	cb 01       	movw	r24, r22
    39d8:	9f 83       	std	Y+7, r25	; 0x07
    39da:	8e 83       	std	Y+6, r24	; 0x06
    39dc:	0f c0       	rjmp	.+30     	; 0x39fc <LCD_function_Set_4bit+0xf16>
    39de:	88 ec       	ldi	r24, 0xC8	; 200
    39e0:	90 e0       	ldi	r25, 0x00	; 0
    39e2:	9d 83       	std	Y+5, r25	; 0x05
    39e4:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    39e6:	8c 81       	ldd	r24, Y+4	; 0x04
    39e8:	9d 81       	ldd	r25, Y+5	; 0x05
    39ea:	01 97       	sbiw	r24, 0x01	; 1
    39ec:	f1 f7       	brne	.-4      	; 0x39ea <LCD_function_Set_4bit+0xf04>
    39ee:	9d 83       	std	Y+5, r25	; 0x05
    39f0:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    39f2:	8e 81       	ldd	r24, Y+6	; 0x06
    39f4:	9f 81       	ldd	r25, Y+7	; 0x07
    39f6:	01 97       	sbiw	r24, 0x01	; 1
    39f8:	9f 83       	std	Y+7, r25	; 0x07
    39fa:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    39fc:	8e 81       	ldd	r24, Y+6	; 0x06
    39fe:	9f 81       	ldd	r25, Y+7	; 0x07
    3a00:	00 97       	sbiw	r24, 0x00	; 0
    3a02:	69 f7       	brne	.-38     	; 0x39de <LCD_function_Set_4bit+0xef8>
    3a04:	24 c0       	rjmp	.+72     	; 0x3a4e <LCD_function_Set_4bit+0xf68>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3a06:	68 85       	ldd	r22, Y+8	; 0x08
    3a08:	79 85       	ldd	r23, Y+9	; 0x09
    3a0a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3a0c:	9b 85       	ldd	r25, Y+11	; 0x0b
    3a0e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3a12:	dc 01       	movw	r26, r24
    3a14:	cb 01       	movw	r24, r22
    3a16:	9f 83       	std	Y+7, r25	; 0x07
    3a18:	8e 83       	std	Y+6, r24	; 0x06
    3a1a:	8e 81       	ldd	r24, Y+6	; 0x06
    3a1c:	9f 81       	ldd	r25, Y+7	; 0x07
    3a1e:	9b 83       	std	Y+3, r25	; 0x03
    3a20:	8a 83       	std	Y+2, r24	; 0x02
    3a22:	8a 81       	ldd	r24, Y+2	; 0x02
    3a24:	9b 81       	ldd	r25, Y+3	; 0x03
    3a26:	01 97       	sbiw	r24, 0x01	; 1
    3a28:	f1 f7       	brne	.-4      	; 0x3a26 <LCD_function_Set_4bit+0xf40>
    3a2a:	9b 83       	std	Y+3, r25	; 0x03
    3a2c:	8a 83       	std	Y+2, r24	; 0x02
    3a2e:	0f c0       	rjmp	.+30     	; 0x3a4e <LCD_function_Set_4bit+0xf68>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3a30:	69 89       	ldd	r22, Y+17	; 0x11
    3a32:	7a 89       	ldd	r23, Y+18	; 0x12
    3a34:	8b 89       	ldd	r24, Y+19	; 0x13
    3a36:	9c 89       	ldd	r25, Y+20	; 0x14
    3a38:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3a3c:	dc 01       	movw	r26, r24
    3a3e:	cb 01       	movw	r24, r22
    3a40:	88 8b       	std	Y+16, r24	; 0x10
    3a42:	88 89       	ldd	r24, Y+16	; 0x10
    3a44:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3a46:	89 81       	ldd	r24, Y+1	; 0x01
    3a48:	8a 95       	dec	r24
    3a4a:	f1 f7       	brne	.-4      	; 0x3a48 <LCD_function_Set_4bit+0xf62>
    3a4c:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(10);

}
    3a4e:	c5 55       	subi	r28, 0x55	; 85
    3a50:	df 4f       	sbci	r29, 0xFF	; 255
    3a52:	0f b6       	in	r0, 0x3f	; 63
    3a54:	f8 94       	cli
    3a56:	de bf       	out	0x3e, r29	; 62
    3a58:	0f be       	out	0x3f, r0	; 63
    3a5a:	cd bf       	out	0x3d, r28	; 61
    3a5c:	cf 91       	pop	r28
    3a5e:	df 91       	pop	r29
    3a60:	1f 91       	pop	r17
    3a62:	0f 91       	pop	r16
    3a64:	08 95       	ret

00003a66 <LCD_init>:



/* Driver features functions for the user */

void LCD_init(){
    3a66:	0f 93       	push	r16
    3a68:	1f 93       	push	r17
    3a6a:	df 93       	push	r29
    3a6c:	cf 93       	push	r28
    3a6e:	cd b7       	in	r28, 0x3d	; 61
    3a70:	de b7       	in	r29, 0x3e	; 62
    3a72:	cc 54       	subi	r28, 0x4C	; 76
    3a74:	d0 40       	sbci	r29, 0x00	; 0
    3a76:	0f b6       	in	r0, 0x3f	; 63
    3a78:	f8 94       	cli
    3a7a:	de bf       	out	0x3e, r29	; 62
    3a7c:	0f be       	out	0x3f, r0	; 63
    3a7e:	cd bf       	out	0x3d, r28	; 61

#elif LCD_interface_mode == interface_4bit


	// configure data pins direction
	DIO_void_set_pin_dir(lcd_data_port, B7, OUTPUT);
    3a80:	82 e0       	ldi	r24, 0x02	; 2
    3a82:	67 e0       	ldi	r22, 0x07	; 7
    3a84:	41 e0       	ldi	r20, 0x01	; 1
    3a86:	0e 94 15 07 	call	0xe2a	; 0xe2a <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_data_port, B6, OUTPUT);
    3a8a:	82 e0       	ldi	r24, 0x02	; 2
    3a8c:	66 e0       	ldi	r22, 0x06	; 6
    3a8e:	41 e0       	ldi	r20, 0x01	; 1
    3a90:	0e 94 15 07 	call	0xe2a	; 0xe2a <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_data_port, B5, OUTPUT);
    3a94:	82 e0       	ldi	r24, 0x02	; 2
    3a96:	65 e0       	ldi	r22, 0x05	; 5
    3a98:	41 e0       	ldi	r20, 0x01	; 1
    3a9a:	0e 94 15 07 	call	0xe2a	; 0xe2a <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_data_port, B4, OUTPUT);
    3a9e:	82 e0       	ldi	r24, 0x02	; 2
    3aa0:	64 e0       	ldi	r22, 0x04	; 4
    3aa2:	41 e0       	ldi	r20, 0x01	; 1
    3aa4:	0e 94 15 07 	call	0xe2a	; 0xe2a <DIO_void_set_pin_dir>
	// RS,RW,E as  output
	DIO_void_set_pin_dir(lcd_control_port, lcd_RS, OUTPUT);
    3aa8:	83 e0       	ldi	r24, 0x03	; 3
    3aaa:	62 e0       	ldi	r22, 0x02	; 2
    3aac:	41 e0       	ldi	r20, 0x01	; 1
    3aae:	0e 94 15 07 	call	0xe2a	; 0xe2a <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_control_port, lcd_RW, OUTPUT);
    3ab2:	83 e0       	ldi	r24, 0x03	; 3
    3ab4:	61 e0       	ldi	r22, 0x01	; 1
    3ab6:	41 e0       	ldi	r20, 0x01	; 1
    3ab8:	0e 94 15 07 	call	0xe2a	; 0xe2a <DIO_void_set_pin_dir>
	DIO_void_set_pin_dir(lcd_control_port, lcd_enable, OUTPUT);
    3abc:	83 e0       	ldi	r24, 0x03	; 3
    3abe:	60 e0       	ldi	r22, 0x00	; 0
    3ac0:	41 e0       	ldi	r20, 0x01	; 1
    3ac2:	0e 94 15 07 	call	0xe2a	; 0xe2a <DIO_void_set_pin_dir>
    3ac6:	fe 01       	movw	r30, r28
    3ac8:	e7 5b       	subi	r30, 0xB7	; 183
    3aca:	ff 4f       	sbci	r31, 0xFF	; 255
    3acc:	80 e0       	ldi	r24, 0x00	; 0
    3ace:	90 e0       	ldi	r25, 0x00	; 0
    3ad0:	a8 e4       	ldi	r26, 0x48	; 72
    3ad2:	b2 e4       	ldi	r27, 0x42	; 66
    3ad4:	80 83       	st	Z, r24
    3ad6:	91 83       	std	Z+1, r25	; 0x01
    3ad8:	a2 83       	std	Z+2, r26	; 0x02
    3ada:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3adc:	8e 01       	movw	r16, r28
    3ade:	0b 5b       	subi	r16, 0xBB	; 187
    3ae0:	1f 4f       	sbci	r17, 0xFF	; 255
    3ae2:	fe 01       	movw	r30, r28
    3ae4:	e7 5b       	subi	r30, 0xB7	; 183
    3ae6:	ff 4f       	sbci	r31, 0xFF	; 255
    3ae8:	60 81       	ld	r22, Z
    3aea:	71 81       	ldd	r23, Z+1	; 0x01
    3aec:	82 81       	ldd	r24, Z+2	; 0x02
    3aee:	93 81       	ldd	r25, Z+3	; 0x03
    3af0:	20 e0       	ldi	r18, 0x00	; 0
    3af2:	30 e0       	ldi	r19, 0x00	; 0
    3af4:	4a ef       	ldi	r20, 0xFA	; 250
    3af6:	54 e4       	ldi	r21, 0x44	; 68
    3af8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3afc:	dc 01       	movw	r26, r24
    3afe:	cb 01       	movw	r24, r22
    3b00:	f8 01       	movw	r30, r16
    3b02:	80 83       	st	Z, r24
    3b04:	91 83       	std	Z+1, r25	; 0x01
    3b06:	a2 83       	std	Z+2, r26	; 0x02
    3b08:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    3b0a:	fe 01       	movw	r30, r28
    3b0c:	eb 5b       	subi	r30, 0xBB	; 187
    3b0e:	ff 4f       	sbci	r31, 0xFF	; 255
    3b10:	60 81       	ld	r22, Z
    3b12:	71 81       	ldd	r23, Z+1	; 0x01
    3b14:	82 81       	ldd	r24, Z+2	; 0x02
    3b16:	93 81       	ldd	r25, Z+3	; 0x03
    3b18:	20 e0       	ldi	r18, 0x00	; 0
    3b1a:	30 e0       	ldi	r19, 0x00	; 0
    3b1c:	40 e8       	ldi	r20, 0x80	; 128
    3b1e:	5f e3       	ldi	r21, 0x3F	; 63
    3b20:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3b24:	88 23       	and	r24, r24
    3b26:	44 f4       	brge	.+16     	; 0x3b38 <LCD_init+0xd2>
		__ticks = 1;
    3b28:	fe 01       	movw	r30, r28
    3b2a:	ed 5b       	subi	r30, 0xBD	; 189
    3b2c:	ff 4f       	sbci	r31, 0xFF	; 255
    3b2e:	81 e0       	ldi	r24, 0x01	; 1
    3b30:	90 e0       	ldi	r25, 0x00	; 0
    3b32:	91 83       	std	Z+1, r25	; 0x01
    3b34:	80 83       	st	Z, r24
    3b36:	64 c0       	rjmp	.+200    	; 0x3c00 <LCD_init+0x19a>
	else if (__tmp > 65535)
    3b38:	fe 01       	movw	r30, r28
    3b3a:	eb 5b       	subi	r30, 0xBB	; 187
    3b3c:	ff 4f       	sbci	r31, 0xFF	; 255
    3b3e:	60 81       	ld	r22, Z
    3b40:	71 81       	ldd	r23, Z+1	; 0x01
    3b42:	82 81       	ldd	r24, Z+2	; 0x02
    3b44:	93 81       	ldd	r25, Z+3	; 0x03
    3b46:	20 e0       	ldi	r18, 0x00	; 0
    3b48:	3f ef       	ldi	r19, 0xFF	; 255
    3b4a:	4f e7       	ldi	r20, 0x7F	; 127
    3b4c:	57 e4       	ldi	r21, 0x47	; 71
    3b4e:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3b52:	18 16       	cp	r1, r24
    3b54:	0c f0       	brlt	.+2      	; 0x3b58 <LCD_init+0xf2>
    3b56:	43 c0       	rjmp	.+134    	; 0x3bde <LCD_init+0x178>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3b58:	fe 01       	movw	r30, r28
    3b5a:	e7 5b       	subi	r30, 0xB7	; 183
    3b5c:	ff 4f       	sbci	r31, 0xFF	; 255
    3b5e:	60 81       	ld	r22, Z
    3b60:	71 81       	ldd	r23, Z+1	; 0x01
    3b62:	82 81       	ldd	r24, Z+2	; 0x02
    3b64:	93 81       	ldd	r25, Z+3	; 0x03
    3b66:	20 e0       	ldi	r18, 0x00	; 0
    3b68:	30 e0       	ldi	r19, 0x00	; 0
    3b6a:	40 e2       	ldi	r20, 0x20	; 32
    3b6c:	51 e4       	ldi	r21, 0x41	; 65
    3b6e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3b72:	dc 01       	movw	r26, r24
    3b74:	cb 01       	movw	r24, r22
    3b76:	8e 01       	movw	r16, r28
    3b78:	0d 5b       	subi	r16, 0xBD	; 189
    3b7a:	1f 4f       	sbci	r17, 0xFF	; 255
    3b7c:	bc 01       	movw	r22, r24
    3b7e:	cd 01       	movw	r24, r26
    3b80:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3b84:	dc 01       	movw	r26, r24
    3b86:	cb 01       	movw	r24, r22
    3b88:	f8 01       	movw	r30, r16
    3b8a:	91 83       	std	Z+1, r25	; 0x01
    3b8c:	80 83       	st	Z, r24
    3b8e:	1f c0       	rjmp	.+62     	; 0x3bce <LCD_init+0x168>
    3b90:	fe 01       	movw	r30, r28
    3b92:	ef 5b       	subi	r30, 0xBF	; 191
    3b94:	ff 4f       	sbci	r31, 0xFF	; 255
    3b96:	88 ec       	ldi	r24, 0xC8	; 200
    3b98:	90 e0       	ldi	r25, 0x00	; 0
    3b9a:	91 83       	std	Z+1, r25	; 0x01
    3b9c:	80 83       	st	Z, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3b9e:	fe 01       	movw	r30, r28
    3ba0:	ef 5b       	subi	r30, 0xBF	; 191
    3ba2:	ff 4f       	sbci	r31, 0xFF	; 255
    3ba4:	80 81       	ld	r24, Z
    3ba6:	91 81       	ldd	r25, Z+1	; 0x01
    3ba8:	01 97       	sbiw	r24, 0x01	; 1
    3baa:	f1 f7       	brne	.-4      	; 0x3ba8 <LCD_init+0x142>
    3bac:	fe 01       	movw	r30, r28
    3bae:	ef 5b       	subi	r30, 0xBF	; 191
    3bb0:	ff 4f       	sbci	r31, 0xFF	; 255
    3bb2:	91 83       	std	Z+1, r25	; 0x01
    3bb4:	80 83       	st	Z, r24
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3bb6:	de 01       	movw	r26, r28
    3bb8:	ad 5b       	subi	r26, 0xBD	; 189
    3bba:	bf 4f       	sbci	r27, 0xFF	; 255
    3bbc:	fe 01       	movw	r30, r28
    3bbe:	ed 5b       	subi	r30, 0xBD	; 189
    3bc0:	ff 4f       	sbci	r31, 0xFF	; 255
    3bc2:	80 81       	ld	r24, Z
    3bc4:	91 81       	ldd	r25, Z+1	; 0x01
    3bc6:	01 97       	sbiw	r24, 0x01	; 1
    3bc8:	11 96       	adiw	r26, 0x01	; 1
    3bca:	9c 93       	st	X, r25
    3bcc:	8e 93       	st	-X, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3bce:	fe 01       	movw	r30, r28
    3bd0:	ed 5b       	subi	r30, 0xBD	; 189
    3bd2:	ff 4f       	sbci	r31, 0xFF	; 255
    3bd4:	80 81       	ld	r24, Z
    3bd6:	91 81       	ldd	r25, Z+1	; 0x01
    3bd8:	00 97       	sbiw	r24, 0x00	; 0
    3bda:	d1 f6       	brne	.-76     	; 0x3b90 <LCD_init+0x12a>
    3bdc:	24 c0       	rjmp	.+72     	; 0x3c26 <LCD_init+0x1c0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3bde:	8e 01       	movw	r16, r28
    3be0:	0d 5b       	subi	r16, 0xBD	; 189
    3be2:	1f 4f       	sbci	r17, 0xFF	; 255
    3be4:	fe 01       	movw	r30, r28
    3be6:	eb 5b       	subi	r30, 0xBB	; 187
    3be8:	ff 4f       	sbci	r31, 0xFF	; 255
    3bea:	60 81       	ld	r22, Z
    3bec:	71 81       	ldd	r23, Z+1	; 0x01
    3bee:	82 81       	ldd	r24, Z+2	; 0x02
    3bf0:	93 81       	ldd	r25, Z+3	; 0x03
    3bf2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3bf6:	dc 01       	movw	r26, r24
    3bf8:	cb 01       	movw	r24, r22
    3bfa:	f8 01       	movw	r30, r16
    3bfc:	91 83       	std	Z+1, r25	; 0x01
    3bfe:	80 83       	st	Z, r24
    3c00:	fe 01       	movw	r30, r28
    3c02:	ed 5b       	subi	r30, 0xBD	; 189
    3c04:	ff 4f       	sbci	r31, 0xFF	; 255
    3c06:	80 81       	ld	r24, Z
    3c08:	91 81       	ldd	r25, Z+1	; 0x01
    3c0a:	fe 01       	movw	r30, r28
    3c0c:	ff 96       	adiw	r30, 0x3f	; 63
    3c0e:	91 83       	std	Z+1, r25	; 0x01
    3c10:	80 83       	st	Z, r24
    3c12:	fe 01       	movw	r30, r28
    3c14:	ff 96       	adiw	r30, 0x3f	; 63
    3c16:	80 81       	ld	r24, Z
    3c18:	91 81       	ldd	r25, Z+1	; 0x01
    3c1a:	01 97       	sbiw	r24, 0x01	; 1
    3c1c:	f1 f7       	brne	.-4      	; 0x3c1a <LCD_init+0x1b4>
    3c1e:	fe 01       	movw	r30, r28
    3c20:	ff 96       	adiw	r30, 0x3f	; 63
    3c22:	91 83       	std	Z+1, r25	; 0x01
    3c24:	80 83       	st	Z, r24
	//wait for
	_delay_ms(50);
	// init 4bit
	LCD_function_Set_4bit();
    3c26:	0e 94 73 15 	call	0x2ae6	; 0x2ae6 <LCD_function_Set_4bit>
    3c2a:	80 e0       	ldi	r24, 0x00	; 0
    3c2c:	90 e0       	ldi	r25, 0x00	; 0
    3c2e:	a8 e4       	ldi	r26, 0x48	; 72
    3c30:	b2 e4       	ldi	r27, 0x42	; 66
    3c32:	8b af       	std	Y+59, r24	; 0x3b
    3c34:	9c af       	std	Y+60, r25	; 0x3c
    3c36:	ad af       	std	Y+61, r26	; 0x3d
    3c38:	be af       	std	Y+62, r27	; 0x3e
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3c3a:	6b ad       	ldd	r22, Y+59	; 0x3b
    3c3c:	7c ad       	ldd	r23, Y+60	; 0x3c
    3c3e:	8d ad       	ldd	r24, Y+61	; 0x3d
    3c40:	9e ad       	ldd	r25, Y+62	; 0x3e
    3c42:	2b ea       	ldi	r18, 0xAB	; 171
    3c44:	3a ea       	ldi	r19, 0xAA	; 170
    3c46:	4a e2       	ldi	r20, 0x2A	; 42
    3c48:	50 e4       	ldi	r21, 0x40	; 64
    3c4a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3c4e:	dc 01       	movw	r26, r24
    3c50:	cb 01       	movw	r24, r22
    3c52:	8f ab       	std	Y+55, r24	; 0x37
    3c54:	98 af       	std	Y+56, r25	; 0x38
    3c56:	a9 af       	std	Y+57, r26	; 0x39
    3c58:	ba af       	std	Y+58, r27	; 0x3a
	if (__tmp < 1.0)
    3c5a:	6f a9       	ldd	r22, Y+55	; 0x37
    3c5c:	78 ad       	ldd	r23, Y+56	; 0x38
    3c5e:	89 ad       	ldd	r24, Y+57	; 0x39
    3c60:	9a ad       	ldd	r25, Y+58	; 0x3a
    3c62:	20 e0       	ldi	r18, 0x00	; 0
    3c64:	30 e0       	ldi	r19, 0x00	; 0
    3c66:	40 e8       	ldi	r20, 0x80	; 128
    3c68:	5f e3       	ldi	r21, 0x3F	; 63
    3c6a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3c6e:	88 23       	and	r24, r24
    3c70:	1c f4       	brge	.+6      	; 0x3c78 <LCD_init+0x212>
		__ticks = 1;
    3c72:	81 e0       	ldi	r24, 0x01	; 1
    3c74:	8e ab       	std	Y+54, r24	; 0x36
    3c76:	91 c0       	rjmp	.+290    	; 0x3d9a <LCD_init+0x334>
	else if (__tmp > 255)
    3c78:	6f a9       	ldd	r22, Y+55	; 0x37
    3c7a:	78 ad       	ldd	r23, Y+56	; 0x38
    3c7c:	89 ad       	ldd	r24, Y+57	; 0x39
    3c7e:	9a ad       	ldd	r25, Y+58	; 0x3a
    3c80:	20 e0       	ldi	r18, 0x00	; 0
    3c82:	30 e0       	ldi	r19, 0x00	; 0
    3c84:	4f e7       	ldi	r20, 0x7F	; 127
    3c86:	53 e4       	ldi	r21, 0x43	; 67
    3c88:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3c8c:	18 16       	cp	r1, r24
    3c8e:	0c f0       	brlt	.+2      	; 0x3c92 <LCD_init+0x22c>
    3c90:	7b c0       	rjmp	.+246    	; 0x3d88 <LCD_init+0x322>
	{
		_delay_ms(__us / 1000.0);
    3c92:	6b ad       	ldd	r22, Y+59	; 0x3b
    3c94:	7c ad       	ldd	r23, Y+60	; 0x3c
    3c96:	8d ad       	ldd	r24, Y+61	; 0x3d
    3c98:	9e ad       	ldd	r25, Y+62	; 0x3e
    3c9a:	20 e0       	ldi	r18, 0x00	; 0
    3c9c:	30 e0       	ldi	r19, 0x00	; 0
    3c9e:	4a e7       	ldi	r20, 0x7A	; 122
    3ca0:	54 e4       	ldi	r21, 0x44	; 68
    3ca2:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3ca6:	dc 01       	movw	r26, r24
    3ca8:	cb 01       	movw	r24, r22
    3caa:	8a ab       	std	Y+50, r24	; 0x32
    3cac:	9b ab       	std	Y+51, r25	; 0x33
    3cae:	ac ab       	std	Y+52, r26	; 0x34
    3cb0:	bd ab       	std	Y+53, r27	; 0x35
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3cb2:	6a a9       	ldd	r22, Y+50	; 0x32
    3cb4:	7b a9       	ldd	r23, Y+51	; 0x33
    3cb6:	8c a9       	ldd	r24, Y+52	; 0x34
    3cb8:	9d a9       	ldd	r25, Y+53	; 0x35
    3cba:	20 e0       	ldi	r18, 0x00	; 0
    3cbc:	30 e0       	ldi	r19, 0x00	; 0
    3cbe:	4a ef       	ldi	r20, 0xFA	; 250
    3cc0:	54 e4       	ldi	r21, 0x44	; 68
    3cc2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3cc6:	dc 01       	movw	r26, r24
    3cc8:	cb 01       	movw	r24, r22
    3cca:	8e a7       	std	Y+46, r24	; 0x2e
    3ccc:	9f a7       	std	Y+47, r25	; 0x2f
    3cce:	a8 ab       	std	Y+48, r26	; 0x30
    3cd0:	b9 ab       	std	Y+49, r27	; 0x31
	if (__tmp < 1.0)
    3cd2:	6e a5       	ldd	r22, Y+46	; 0x2e
    3cd4:	7f a5       	ldd	r23, Y+47	; 0x2f
    3cd6:	88 a9       	ldd	r24, Y+48	; 0x30
    3cd8:	99 a9       	ldd	r25, Y+49	; 0x31
    3cda:	20 e0       	ldi	r18, 0x00	; 0
    3cdc:	30 e0       	ldi	r19, 0x00	; 0
    3cde:	40 e8       	ldi	r20, 0x80	; 128
    3ce0:	5f e3       	ldi	r21, 0x3F	; 63
    3ce2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3ce6:	88 23       	and	r24, r24
    3ce8:	2c f4       	brge	.+10     	; 0x3cf4 <LCD_init+0x28e>
		__ticks = 1;
    3cea:	81 e0       	ldi	r24, 0x01	; 1
    3cec:	90 e0       	ldi	r25, 0x00	; 0
    3cee:	9d a7       	std	Y+45, r25	; 0x2d
    3cf0:	8c a7       	std	Y+44, r24	; 0x2c
    3cf2:	3f c0       	rjmp	.+126    	; 0x3d72 <LCD_init+0x30c>
	else if (__tmp > 65535)
    3cf4:	6e a5       	ldd	r22, Y+46	; 0x2e
    3cf6:	7f a5       	ldd	r23, Y+47	; 0x2f
    3cf8:	88 a9       	ldd	r24, Y+48	; 0x30
    3cfa:	99 a9       	ldd	r25, Y+49	; 0x31
    3cfc:	20 e0       	ldi	r18, 0x00	; 0
    3cfe:	3f ef       	ldi	r19, 0xFF	; 255
    3d00:	4f e7       	ldi	r20, 0x7F	; 127
    3d02:	57 e4       	ldi	r21, 0x47	; 71
    3d04:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3d08:	18 16       	cp	r1, r24
    3d0a:	4c f5       	brge	.+82     	; 0x3d5e <LCD_init+0x2f8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3d0c:	6a a9       	ldd	r22, Y+50	; 0x32
    3d0e:	7b a9       	ldd	r23, Y+51	; 0x33
    3d10:	8c a9       	ldd	r24, Y+52	; 0x34
    3d12:	9d a9       	ldd	r25, Y+53	; 0x35
    3d14:	20 e0       	ldi	r18, 0x00	; 0
    3d16:	30 e0       	ldi	r19, 0x00	; 0
    3d18:	40 e2       	ldi	r20, 0x20	; 32
    3d1a:	51 e4       	ldi	r21, 0x41	; 65
    3d1c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3d20:	dc 01       	movw	r26, r24
    3d22:	cb 01       	movw	r24, r22
    3d24:	bc 01       	movw	r22, r24
    3d26:	cd 01       	movw	r24, r26
    3d28:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3d2c:	dc 01       	movw	r26, r24
    3d2e:	cb 01       	movw	r24, r22
    3d30:	9d a7       	std	Y+45, r25	; 0x2d
    3d32:	8c a7       	std	Y+44, r24	; 0x2c
    3d34:	0f c0       	rjmp	.+30     	; 0x3d54 <LCD_init+0x2ee>
    3d36:	88 ec       	ldi	r24, 0xC8	; 200
    3d38:	90 e0       	ldi	r25, 0x00	; 0
    3d3a:	9b a7       	std	Y+43, r25	; 0x2b
    3d3c:	8a a7       	std	Y+42, r24	; 0x2a
    3d3e:	8a a5       	ldd	r24, Y+42	; 0x2a
    3d40:	9b a5       	ldd	r25, Y+43	; 0x2b
    3d42:	01 97       	sbiw	r24, 0x01	; 1
    3d44:	f1 f7       	brne	.-4      	; 0x3d42 <LCD_init+0x2dc>
    3d46:	9b a7       	std	Y+43, r25	; 0x2b
    3d48:	8a a7       	std	Y+42, r24	; 0x2a
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3d4a:	8c a5       	ldd	r24, Y+44	; 0x2c
    3d4c:	9d a5       	ldd	r25, Y+45	; 0x2d
    3d4e:	01 97       	sbiw	r24, 0x01	; 1
    3d50:	9d a7       	std	Y+45, r25	; 0x2d
    3d52:	8c a7       	std	Y+44, r24	; 0x2c
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3d54:	8c a5       	ldd	r24, Y+44	; 0x2c
    3d56:	9d a5       	ldd	r25, Y+45	; 0x2d
    3d58:	00 97       	sbiw	r24, 0x00	; 0
    3d5a:	69 f7       	brne	.-38     	; 0x3d36 <LCD_init+0x2d0>
    3d5c:	24 c0       	rjmp	.+72     	; 0x3da6 <LCD_init+0x340>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3d5e:	6e a5       	ldd	r22, Y+46	; 0x2e
    3d60:	7f a5       	ldd	r23, Y+47	; 0x2f
    3d62:	88 a9       	ldd	r24, Y+48	; 0x30
    3d64:	99 a9       	ldd	r25, Y+49	; 0x31
    3d66:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3d6a:	dc 01       	movw	r26, r24
    3d6c:	cb 01       	movw	r24, r22
    3d6e:	9d a7       	std	Y+45, r25	; 0x2d
    3d70:	8c a7       	std	Y+44, r24	; 0x2c
    3d72:	8c a5       	ldd	r24, Y+44	; 0x2c
    3d74:	9d a5       	ldd	r25, Y+45	; 0x2d
    3d76:	99 a7       	std	Y+41, r25	; 0x29
    3d78:	88 a7       	std	Y+40, r24	; 0x28
    3d7a:	88 a5       	ldd	r24, Y+40	; 0x28
    3d7c:	99 a5       	ldd	r25, Y+41	; 0x29
    3d7e:	01 97       	sbiw	r24, 0x01	; 1
    3d80:	f1 f7       	brne	.-4      	; 0x3d7e <LCD_init+0x318>
    3d82:	99 a7       	std	Y+41, r25	; 0x29
    3d84:	88 a7       	std	Y+40, r24	; 0x28
    3d86:	0f c0       	rjmp	.+30     	; 0x3da6 <LCD_init+0x340>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3d88:	6f a9       	ldd	r22, Y+55	; 0x37
    3d8a:	78 ad       	ldd	r23, Y+56	; 0x38
    3d8c:	89 ad       	ldd	r24, Y+57	; 0x39
    3d8e:	9a ad       	ldd	r25, Y+58	; 0x3a
    3d90:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3d94:	dc 01       	movw	r26, r24
    3d96:	cb 01       	movw	r24, r22
    3d98:	8e ab       	std	Y+54, r24	; 0x36
    3d9a:	8e a9       	ldd	r24, Y+54	; 0x36
    3d9c:	8f a3       	std	Y+39, r24	; 0x27
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3d9e:	8f a1       	ldd	r24, Y+39	; 0x27
    3da0:	8a 95       	dec	r24
    3da2:	f1 f7       	brne	.-4      	; 0x3da0 <LCD_init+0x33a>
    3da4:	8f a3       	std	Y+39, r24	; 0x27
	// wait > 30 us
	_delay_us(50);
	LCD_write_command_4bit(display_On);
    3da6:	8c e0       	ldi	r24, 0x0C	; 12
    3da8:	0e 94 57 11 	call	0x22ae	; 0x22ae <LCD_write_command_4bit>
    3dac:	80 e0       	ldi	r24, 0x00	; 0
    3dae:	90 e0       	ldi	r25, 0x00	; 0
    3db0:	a8 e4       	ldi	r26, 0x48	; 72
    3db2:	b2 e4       	ldi	r27, 0x42	; 66
    3db4:	8b a3       	std	Y+35, r24	; 0x23
    3db6:	9c a3       	std	Y+36, r25	; 0x24
    3db8:	ad a3       	std	Y+37, r26	; 0x25
    3dba:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    3dbc:	6b a1       	ldd	r22, Y+35	; 0x23
    3dbe:	7c a1       	ldd	r23, Y+36	; 0x24
    3dc0:	8d a1       	ldd	r24, Y+37	; 0x25
    3dc2:	9e a1       	ldd	r25, Y+38	; 0x26
    3dc4:	2b ea       	ldi	r18, 0xAB	; 171
    3dc6:	3a ea       	ldi	r19, 0xAA	; 170
    3dc8:	4a e2       	ldi	r20, 0x2A	; 42
    3dca:	50 e4       	ldi	r21, 0x40	; 64
    3dcc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3dd0:	dc 01       	movw	r26, r24
    3dd2:	cb 01       	movw	r24, r22
    3dd4:	8f 8f       	std	Y+31, r24	; 0x1f
    3dd6:	98 a3       	std	Y+32, r25	; 0x20
    3dd8:	a9 a3       	std	Y+33, r26	; 0x21
    3dda:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    3ddc:	6f 8d       	ldd	r22, Y+31	; 0x1f
    3dde:	78 a1       	ldd	r23, Y+32	; 0x20
    3de0:	89 a1       	ldd	r24, Y+33	; 0x21
    3de2:	9a a1       	ldd	r25, Y+34	; 0x22
    3de4:	20 e0       	ldi	r18, 0x00	; 0
    3de6:	30 e0       	ldi	r19, 0x00	; 0
    3de8:	40 e8       	ldi	r20, 0x80	; 128
    3dea:	5f e3       	ldi	r21, 0x3F	; 63
    3dec:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3df0:	88 23       	and	r24, r24
    3df2:	1c f4       	brge	.+6      	; 0x3dfa <LCD_init+0x394>
		__ticks = 1;
    3df4:	81 e0       	ldi	r24, 0x01	; 1
    3df6:	8e 8f       	std	Y+30, r24	; 0x1e
    3df8:	91 c0       	rjmp	.+290    	; 0x3f1c <LCD_init+0x4b6>
	else if (__tmp > 255)
    3dfa:	6f 8d       	ldd	r22, Y+31	; 0x1f
    3dfc:	78 a1       	ldd	r23, Y+32	; 0x20
    3dfe:	89 a1       	ldd	r24, Y+33	; 0x21
    3e00:	9a a1       	ldd	r25, Y+34	; 0x22
    3e02:	20 e0       	ldi	r18, 0x00	; 0
    3e04:	30 e0       	ldi	r19, 0x00	; 0
    3e06:	4f e7       	ldi	r20, 0x7F	; 127
    3e08:	53 e4       	ldi	r21, 0x43	; 67
    3e0a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3e0e:	18 16       	cp	r1, r24
    3e10:	0c f0       	brlt	.+2      	; 0x3e14 <LCD_init+0x3ae>
    3e12:	7b c0       	rjmp	.+246    	; 0x3f0a <LCD_init+0x4a4>
	{
		_delay_ms(__us / 1000.0);
    3e14:	6b a1       	ldd	r22, Y+35	; 0x23
    3e16:	7c a1       	ldd	r23, Y+36	; 0x24
    3e18:	8d a1       	ldd	r24, Y+37	; 0x25
    3e1a:	9e a1       	ldd	r25, Y+38	; 0x26
    3e1c:	20 e0       	ldi	r18, 0x00	; 0
    3e1e:	30 e0       	ldi	r19, 0x00	; 0
    3e20:	4a e7       	ldi	r20, 0x7A	; 122
    3e22:	54 e4       	ldi	r21, 0x44	; 68
    3e24:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    3e28:	dc 01       	movw	r26, r24
    3e2a:	cb 01       	movw	r24, r22
    3e2c:	8a 8f       	std	Y+26, r24	; 0x1a
    3e2e:	9b 8f       	std	Y+27, r25	; 0x1b
    3e30:	ac 8f       	std	Y+28, r26	; 0x1c
    3e32:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3e34:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3e36:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3e38:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3e3a:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3e3c:	20 e0       	ldi	r18, 0x00	; 0
    3e3e:	30 e0       	ldi	r19, 0x00	; 0
    3e40:	4a ef       	ldi	r20, 0xFA	; 250
    3e42:	54 e4       	ldi	r21, 0x44	; 68
    3e44:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3e48:	dc 01       	movw	r26, r24
    3e4a:	cb 01       	movw	r24, r22
    3e4c:	8e 8b       	std	Y+22, r24	; 0x16
    3e4e:	9f 8b       	std	Y+23, r25	; 0x17
    3e50:	a8 8f       	std	Y+24, r26	; 0x18
    3e52:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    3e54:	6e 89       	ldd	r22, Y+22	; 0x16
    3e56:	7f 89       	ldd	r23, Y+23	; 0x17
    3e58:	88 8d       	ldd	r24, Y+24	; 0x18
    3e5a:	99 8d       	ldd	r25, Y+25	; 0x19
    3e5c:	20 e0       	ldi	r18, 0x00	; 0
    3e5e:	30 e0       	ldi	r19, 0x00	; 0
    3e60:	40 e8       	ldi	r20, 0x80	; 128
    3e62:	5f e3       	ldi	r21, 0x3F	; 63
    3e64:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3e68:	88 23       	and	r24, r24
    3e6a:	2c f4       	brge	.+10     	; 0x3e76 <LCD_init+0x410>
		__ticks = 1;
    3e6c:	81 e0       	ldi	r24, 0x01	; 1
    3e6e:	90 e0       	ldi	r25, 0x00	; 0
    3e70:	9d 8b       	std	Y+21, r25	; 0x15
    3e72:	8c 8b       	std	Y+20, r24	; 0x14
    3e74:	3f c0       	rjmp	.+126    	; 0x3ef4 <LCD_init+0x48e>
	else if (__tmp > 65535)
    3e76:	6e 89       	ldd	r22, Y+22	; 0x16
    3e78:	7f 89       	ldd	r23, Y+23	; 0x17
    3e7a:	88 8d       	ldd	r24, Y+24	; 0x18
    3e7c:	99 8d       	ldd	r25, Y+25	; 0x19
    3e7e:	20 e0       	ldi	r18, 0x00	; 0
    3e80:	3f ef       	ldi	r19, 0xFF	; 255
    3e82:	4f e7       	ldi	r20, 0x7F	; 127
    3e84:	57 e4       	ldi	r21, 0x47	; 71
    3e86:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3e8a:	18 16       	cp	r1, r24
    3e8c:	4c f5       	brge	.+82     	; 0x3ee0 <LCD_init+0x47a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3e8e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3e90:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3e92:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3e94:	9d 8d       	ldd	r25, Y+29	; 0x1d
    3e96:	20 e0       	ldi	r18, 0x00	; 0
    3e98:	30 e0       	ldi	r19, 0x00	; 0
    3e9a:	40 e2       	ldi	r20, 0x20	; 32
    3e9c:	51 e4       	ldi	r21, 0x41	; 65
    3e9e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3ea2:	dc 01       	movw	r26, r24
    3ea4:	cb 01       	movw	r24, r22
    3ea6:	bc 01       	movw	r22, r24
    3ea8:	cd 01       	movw	r24, r26
    3eaa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3eae:	dc 01       	movw	r26, r24
    3eb0:	cb 01       	movw	r24, r22
    3eb2:	9d 8b       	std	Y+21, r25	; 0x15
    3eb4:	8c 8b       	std	Y+20, r24	; 0x14
    3eb6:	0f c0       	rjmp	.+30     	; 0x3ed6 <LCD_init+0x470>
    3eb8:	88 ec       	ldi	r24, 0xC8	; 200
    3eba:	90 e0       	ldi	r25, 0x00	; 0
    3ebc:	9b 8b       	std	Y+19, r25	; 0x13
    3ebe:	8a 8b       	std	Y+18, r24	; 0x12
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3ec0:	8a 89       	ldd	r24, Y+18	; 0x12
    3ec2:	9b 89       	ldd	r25, Y+19	; 0x13
    3ec4:	01 97       	sbiw	r24, 0x01	; 1
    3ec6:	f1 f7       	brne	.-4      	; 0x3ec4 <LCD_init+0x45e>
    3ec8:	9b 8b       	std	Y+19, r25	; 0x13
    3eca:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3ecc:	8c 89       	ldd	r24, Y+20	; 0x14
    3ece:	9d 89       	ldd	r25, Y+21	; 0x15
    3ed0:	01 97       	sbiw	r24, 0x01	; 1
    3ed2:	9d 8b       	std	Y+21, r25	; 0x15
    3ed4:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3ed6:	8c 89       	ldd	r24, Y+20	; 0x14
    3ed8:	9d 89       	ldd	r25, Y+21	; 0x15
    3eda:	00 97       	sbiw	r24, 0x00	; 0
    3edc:	69 f7       	brne	.-38     	; 0x3eb8 <LCD_init+0x452>
    3ede:	24 c0       	rjmp	.+72     	; 0x3f28 <LCD_init+0x4c2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3ee0:	6e 89       	ldd	r22, Y+22	; 0x16
    3ee2:	7f 89       	ldd	r23, Y+23	; 0x17
    3ee4:	88 8d       	ldd	r24, Y+24	; 0x18
    3ee6:	99 8d       	ldd	r25, Y+25	; 0x19
    3ee8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3eec:	dc 01       	movw	r26, r24
    3eee:	cb 01       	movw	r24, r22
    3ef0:	9d 8b       	std	Y+21, r25	; 0x15
    3ef2:	8c 8b       	std	Y+20, r24	; 0x14
    3ef4:	8c 89       	ldd	r24, Y+20	; 0x14
    3ef6:	9d 89       	ldd	r25, Y+21	; 0x15
    3ef8:	99 8b       	std	Y+17, r25	; 0x11
    3efa:	88 8b       	std	Y+16, r24	; 0x10
    3efc:	88 89       	ldd	r24, Y+16	; 0x10
    3efe:	99 89       	ldd	r25, Y+17	; 0x11
    3f00:	01 97       	sbiw	r24, 0x01	; 1
    3f02:	f1 f7       	brne	.-4      	; 0x3f00 <LCD_init+0x49a>
    3f04:	99 8b       	std	Y+17, r25	; 0x11
    3f06:	88 8b       	std	Y+16, r24	; 0x10
    3f08:	0f c0       	rjmp	.+30     	; 0x3f28 <LCD_init+0x4c2>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    3f0a:	6f 8d       	ldd	r22, Y+31	; 0x1f
    3f0c:	78 a1       	ldd	r23, Y+32	; 0x20
    3f0e:	89 a1       	ldd	r24, Y+33	; 0x21
    3f10:	9a a1       	ldd	r25, Y+34	; 0x22
    3f12:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3f16:	dc 01       	movw	r26, r24
    3f18:	cb 01       	movw	r24, r22
    3f1a:	8e 8f       	std	Y+30, r24	; 0x1e
    3f1c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3f1e:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    3f20:	8f 85       	ldd	r24, Y+15	; 0x0f
    3f22:	8a 95       	dec	r24
    3f24:	f1 f7       	brne	.-4      	; 0x3f22 <LCD_init+0x4bc>
    3f26:	8f 87       	std	Y+15, r24	; 0x0f
	// wait > 30 us
	_delay_us(50);
	LCD_write_command_4bit(clear_Display);
    3f28:	81 e0       	ldi	r24, 0x01	; 1
    3f2a:	0e 94 57 11 	call	0x22ae	; 0x22ae <LCD_write_command_4bit>
    3f2e:	80 e0       	ldi	r24, 0x00	; 0
    3f30:	90 e0       	ldi	r25, 0x00	; 0
    3f32:	a0 e0       	ldi	r26, 0x00	; 0
    3f34:	b0 e4       	ldi	r27, 0x40	; 64
    3f36:	8b 87       	std	Y+11, r24	; 0x0b
    3f38:	9c 87       	std	Y+12, r25	; 0x0c
    3f3a:	ad 87       	std	Y+13, r26	; 0x0d
    3f3c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    3f3e:	6b 85       	ldd	r22, Y+11	; 0x0b
    3f40:	7c 85       	ldd	r23, Y+12	; 0x0c
    3f42:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f44:	9e 85       	ldd	r25, Y+14	; 0x0e
    3f46:	20 e0       	ldi	r18, 0x00	; 0
    3f48:	30 e0       	ldi	r19, 0x00	; 0
    3f4a:	4a ef       	ldi	r20, 0xFA	; 250
    3f4c:	54 e4       	ldi	r21, 0x44	; 68
    3f4e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3f52:	dc 01       	movw	r26, r24
    3f54:	cb 01       	movw	r24, r22
    3f56:	8f 83       	std	Y+7, r24	; 0x07
    3f58:	98 87       	std	Y+8, r25	; 0x08
    3f5a:	a9 87       	std	Y+9, r26	; 0x09
    3f5c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    3f5e:	6f 81       	ldd	r22, Y+7	; 0x07
    3f60:	78 85       	ldd	r23, Y+8	; 0x08
    3f62:	89 85       	ldd	r24, Y+9	; 0x09
    3f64:	9a 85       	ldd	r25, Y+10	; 0x0a
    3f66:	20 e0       	ldi	r18, 0x00	; 0
    3f68:	30 e0       	ldi	r19, 0x00	; 0
    3f6a:	40 e8       	ldi	r20, 0x80	; 128
    3f6c:	5f e3       	ldi	r21, 0x3F	; 63
    3f6e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    3f72:	88 23       	and	r24, r24
    3f74:	2c f4       	brge	.+10     	; 0x3f80 <LCD_init+0x51a>
		__ticks = 1;
    3f76:	81 e0       	ldi	r24, 0x01	; 1
    3f78:	90 e0       	ldi	r25, 0x00	; 0
    3f7a:	9e 83       	std	Y+6, r25	; 0x06
    3f7c:	8d 83       	std	Y+5, r24	; 0x05
    3f7e:	3f c0       	rjmp	.+126    	; 0x3ffe <LCD_init+0x598>
	else if (__tmp > 65535)
    3f80:	6f 81       	ldd	r22, Y+7	; 0x07
    3f82:	78 85       	ldd	r23, Y+8	; 0x08
    3f84:	89 85       	ldd	r24, Y+9	; 0x09
    3f86:	9a 85       	ldd	r25, Y+10	; 0x0a
    3f88:	20 e0       	ldi	r18, 0x00	; 0
    3f8a:	3f ef       	ldi	r19, 0xFF	; 255
    3f8c:	4f e7       	ldi	r20, 0x7F	; 127
    3f8e:	57 e4       	ldi	r21, 0x47	; 71
    3f90:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    3f94:	18 16       	cp	r1, r24
    3f96:	4c f5       	brge	.+82     	; 0x3fea <LCD_init+0x584>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3f98:	6b 85       	ldd	r22, Y+11	; 0x0b
    3f9a:	7c 85       	ldd	r23, Y+12	; 0x0c
    3f9c:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f9e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3fa0:	20 e0       	ldi	r18, 0x00	; 0
    3fa2:	30 e0       	ldi	r19, 0x00	; 0
    3fa4:	40 e2       	ldi	r20, 0x20	; 32
    3fa6:	51 e4       	ldi	r21, 0x41	; 65
    3fa8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3fac:	dc 01       	movw	r26, r24
    3fae:	cb 01       	movw	r24, r22
    3fb0:	bc 01       	movw	r22, r24
    3fb2:	cd 01       	movw	r24, r26
    3fb4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3fb8:	dc 01       	movw	r26, r24
    3fba:	cb 01       	movw	r24, r22
    3fbc:	9e 83       	std	Y+6, r25	; 0x06
    3fbe:	8d 83       	std	Y+5, r24	; 0x05
    3fc0:	0f c0       	rjmp	.+30     	; 0x3fe0 <LCD_init+0x57a>
    3fc2:	88 ec       	ldi	r24, 0xC8	; 200
    3fc4:	90 e0       	ldi	r25, 0x00	; 0
    3fc6:	9c 83       	std	Y+4, r25	; 0x04
    3fc8:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    3fca:	8b 81       	ldd	r24, Y+3	; 0x03
    3fcc:	9c 81       	ldd	r25, Y+4	; 0x04
    3fce:	01 97       	sbiw	r24, 0x01	; 1
    3fd0:	f1 f7       	brne	.-4      	; 0x3fce <LCD_init+0x568>
    3fd2:	9c 83       	std	Y+4, r25	; 0x04
    3fd4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    3fd6:	8d 81       	ldd	r24, Y+5	; 0x05
    3fd8:	9e 81       	ldd	r25, Y+6	; 0x06
    3fda:	01 97       	sbiw	r24, 0x01	; 1
    3fdc:	9e 83       	std	Y+6, r25	; 0x06
    3fde:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3fe0:	8d 81       	ldd	r24, Y+5	; 0x05
    3fe2:	9e 81       	ldd	r25, Y+6	; 0x06
    3fe4:	00 97       	sbiw	r24, 0x00	; 0
    3fe6:	69 f7       	brne	.-38     	; 0x3fc2 <LCD_init+0x55c>
    3fe8:	14 c0       	rjmp	.+40     	; 0x4012 <LCD_init+0x5ac>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3fea:	6f 81       	ldd	r22, Y+7	; 0x07
    3fec:	78 85       	ldd	r23, Y+8	; 0x08
    3fee:	89 85       	ldd	r24, Y+9	; 0x09
    3ff0:	9a 85       	ldd	r25, Y+10	; 0x0a
    3ff2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3ff6:	dc 01       	movw	r26, r24
    3ff8:	cb 01       	movw	r24, r22
    3ffa:	9e 83       	std	Y+6, r25	; 0x06
    3ffc:	8d 83       	std	Y+5, r24	; 0x05
    3ffe:	8d 81       	ldd	r24, Y+5	; 0x05
    4000:	9e 81       	ldd	r25, Y+6	; 0x06
    4002:	9a 83       	std	Y+2, r25	; 0x02
    4004:	89 83       	std	Y+1, r24	; 0x01
    4006:	89 81       	ldd	r24, Y+1	; 0x01
    4008:	9a 81       	ldd	r25, Y+2	; 0x02
    400a:	01 97       	sbiw	r24, 0x01	; 1
    400c:	f1 f7       	brne	.-4      	; 0x400a <LCD_init+0x5a4>
    400e:	9a 83       	std	Y+2, r25	; 0x02
    4010:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
//	LCD_write_data_4bit(entry_Mode);

#endif

}
    4012:	c4 5b       	subi	r28, 0xB4	; 180
    4014:	df 4f       	sbci	r29, 0xFF	; 255
    4016:	0f b6       	in	r0, 0x3f	; 63
    4018:	f8 94       	cli
    401a:	de bf       	out	0x3e, r29	; 62
    401c:	0f be       	out	0x3f, r0	; 63
    401e:	cd bf       	out	0x3d, r28	; 61
    4020:	cf 91       	pop	r28
    4022:	df 91       	pop	r29
    4024:	1f 91       	pop	r17
    4026:	0f 91       	pop	r16
    4028:	08 95       	ret

0000402a <LCD_set_cursor>:

void LCD_set_cursor(u8 copy_u8_row , u8 copy_u8_Column){
    402a:	df 93       	push	r29
    402c:	cf 93       	push	r28
    402e:	cd b7       	in	r28, 0x3d	; 61
    4030:	de b7       	in	r29, 0x3e	; 62
    4032:	6b 97       	sbiw	r28, 0x1b	; 27
    4034:	0f b6       	in	r0, 0x3f	; 63
    4036:	f8 94       	cli
    4038:	de bf       	out	0x3e, r29	; 62
    403a:	0f be       	out	0x3f, r0	; 63
    403c:	cd bf       	out	0x3d, r28	; 61
    403e:	8a 8f       	std	Y+26, r24	; 0x1a
    4040:	6b 8f       	std	Y+27, r22	; 0x1b
	//delay to smooth things out
	_delay_us(50);

#elif LCD_interface_mode == interface_4bit

	u8 loc_Address = 128+(copy_u8_row*line2_Start)+(copy_u8_Column);
    4042:	8a 8d       	ldd	r24, Y+26	; 0x1a
    4044:	88 2f       	mov	r24, r24
    4046:	90 e0       	ldi	r25, 0x00	; 0
    4048:	02 96       	adiw	r24, 0x02	; 2
    404a:	00 24       	eor	r0, r0
    404c:	96 95       	lsr	r25
    404e:	87 95       	ror	r24
    4050:	07 94       	ror	r0
    4052:	96 95       	lsr	r25
    4054:	87 95       	ror	r24
    4056:	07 94       	ror	r0
    4058:	98 2f       	mov	r25, r24
    405a:	80 2d       	mov	r24, r0
    405c:	98 2f       	mov	r25, r24
    405e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4060:	89 0f       	add	r24, r25
    4062:	89 8f       	std	Y+25, r24	; 0x19
		LCD_write_command_4bit(loc_Address);
    4064:	89 8d       	ldd	r24, Y+25	; 0x19
    4066:	0e 94 57 11 	call	0x22ae	; 0x22ae <LCD_write_command_4bit>
    406a:	80 e0       	ldi	r24, 0x00	; 0
    406c:	90 e0       	ldi	r25, 0x00	; 0
    406e:	a8 e4       	ldi	r26, 0x48	; 72
    4070:	b2 e4       	ldi	r27, 0x42	; 66
    4072:	8d 8b       	std	Y+21, r24	; 0x15
    4074:	9e 8b       	std	Y+22, r25	; 0x16
    4076:	af 8b       	std	Y+23, r26	; 0x17
    4078:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    407a:	6d 89       	ldd	r22, Y+21	; 0x15
    407c:	7e 89       	ldd	r23, Y+22	; 0x16
    407e:	8f 89       	ldd	r24, Y+23	; 0x17
    4080:	98 8d       	ldd	r25, Y+24	; 0x18
    4082:	2b ea       	ldi	r18, 0xAB	; 171
    4084:	3a ea       	ldi	r19, 0xAA	; 170
    4086:	4a e2       	ldi	r20, 0x2A	; 42
    4088:	50 e4       	ldi	r21, 0x40	; 64
    408a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    408e:	dc 01       	movw	r26, r24
    4090:	cb 01       	movw	r24, r22
    4092:	89 8b       	std	Y+17, r24	; 0x11
    4094:	9a 8b       	std	Y+18, r25	; 0x12
    4096:	ab 8b       	std	Y+19, r26	; 0x13
    4098:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    409a:	69 89       	ldd	r22, Y+17	; 0x11
    409c:	7a 89       	ldd	r23, Y+18	; 0x12
    409e:	8b 89       	ldd	r24, Y+19	; 0x13
    40a0:	9c 89       	ldd	r25, Y+20	; 0x14
    40a2:	20 e0       	ldi	r18, 0x00	; 0
    40a4:	30 e0       	ldi	r19, 0x00	; 0
    40a6:	40 e8       	ldi	r20, 0x80	; 128
    40a8:	5f e3       	ldi	r21, 0x3F	; 63
    40aa:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    40ae:	88 23       	and	r24, r24
    40b0:	1c f4       	brge	.+6      	; 0x40b8 <LCD_set_cursor+0x8e>
		__ticks = 1;
    40b2:	81 e0       	ldi	r24, 0x01	; 1
    40b4:	88 8b       	std	Y+16, r24	; 0x10
    40b6:	91 c0       	rjmp	.+290    	; 0x41da <LCD_set_cursor+0x1b0>
	else if (__tmp > 255)
    40b8:	69 89       	ldd	r22, Y+17	; 0x11
    40ba:	7a 89       	ldd	r23, Y+18	; 0x12
    40bc:	8b 89       	ldd	r24, Y+19	; 0x13
    40be:	9c 89       	ldd	r25, Y+20	; 0x14
    40c0:	20 e0       	ldi	r18, 0x00	; 0
    40c2:	30 e0       	ldi	r19, 0x00	; 0
    40c4:	4f e7       	ldi	r20, 0x7F	; 127
    40c6:	53 e4       	ldi	r21, 0x43	; 67
    40c8:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    40cc:	18 16       	cp	r1, r24
    40ce:	0c f0       	brlt	.+2      	; 0x40d2 <LCD_set_cursor+0xa8>
    40d0:	7b c0       	rjmp	.+246    	; 0x41c8 <LCD_set_cursor+0x19e>
	{
		_delay_ms(__us / 1000.0);
    40d2:	6d 89       	ldd	r22, Y+21	; 0x15
    40d4:	7e 89       	ldd	r23, Y+22	; 0x16
    40d6:	8f 89       	ldd	r24, Y+23	; 0x17
    40d8:	98 8d       	ldd	r25, Y+24	; 0x18
    40da:	20 e0       	ldi	r18, 0x00	; 0
    40dc:	30 e0       	ldi	r19, 0x00	; 0
    40de:	4a e7       	ldi	r20, 0x7A	; 122
    40e0:	54 e4       	ldi	r21, 0x44	; 68
    40e2:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    40e6:	dc 01       	movw	r26, r24
    40e8:	cb 01       	movw	r24, r22
    40ea:	8c 87       	std	Y+12, r24	; 0x0c
    40ec:	9d 87       	std	Y+13, r25	; 0x0d
    40ee:	ae 87       	std	Y+14, r26	; 0x0e
    40f0:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    40f2:	6c 85       	ldd	r22, Y+12	; 0x0c
    40f4:	7d 85       	ldd	r23, Y+13	; 0x0d
    40f6:	8e 85       	ldd	r24, Y+14	; 0x0e
    40f8:	9f 85       	ldd	r25, Y+15	; 0x0f
    40fa:	20 e0       	ldi	r18, 0x00	; 0
    40fc:	30 e0       	ldi	r19, 0x00	; 0
    40fe:	4a ef       	ldi	r20, 0xFA	; 250
    4100:	54 e4       	ldi	r21, 0x44	; 68
    4102:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4106:	dc 01       	movw	r26, r24
    4108:	cb 01       	movw	r24, r22
    410a:	88 87       	std	Y+8, r24	; 0x08
    410c:	99 87       	std	Y+9, r25	; 0x09
    410e:	aa 87       	std	Y+10, r26	; 0x0a
    4110:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    4112:	68 85       	ldd	r22, Y+8	; 0x08
    4114:	79 85       	ldd	r23, Y+9	; 0x09
    4116:	8a 85       	ldd	r24, Y+10	; 0x0a
    4118:	9b 85       	ldd	r25, Y+11	; 0x0b
    411a:	20 e0       	ldi	r18, 0x00	; 0
    411c:	30 e0       	ldi	r19, 0x00	; 0
    411e:	40 e8       	ldi	r20, 0x80	; 128
    4120:	5f e3       	ldi	r21, 0x3F	; 63
    4122:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4126:	88 23       	and	r24, r24
    4128:	2c f4       	brge	.+10     	; 0x4134 <LCD_set_cursor+0x10a>
		__ticks = 1;
    412a:	81 e0       	ldi	r24, 0x01	; 1
    412c:	90 e0       	ldi	r25, 0x00	; 0
    412e:	9f 83       	std	Y+7, r25	; 0x07
    4130:	8e 83       	std	Y+6, r24	; 0x06
    4132:	3f c0       	rjmp	.+126    	; 0x41b2 <LCD_set_cursor+0x188>
	else if (__tmp > 65535)
    4134:	68 85       	ldd	r22, Y+8	; 0x08
    4136:	79 85       	ldd	r23, Y+9	; 0x09
    4138:	8a 85       	ldd	r24, Y+10	; 0x0a
    413a:	9b 85       	ldd	r25, Y+11	; 0x0b
    413c:	20 e0       	ldi	r18, 0x00	; 0
    413e:	3f ef       	ldi	r19, 0xFF	; 255
    4140:	4f e7       	ldi	r20, 0x7F	; 127
    4142:	57 e4       	ldi	r21, 0x47	; 71
    4144:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4148:	18 16       	cp	r1, r24
    414a:	4c f5       	brge	.+82     	; 0x419e <LCD_set_cursor+0x174>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    414c:	6c 85       	ldd	r22, Y+12	; 0x0c
    414e:	7d 85       	ldd	r23, Y+13	; 0x0d
    4150:	8e 85       	ldd	r24, Y+14	; 0x0e
    4152:	9f 85       	ldd	r25, Y+15	; 0x0f
    4154:	20 e0       	ldi	r18, 0x00	; 0
    4156:	30 e0       	ldi	r19, 0x00	; 0
    4158:	40 e2       	ldi	r20, 0x20	; 32
    415a:	51 e4       	ldi	r21, 0x41	; 65
    415c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4160:	dc 01       	movw	r26, r24
    4162:	cb 01       	movw	r24, r22
    4164:	bc 01       	movw	r22, r24
    4166:	cd 01       	movw	r24, r26
    4168:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    416c:	dc 01       	movw	r26, r24
    416e:	cb 01       	movw	r24, r22
    4170:	9f 83       	std	Y+7, r25	; 0x07
    4172:	8e 83       	std	Y+6, r24	; 0x06
    4174:	0f c0       	rjmp	.+30     	; 0x4194 <LCD_set_cursor+0x16a>
    4176:	88 ec       	ldi	r24, 0xC8	; 200
    4178:	90 e0       	ldi	r25, 0x00	; 0
    417a:	9d 83       	std	Y+5, r25	; 0x05
    417c:	8c 83       	std	Y+4, r24	; 0x04
    417e:	8c 81       	ldd	r24, Y+4	; 0x04
    4180:	9d 81       	ldd	r25, Y+5	; 0x05
    4182:	01 97       	sbiw	r24, 0x01	; 1
    4184:	f1 f7       	brne	.-4      	; 0x4182 <LCD_set_cursor+0x158>
    4186:	9d 83       	std	Y+5, r25	; 0x05
    4188:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    418a:	8e 81       	ldd	r24, Y+6	; 0x06
    418c:	9f 81       	ldd	r25, Y+7	; 0x07
    418e:	01 97       	sbiw	r24, 0x01	; 1
    4190:	9f 83       	std	Y+7, r25	; 0x07
    4192:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4194:	8e 81       	ldd	r24, Y+6	; 0x06
    4196:	9f 81       	ldd	r25, Y+7	; 0x07
    4198:	00 97       	sbiw	r24, 0x00	; 0
    419a:	69 f7       	brne	.-38     	; 0x4176 <LCD_set_cursor+0x14c>
    419c:	24 c0       	rjmp	.+72     	; 0x41e6 <LCD_set_cursor+0x1bc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    419e:	68 85       	ldd	r22, Y+8	; 0x08
    41a0:	79 85       	ldd	r23, Y+9	; 0x09
    41a2:	8a 85       	ldd	r24, Y+10	; 0x0a
    41a4:	9b 85       	ldd	r25, Y+11	; 0x0b
    41a6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    41aa:	dc 01       	movw	r26, r24
    41ac:	cb 01       	movw	r24, r22
    41ae:	9f 83       	std	Y+7, r25	; 0x07
    41b0:	8e 83       	std	Y+6, r24	; 0x06
    41b2:	8e 81       	ldd	r24, Y+6	; 0x06
    41b4:	9f 81       	ldd	r25, Y+7	; 0x07
    41b6:	9b 83       	std	Y+3, r25	; 0x03
    41b8:	8a 83       	std	Y+2, r24	; 0x02
    41ba:	8a 81       	ldd	r24, Y+2	; 0x02
    41bc:	9b 81       	ldd	r25, Y+3	; 0x03
    41be:	01 97       	sbiw	r24, 0x01	; 1
    41c0:	f1 f7       	brne	.-4      	; 0x41be <LCD_set_cursor+0x194>
    41c2:	9b 83       	std	Y+3, r25	; 0x03
    41c4:	8a 83       	std	Y+2, r24	; 0x02
    41c6:	0f c0       	rjmp	.+30     	; 0x41e6 <LCD_set_cursor+0x1bc>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    41c8:	69 89       	ldd	r22, Y+17	; 0x11
    41ca:	7a 89       	ldd	r23, Y+18	; 0x12
    41cc:	8b 89       	ldd	r24, Y+19	; 0x13
    41ce:	9c 89       	ldd	r25, Y+20	; 0x14
    41d0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    41d4:	dc 01       	movw	r26, r24
    41d6:	cb 01       	movw	r24, r22
    41d8:	88 8b       	std	Y+16, r24	; 0x10
    41da:	88 89       	ldd	r24, Y+16	; 0x10
    41dc:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    41de:	89 81       	ldd	r24, Y+1	; 0x01
    41e0:	8a 95       	dec	r24
    41e2:	f1 f7       	brne	.-4      	; 0x41e0 <LCD_set_cursor+0x1b6>
    41e4:	89 83       	std	Y+1, r24	; 0x01

#endif



}
    41e6:	6b 96       	adiw	r28, 0x1b	; 27
    41e8:	0f b6       	in	r0, 0x3f	; 63
    41ea:	f8 94       	cli
    41ec:	de bf       	out	0x3e, r29	; 62
    41ee:	0f be       	out	0x3f, r0	; 63
    41f0:	cd bf       	out	0x3d, r28	; 61
    41f2:	cf 91       	pop	r28
    41f4:	df 91       	pop	r29
    41f6:	08 95       	ret

000041f8 <LCD_on>:

void LCD_on(){
    41f8:	df 93       	push	r29
    41fa:	cf 93       	push	r28
    41fc:	cd b7       	in	r28, 0x3d	; 61
    41fe:	de b7       	in	r29, 0x3e	; 62
    4200:	68 97       	sbiw	r28, 0x18	; 24
    4202:	0f b6       	in	r0, 0x3f	; 63
    4204:	f8 94       	cli
    4206:	de bf       	out	0x3e, r29	; 62
    4208:	0f be       	out	0x3f, r0	; 63
    420a:	cd bf       	out	0x3d, r28	; 61
	LCD_write_command_8bit(display_On);
	_delay_us(50);

#elif LCD_interface_mode == interface_4bit

	LCD_write_command_4bit(display_On);
    420c:	8c e0       	ldi	r24, 0x0C	; 12
    420e:	0e 94 57 11 	call	0x22ae	; 0x22ae <LCD_write_command_4bit>
    4212:	80 e0       	ldi	r24, 0x00	; 0
    4214:	90 e0       	ldi	r25, 0x00	; 0
    4216:	a8 e4       	ldi	r26, 0x48	; 72
    4218:	b2 e4       	ldi	r27, 0x42	; 66
    421a:	8d 8b       	std	Y+21, r24	; 0x15
    421c:	9e 8b       	std	Y+22, r25	; 0x16
    421e:	af 8b       	std	Y+23, r26	; 0x17
    4220:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    4222:	6d 89       	ldd	r22, Y+21	; 0x15
    4224:	7e 89       	ldd	r23, Y+22	; 0x16
    4226:	8f 89       	ldd	r24, Y+23	; 0x17
    4228:	98 8d       	ldd	r25, Y+24	; 0x18
    422a:	2b ea       	ldi	r18, 0xAB	; 171
    422c:	3a ea       	ldi	r19, 0xAA	; 170
    422e:	4a e2       	ldi	r20, 0x2A	; 42
    4230:	50 e4       	ldi	r21, 0x40	; 64
    4232:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4236:	dc 01       	movw	r26, r24
    4238:	cb 01       	movw	r24, r22
    423a:	89 8b       	std	Y+17, r24	; 0x11
    423c:	9a 8b       	std	Y+18, r25	; 0x12
    423e:	ab 8b       	std	Y+19, r26	; 0x13
    4240:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    4242:	69 89       	ldd	r22, Y+17	; 0x11
    4244:	7a 89       	ldd	r23, Y+18	; 0x12
    4246:	8b 89       	ldd	r24, Y+19	; 0x13
    4248:	9c 89       	ldd	r25, Y+20	; 0x14
    424a:	20 e0       	ldi	r18, 0x00	; 0
    424c:	30 e0       	ldi	r19, 0x00	; 0
    424e:	40 e8       	ldi	r20, 0x80	; 128
    4250:	5f e3       	ldi	r21, 0x3F	; 63
    4252:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4256:	88 23       	and	r24, r24
    4258:	1c f4       	brge	.+6      	; 0x4260 <LCD_on+0x68>
		__ticks = 1;
    425a:	81 e0       	ldi	r24, 0x01	; 1
    425c:	88 8b       	std	Y+16, r24	; 0x10
    425e:	91 c0       	rjmp	.+290    	; 0x4382 <LCD_on+0x18a>
	else if (__tmp > 255)
    4260:	69 89       	ldd	r22, Y+17	; 0x11
    4262:	7a 89       	ldd	r23, Y+18	; 0x12
    4264:	8b 89       	ldd	r24, Y+19	; 0x13
    4266:	9c 89       	ldd	r25, Y+20	; 0x14
    4268:	20 e0       	ldi	r18, 0x00	; 0
    426a:	30 e0       	ldi	r19, 0x00	; 0
    426c:	4f e7       	ldi	r20, 0x7F	; 127
    426e:	53 e4       	ldi	r21, 0x43	; 67
    4270:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4274:	18 16       	cp	r1, r24
    4276:	0c f0       	brlt	.+2      	; 0x427a <LCD_on+0x82>
    4278:	7b c0       	rjmp	.+246    	; 0x4370 <LCD_on+0x178>
	{
		_delay_ms(__us / 1000.0);
    427a:	6d 89       	ldd	r22, Y+21	; 0x15
    427c:	7e 89       	ldd	r23, Y+22	; 0x16
    427e:	8f 89       	ldd	r24, Y+23	; 0x17
    4280:	98 8d       	ldd	r25, Y+24	; 0x18
    4282:	20 e0       	ldi	r18, 0x00	; 0
    4284:	30 e0       	ldi	r19, 0x00	; 0
    4286:	4a e7       	ldi	r20, 0x7A	; 122
    4288:	54 e4       	ldi	r21, 0x44	; 68
    428a:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    428e:	dc 01       	movw	r26, r24
    4290:	cb 01       	movw	r24, r22
    4292:	8c 87       	std	Y+12, r24	; 0x0c
    4294:	9d 87       	std	Y+13, r25	; 0x0d
    4296:	ae 87       	std	Y+14, r26	; 0x0e
    4298:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    429a:	6c 85       	ldd	r22, Y+12	; 0x0c
    429c:	7d 85       	ldd	r23, Y+13	; 0x0d
    429e:	8e 85       	ldd	r24, Y+14	; 0x0e
    42a0:	9f 85       	ldd	r25, Y+15	; 0x0f
    42a2:	20 e0       	ldi	r18, 0x00	; 0
    42a4:	30 e0       	ldi	r19, 0x00	; 0
    42a6:	4a ef       	ldi	r20, 0xFA	; 250
    42a8:	54 e4       	ldi	r21, 0x44	; 68
    42aa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    42ae:	dc 01       	movw	r26, r24
    42b0:	cb 01       	movw	r24, r22
    42b2:	88 87       	std	Y+8, r24	; 0x08
    42b4:	99 87       	std	Y+9, r25	; 0x09
    42b6:	aa 87       	std	Y+10, r26	; 0x0a
    42b8:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    42ba:	68 85       	ldd	r22, Y+8	; 0x08
    42bc:	79 85       	ldd	r23, Y+9	; 0x09
    42be:	8a 85       	ldd	r24, Y+10	; 0x0a
    42c0:	9b 85       	ldd	r25, Y+11	; 0x0b
    42c2:	20 e0       	ldi	r18, 0x00	; 0
    42c4:	30 e0       	ldi	r19, 0x00	; 0
    42c6:	40 e8       	ldi	r20, 0x80	; 128
    42c8:	5f e3       	ldi	r21, 0x3F	; 63
    42ca:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    42ce:	88 23       	and	r24, r24
    42d0:	2c f4       	brge	.+10     	; 0x42dc <LCD_on+0xe4>
		__ticks = 1;
    42d2:	81 e0       	ldi	r24, 0x01	; 1
    42d4:	90 e0       	ldi	r25, 0x00	; 0
    42d6:	9f 83       	std	Y+7, r25	; 0x07
    42d8:	8e 83       	std	Y+6, r24	; 0x06
    42da:	3f c0       	rjmp	.+126    	; 0x435a <LCD_on+0x162>
	else if (__tmp > 65535)
    42dc:	68 85       	ldd	r22, Y+8	; 0x08
    42de:	79 85       	ldd	r23, Y+9	; 0x09
    42e0:	8a 85       	ldd	r24, Y+10	; 0x0a
    42e2:	9b 85       	ldd	r25, Y+11	; 0x0b
    42e4:	20 e0       	ldi	r18, 0x00	; 0
    42e6:	3f ef       	ldi	r19, 0xFF	; 255
    42e8:	4f e7       	ldi	r20, 0x7F	; 127
    42ea:	57 e4       	ldi	r21, 0x47	; 71
    42ec:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    42f0:	18 16       	cp	r1, r24
    42f2:	4c f5       	brge	.+82     	; 0x4346 <LCD_on+0x14e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    42f4:	6c 85       	ldd	r22, Y+12	; 0x0c
    42f6:	7d 85       	ldd	r23, Y+13	; 0x0d
    42f8:	8e 85       	ldd	r24, Y+14	; 0x0e
    42fa:	9f 85       	ldd	r25, Y+15	; 0x0f
    42fc:	20 e0       	ldi	r18, 0x00	; 0
    42fe:	30 e0       	ldi	r19, 0x00	; 0
    4300:	40 e2       	ldi	r20, 0x20	; 32
    4302:	51 e4       	ldi	r21, 0x41	; 65
    4304:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4308:	dc 01       	movw	r26, r24
    430a:	cb 01       	movw	r24, r22
    430c:	bc 01       	movw	r22, r24
    430e:	cd 01       	movw	r24, r26
    4310:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4314:	dc 01       	movw	r26, r24
    4316:	cb 01       	movw	r24, r22
    4318:	9f 83       	std	Y+7, r25	; 0x07
    431a:	8e 83       	std	Y+6, r24	; 0x06
    431c:	0f c0       	rjmp	.+30     	; 0x433c <LCD_on+0x144>
    431e:	88 ec       	ldi	r24, 0xC8	; 200
    4320:	90 e0       	ldi	r25, 0x00	; 0
    4322:	9d 83       	std	Y+5, r25	; 0x05
    4324:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4326:	8c 81       	ldd	r24, Y+4	; 0x04
    4328:	9d 81       	ldd	r25, Y+5	; 0x05
    432a:	01 97       	sbiw	r24, 0x01	; 1
    432c:	f1 f7       	brne	.-4      	; 0x432a <LCD_on+0x132>
    432e:	9d 83       	std	Y+5, r25	; 0x05
    4330:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4332:	8e 81       	ldd	r24, Y+6	; 0x06
    4334:	9f 81       	ldd	r25, Y+7	; 0x07
    4336:	01 97       	sbiw	r24, 0x01	; 1
    4338:	9f 83       	std	Y+7, r25	; 0x07
    433a:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    433c:	8e 81       	ldd	r24, Y+6	; 0x06
    433e:	9f 81       	ldd	r25, Y+7	; 0x07
    4340:	00 97       	sbiw	r24, 0x00	; 0
    4342:	69 f7       	brne	.-38     	; 0x431e <LCD_on+0x126>
    4344:	24 c0       	rjmp	.+72     	; 0x438e <LCD_on+0x196>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4346:	68 85       	ldd	r22, Y+8	; 0x08
    4348:	79 85       	ldd	r23, Y+9	; 0x09
    434a:	8a 85       	ldd	r24, Y+10	; 0x0a
    434c:	9b 85       	ldd	r25, Y+11	; 0x0b
    434e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4352:	dc 01       	movw	r26, r24
    4354:	cb 01       	movw	r24, r22
    4356:	9f 83       	std	Y+7, r25	; 0x07
    4358:	8e 83       	std	Y+6, r24	; 0x06
    435a:	8e 81       	ldd	r24, Y+6	; 0x06
    435c:	9f 81       	ldd	r25, Y+7	; 0x07
    435e:	9b 83       	std	Y+3, r25	; 0x03
    4360:	8a 83       	std	Y+2, r24	; 0x02
    4362:	8a 81       	ldd	r24, Y+2	; 0x02
    4364:	9b 81       	ldd	r25, Y+3	; 0x03
    4366:	01 97       	sbiw	r24, 0x01	; 1
    4368:	f1 f7       	brne	.-4      	; 0x4366 <LCD_on+0x16e>
    436a:	9b 83       	std	Y+3, r25	; 0x03
    436c:	8a 83       	std	Y+2, r24	; 0x02
    436e:	0f c0       	rjmp	.+30     	; 0x438e <LCD_on+0x196>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4370:	69 89       	ldd	r22, Y+17	; 0x11
    4372:	7a 89       	ldd	r23, Y+18	; 0x12
    4374:	8b 89       	ldd	r24, Y+19	; 0x13
    4376:	9c 89       	ldd	r25, Y+20	; 0x14
    4378:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    437c:	dc 01       	movw	r26, r24
    437e:	cb 01       	movw	r24, r22
    4380:	88 8b       	std	Y+16, r24	; 0x10
    4382:	88 89       	ldd	r24, Y+16	; 0x10
    4384:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4386:	89 81       	ldd	r24, Y+1	; 0x01
    4388:	8a 95       	dec	r24
    438a:	f1 f7       	brne	.-4      	; 0x4388 <LCD_on+0x190>
    438c:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(50);

#endif


}
    438e:	68 96       	adiw	r28, 0x18	; 24
    4390:	0f b6       	in	r0, 0x3f	; 63
    4392:	f8 94       	cli
    4394:	de bf       	out	0x3e, r29	; 62
    4396:	0f be       	out	0x3f, r0	; 63
    4398:	cd bf       	out	0x3d, r28	; 61
    439a:	cf 91       	pop	r28
    439c:	df 91       	pop	r29
    439e:	08 95       	ret

000043a0 <LCD_off>:

void LCD_off(){
    43a0:	df 93       	push	r29
    43a2:	cf 93       	push	r28
    43a4:	cd b7       	in	r28, 0x3d	; 61
    43a6:	de b7       	in	r29, 0x3e	; 62
    43a8:	68 97       	sbiw	r28, 0x18	; 24
    43aa:	0f b6       	in	r0, 0x3f	; 63
    43ac:	f8 94       	cli
    43ae:	de bf       	out	0x3e, r29	; 62
    43b0:	0f be       	out	0x3f, r0	; 63
    43b2:	cd bf       	out	0x3d, r28	; 61
	LCD_write_command_8bit(display_Off);
	_delay_us(50);

#elif LCD_interface_mode == interface_4bit

	LCD_write_command_4bit(display_Off);
    43b4:	88 e0       	ldi	r24, 0x08	; 8
    43b6:	0e 94 57 11 	call	0x22ae	; 0x22ae <LCD_write_command_4bit>
    43ba:	80 e0       	ldi	r24, 0x00	; 0
    43bc:	90 e0       	ldi	r25, 0x00	; 0
    43be:	a8 e4       	ldi	r26, 0x48	; 72
    43c0:	b2 e4       	ldi	r27, 0x42	; 66
    43c2:	8d 8b       	std	Y+21, r24	; 0x15
    43c4:	9e 8b       	std	Y+22, r25	; 0x16
    43c6:	af 8b       	std	Y+23, r26	; 0x17
    43c8:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    43ca:	6d 89       	ldd	r22, Y+21	; 0x15
    43cc:	7e 89       	ldd	r23, Y+22	; 0x16
    43ce:	8f 89       	ldd	r24, Y+23	; 0x17
    43d0:	98 8d       	ldd	r25, Y+24	; 0x18
    43d2:	2b ea       	ldi	r18, 0xAB	; 171
    43d4:	3a ea       	ldi	r19, 0xAA	; 170
    43d6:	4a e2       	ldi	r20, 0x2A	; 42
    43d8:	50 e4       	ldi	r21, 0x40	; 64
    43da:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    43de:	dc 01       	movw	r26, r24
    43e0:	cb 01       	movw	r24, r22
    43e2:	89 8b       	std	Y+17, r24	; 0x11
    43e4:	9a 8b       	std	Y+18, r25	; 0x12
    43e6:	ab 8b       	std	Y+19, r26	; 0x13
    43e8:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    43ea:	69 89       	ldd	r22, Y+17	; 0x11
    43ec:	7a 89       	ldd	r23, Y+18	; 0x12
    43ee:	8b 89       	ldd	r24, Y+19	; 0x13
    43f0:	9c 89       	ldd	r25, Y+20	; 0x14
    43f2:	20 e0       	ldi	r18, 0x00	; 0
    43f4:	30 e0       	ldi	r19, 0x00	; 0
    43f6:	40 e8       	ldi	r20, 0x80	; 128
    43f8:	5f e3       	ldi	r21, 0x3F	; 63
    43fa:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    43fe:	88 23       	and	r24, r24
    4400:	1c f4       	brge	.+6      	; 0x4408 <LCD_off+0x68>
		__ticks = 1;
    4402:	81 e0       	ldi	r24, 0x01	; 1
    4404:	88 8b       	std	Y+16, r24	; 0x10
    4406:	91 c0       	rjmp	.+290    	; 0x452a <LCD_off+0x18a>
	else if (__tmp > 255)
    4408:	69 89       	ldd	r22, Y+17	; 0x11
    440a:	7a 89       	ldd	r23, Y+18	; 0x12
    440c:	8b 89       	ldd	r24, Y+19	; 0x13
    440e:	9c 89       	ldd	r25, Y+20	; 0x14
    4410:	20 e0       	ldi	r18, 0x00	; 0
    4412:	30 e0       	ldi	r19, 0x00	; 0
    4414:	4f e7       	ldi	r20, 0x7F	; 127
    4416:	53 e4       	ldi	r21, 0x43	; 67
    4418:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    441c:	18 16       	cp	r1, r24
    441e:	0c f0       	brlt	.+2      	; 0x4422 <LCD_off+0x82>
    4420:	7b c0       	rjmp	.+246    	; 0x4518 <LCD_off+0x178>
	{
		_delay_ms(__us / 1000.0);
    4422:	6d 89       	ldd	r22, Y+21	; 0x15
    4424:	7e 89       	ldd	r23, Y+22	; 0x16
    4426:	8f 89       	ldd	r24, Y+23	; 0x17
    4428:	98 8d       	ldd	r25, Y+24	; 0x18
    442a:	20 e0       	ldi	r18, 0x00	; 0
    442c:	30 e0       	ldi	r19, 0x00	; 0
    442e:	4a e7       	ldi	r20, 0x7A	; 122
    4430:	54 e4       	ldi	r21, 0x44	; 68
    4432:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    4436:	dc 01       	movw	r26, r24
    4438:	cb 01       	movw	r24, r22
    443a:	8c 87       	std	Y+12, r24	; 0x0c
    443c:	9d 87       	std	Y+13, r25	; 0x0d
    443e:	ae 87       	std	Y+14, r26	; 0x0e
    4440:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4442:	6c 85       	ldd	r22, Y+12	; 0x0c
    4444:	7d 85       	ldd	r23, Y+13	; 0x0d
    4446:	8e 85       	ldd	r24, Y+14	; 0x0e
    4448:	9f 85       	ldd	r25, Y+15	; 0x0f
    444a:	20 e0       	ldi	r18, 0x00	; 0
    444c:	30 e0       	ldi	r19, 0x00	; 0
    444e:	4a ef       	ldi	r20, 0xFA	; 250
    4450:	54 e4       	ldi	r21, 0x44	; 68
    4452:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4456:	dc 01       	movw	r26, r24
    4458:	cb 01       	movw	r24, r22
    445a:	88 87       	std	Y+8, r24	; 0x08
    445c:	99 87       	std	Y+9, r25	; 0x09
    445e:	aa 87       	std	Y+10, r26	; 0x0a
    4460:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    4462:	68 85       	ldd	r22, Y+8	; 0x08
    4464:	79 85       	ldd	r23, Y+9	; 0x09
    4466:	8a 85       	ldd	r24, Y+10	; 0x0a
    4468:	9b 85       	ldd	r25, Y+11	; 0x0b
    446a:	20 e0       	ldi	r18, 0x00	; 0
    446c:	30 e0       	ldi	r19, 0x00	; 0
    446e:	40 e8       	ldi	r20, 0x80	; 128
    4470:	5f e3       	ldi	r21, 0x3F	; 63
    4472:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4476:	88 23       	and	r24, r24
    4478:	2c f4       	brge	.+10     	; 0x4484 <LCD_off+0xe4>
		__ticks = 1;
    447a:	81 e0       	ldi	r24, 0x01	; 1
    447c:	90 e0       	ldi	r25, 0x00	; 0
    447e:	9f 83       	std	Y+7, r25	; 0x07
    4480:	8e 83       	std	Y+6, r24	; 0x06
    4482:	3f c0       	rjmp	.+126    	; 0x4502 <LCD_off+0x162>
	else if (__tmp > 65535)
    4484:	68 85       	ldd	r22, Y+8	; 0x08
    4486:	79 85       	ldd	r23, Y+9	; 0x09
    4488:	8a 85       	ldd	r24, Y+10	; 0x0a
    448a:	9b 85       	ldd	r25, Y+11	; 0x0b
    448c:	20 e0       	ldi	r18, 0x00	; 0
    448e:	3f ef       	ldi	r19, 0xFF	; 255
    4490:	4f e7       	ldi	r20, 0x7F	; 127
    4492:	57 e4       	ldi	r21, 0x47	; 71
    4494:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4498:	18 16       	cp	r1, r24
    449a:	4c f5       	brge	.+82     	; 0x44ee <LCD_off+0x14e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    449c:	6c 85       	ldd	r22, Y+12	; 0x0c
    449e:	7d 85       	ldd	r23, Y+13	; 0x0d
    44a0:	8e 85       	ldd	r24, Y+14	; 0x0e
    44a2:	9f 85       	ldd	r25, Y+15	; 0x0f
    44a4:	20 e0       	ldi	r18, 0x00	; 0
    44a6:	30 e0       	ldi	r19, 0x00	; 0
    44a8:	40 e2       	ldi	r20, 0x20	; 32
    44aa:	51 e4       	ldi	r21, 0x41	; 65
    44ac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    44b0:	dc 01       	movw	r26, r24
    44b2:	cb 01       	movw	r24, r22
    44b4:	bc 01       	movw	r22, r24
    44b6:	cd 01       	movw	r24, r26
    44b8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    44bc:	dc 01       	movw	r26, r24
    44be:	cb 01       	movw	r24, r22
    44c0:	9f 83       	std	Y+7, r25	; 0x07
    44c2:	8e 83       	std	Y+6, r24	; 0x06
    44c4:	0f c0       	rjmp	.+30     	; 0x44e4 <LCD_off+0x144>
    44c6:	88 ec       	ldi	r24, 0xC8	; 200
    44c8:	90 e0       	ldi	r25, 0x00	; 0
    44ca:	9d 83       	std	Y+5, r25	; 0x05
    44cc:	8c 83       	std	Y+4, r24	; 0x04
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    44ce:	8c 81       	ldd	r24, Y+4	; 0x04
    44d0:	9d 81       	ldd	r25, Y+5	; 0x05
    44d2:	01 97       	sbiw	r24, 0x01	; 1
    44d4:	f1 f7       	brne	.-4      	; 0x44d2 <LCD_off+0x132>
    44d6:	9d 83       	std	Y+5, r25	; 0x05
    44d8:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    44da:	8e 81       	ldd	r24, Y+6	; 0x06
    44dc:	9f 81       	ldd	r25, Y+7	; 0x07
    44de:	01 97       	sbiw	r24, 0x01	; 1
    44e0:	9f 83       	std	Y+7, r25	; 0x07
    44e2:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    44e4:	8e 81       	ldd	r24, Y+6	; 0x06
    44e6:	9f 81       	ldd	r25, Y+7	; 0x07
    44e8:	00 97       	sbiw	r24, 0x00	; 0
    44ea:	69 f7       	brne	.-38     	; 0x44c6 <LCD_off+0x126>
    44ec:	24 c0       	rjmp	.+72     	; 0x4536 <LCD_off+0x196>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    44ee:	68 85       	ldd	r22, Y+8	; 0x08
    44f0:	79 85       	ldd	r23, Y+9	; 0x09
    44f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    44f4:	9b 85       	ldd	r25, Y+11	; 0x0b
    44f6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    44fa:	dc 01       	movw	r26, r24
    44fc:	cb 01       	movw	r24, r22
    44fe:	9f 83       	std	Y+7, r25	; 0x07
    4500:	8e 83       	std	Y+6, r24	; 0x06
    4502:	8e 81       	ldd	r24, Y+6	; 0x06
    4504:	9f 81       	ldd	r25, Y+7	; 0x07
    4506:	9b 83       	std	Y+3, r25	; 0x03
    4508:	8a 83       	std	Y+2, r24	; 0x02
    450a:	8a 81       	ldd	r24, Y+2	; 0x02
    450c:	9b 81       	ldd	r25, Y+3	; 0x03
    450e:	01 97       	sbiw	r24, 0x01	; 1
    4510:	f1 f7       	brne	.-4      	; 0x450e <LCD_off+0x16e>
    4512:	9b 83       	std	Y+3, r25	; 0x03
    4514:	8a 83       	std	Y+2, r24	; 0x02
    4516:	0f c0       	rjmp	.+30     	; 0x4536 <LCD_off+0x196>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4518:	69 89       	ldd	r22, Y+17	; 0x11
    451a:	7a 89       	ldd	r23, Y+18	; 0x12
    451c:	8b 89       	ldd	r24, Y+19	; 0x13
    451e:	9c 89       	ldd	r25, Y+20	; 0x14
    4520:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4524:	dc 01       	movw	r26, r24
    4526:	cb 01       	movw	r24, r22
    4528:	88 8b       	std	Y+16, r24	; 0x10
    452a:	88 89       	ldd	r24, Y+16	; 0x10
    452c:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    452e:	89 81       	ldd	r24, Y+1	; 0x01
    4530:	8a 95       	dec	r24
    4532:	f1 f7       	brne	.-4      	; 0x4530 <LCD_off+0x190>
    4534:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(50);

#endif


}
    4536:	68 96       	adiw	r28, 0x18	; 24
    4538:	0f b6       	in	r0, 0x3f	; 63
    453a:	f8 94       	cli
    453c:	de bf       	out	0x3e, r29	; 62
    453e:	0f be       	out	0x3f, r0	; 63
    4540:	cd bf       	out	0x3d, r28	; 61
    4542:	cf 91       	pop	r28
    4544:	df 91       	pop	r29
    4546:	08 95       	ret

00004548 <LCD_clear_display>:

void LCD_clear_display(){
    4548:	df 93       	push	r29
    454a:	cf 93       	push	r28
    454c:	cd b7       	in	r28, 0x3d	; 61
    454e:	de b7       	in	r29, 0x3e	; 62
    4550:	6c 97       	sbiw	r28, 0x1c	; 28
    4552:	0f b6       	in	r0, 0x3f	; 63
    4554:	f8 94       	cli
    4556:	de bf       	out	0x3e, r29	; 62
    4558:	0f be       	out	0x3f, r0	; 63
    455a:	cd bf       	out	0x3d, r28	; 61
	//return home
	LCD_write_command_8bit(return_Home);
	_delay_ms(2);

#elif LCD_interface_mode == interface_4bit
	LCD_write_command_4bit(clear_Display);
    455c:	81 e0       	ldi	r24, 0x01	; 1
    455e:	0e 94 57 11 	call	0x22ae	; 0x22ae <LCD_write_command_4bit>
    4562:	80 e0       	ldi	r24, 0x00	; 0
    4564:	90 e0       	ldi	r25, 0x00	; 0
    4566:	a0 e0       	ldi	r26, 0x00	; 0
    4568:	b0 e4       	ldi	r27, 0x40	; 64
    456a:	89 8f       	std	Y+25, r24	; 0x19
    456c:	9a 8f       	std	Y+26, r25	; 0x1a
    456e:	ab 8f       	std	Y+27, r26	; 0x1b
    4570:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4572:	69 8d       	ldd	r22, Y+25	; 0x19
    4574:	7a 8d       	ldd	r23, Y+26	; 0x1a
    4576:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4578:	9c 8d       	ldd	r25, Y+28	; 0x1c
    457a:	20 e0       	ldi	r18, 0x00	; 0
    457c:	30 e0       	ldi	r19, 0x00	; 0
    457e:	4a ef       	ldi	r20, 0xFA	; 250
    4580:	54 e4       	ldi	r21, 0x44	; 68
    4582:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4586:	dc 01       	movw	r26, r24
    4588:	cb 01       	movw	r24, r22
    458a:	8d 8b       	std	Y+21, r24	; 0x15
    458c:	9e 8b       	std	Y+22, r25	; 0x16
    458e:	af 8b       	std	Y+23, r26	; 0x17
    4590:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    4592:	6d 89       	ldd	r22, Y+21	; 0x15
    4594:	7e 89       	ldd	r23, Y+22	; 0x16
    4596:	8f 89       	ldd	r24, Y+23	; 0x17
    4598:	98 8d       	ldd	r25, Y+24	; 0x18
    459a:	20 e0       	ldi	r18, 0x00	; 0
    459c:	30 e0       	ldi	r19, 0x00	; 0
    459e:	40 e8       	ldi	r20, 0x80	; 128
    45a0:	5f e3       	ldi	r21, 0x3F	; 63
    45a2:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    45a6:	88 23       	and	r24, r24
    45a8:	2c f4       	brge	.+10     	; 0x45b4 <LCD_clear_display+0x6c>
		__ticks = 1;
    45aa:	81 e0       	ldi	r24, 0x01	; 1
    45ac:	90 e0       	ldi	r25, 0x00	; 0
    45ae:	9c 8b       	std	Y+20, r25	; 0x14
    45b0:	8b 8b       	std	Y+19, r24	; 0x13
    45b2:	3f c0       	rjmp	.+126    	; 0x4632 <LCD_clear_display+0xea>
	else if (__tmp > 65535)
    45b4:	6d 89       	ldd	r22, Y+21	; 0x15
    45b6:	7e 89       	ldd	r23, Y+22	; 0x16
    45b8:	8f 89       	ldd	r24, Y+23	; 0x17
    45ba:	98 8d       	ldd	r25, Y+24	; 0x18
    45bc:	20 e0       	ldi	r18, 0x00	; 0
    45be:	3f ef       	ldi	r19, 0xFF	; 255
    45c0:	4f e7       	ldi	r20, 0x7F	; 127
    45c2:	57 e4       	ldi	r21, 0x47	; 71
    45c4:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    45c8:	18 16       	cp	r1, r24
    45ca:	4c f5       	brge	.+82     	; 0x461e <LCD_clear_display+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    45cc:	69 8d       	ldd	r22, Y+25	; 0x19
    45ce:	7a 8d       	ldd	r23, Y+26	; 0x1a
    45d0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    45d2:	9c 8d       	ldd	r25, Y+28	; 0x1c
    45d4:	20 e0       	ldi	r18, 0x00	; 0
    45d6:	30 e0       	ldi	r19, 0x00	; 0
    45d8:	40 e2       	ldi	r20, 0x20	; 32
    45da:	51 e4       	ldi	r21, 0x41	; 65
    45dc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    45e0:	dc 01       	movw	r26, r24
    45e2:	cb 01       	movw	r24, r22
    45e4:	bc 01       	movw	r22, r24
    45e6:	cd 01       	movw	r24, r26
    45e8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    45ec:	dc 01       	movw	r26, r24
    45ee:	cb 01       	movw	r24, r22
    45f0:	9c 8b       	std	Y+20, r25	; 0x14
    45f2:	8b 8b       	std	Y+19, r24	; 0x13
    45f4:	0f c0       	rjmp	.+30     	; 0x4614 <LCD_clear_display+0xcc>
    45f6:	88 ec       	ldi	r24, 0xC8	; 200
    45f8:	90 e0       	ldi	r25, 0x00	; 0
    45fa:	9a 8b       	std	Y+18, r25	; 0x12
    45fc:	89 8b       	std	Y+17, r24	; 0x11
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    45fe:	89 89       	ldd	r24, Y+17	; 0x11
    4600:	9a 89       	ldd	r25, Y+18	; 0x12
    4602:	01 97       	sbiw	r24, 0x01	; 1
    4604:	f1 f7       	brne	.-4      	; 0x4602 <LCD_clear_display+0xba>
    4606:	9a 8b       	std	Y+18, r25	; 0x12
    4608:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    460a:	8b 89       	ldd	r24, Y+19	; 0x13
    460c:	9c 89       	ldd	r25, Y+20	; 0x14
    460e:	01 97       	sbiw	r24, 0x01	; 1
    4610:	9c 8b       	std	Y+20, r25	; 0x14
    4612:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4614:	8b 89       	ldd	r24, Y+19	; 0x13
    4616:	9c 89       	ldd	r25, Y+20	; 0x14
    4618:	00 97       	sbiw	r24, 0x00	; 0
    461a:	69 f7       	brne	.-38     	; 0x45f6 <LCD_clear_display+0xae>
    461c:	14 c0       	rjmp	.+40     	; 0x4646 <LCD_clear_display+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    461e:	6d 89       	ldd	r22, Y+21	; 0x15
    4620:	7e 89       	ldd	r23, Y+22	; 0x16
    4622:	8f 89       	ldd	r24, Y+23	; 0x17
    4624:	98 8d       	ldd	r25, Y+24	; 0x18
    4626:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    462a:	dc 01       	movw	r26, r24
    462c:	cb 01       	movw	r24, r22
    462e:	9c 8b       	std	Y+20, r25	; 0x14
    4630:	8b 8b       	std	Y+19, r24	; 0x13
    4632:	8b 89       	ldd	r24, Y+19	; 0x13
    4634:	9c 89       	ldd	r25, Y+20	; 0x14
    4636:	98 8b       	std	Y+16, r25	; 0x10
    4638:	8f 87       	std	Y+15, r24	; 0x0f
    463a:	8f 85       	ldd	r24, Y+15	; 0x0f
    463c:	98 89       	ldd	r25, Y+16	; 0x10
    463e:	01 97       	sbiw	r24, 0x01	; 1
    4640:	f1 f7       	brne	.-4      	; 0x463e <LCD_clear_display+0xf6>
    4642:	98 8b       	std	Y+16, r25	; 0x10
    4644:	8f 87       	std	Y+15, r24	; 0x0f
	//wait more than 1.53 ms
	_delay_ms(2);
	//return home
	LCD_write_command_4bit(return_Home);
    4646:	82 e0       	ldi	r24, 0x02	; 2
    4648:	0e 94 57 11 	call	0x22ae	; 0x22ae <LCD_write_command_4bit>
    464c:	80 e0       	ldi	r24, 0x00	; 0
    464e:	90 e0       	ldi	r25, 0x00	; 0
    4650:	a0 e0       	ldi	r26, 0x00	; 0
    4652:	b0 e4       	ldi	r27, 0x40	; 64
    4654:	8b 87       	std	Y+11, r24	; 0x0b
    4656:	9c 87       	std	Y+12, r25	; 0x0c
    4658:	ad 87       	std	Y+13, r26	; 0x0d
    465a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    465c:	6b 85       	ldd	r22, Y+11	; 0x0b
    465e:	7c 85       	ldd	r23, Y+12	; 0x0c
    4660:	8d 85       	ldd	r24, Y+13	; 0x0d
    4662:	9e 85       	ldd	r25, Y+14	; 0x0e
    4664:	20 e0       	ldi	r18, 0x00	; 0
    4666:	30 e0       	ldi	r19, 0x00	; 0
    4668:	4a ef       	ldi	r20, 0xFA	; 250
    466a:	54 e4       	ldi	r21, 0x44	; 68
    466c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4670:	dc 01       	movw	r26, r24
    4672:	cb 01       	movw	r24, r22
    4674:	8f 83       	std	Y+7, r24	; 0x07
    4676:	98 87       	std	Y+8, r25	; 0x08
    4678:	a9 87       	std	Y+9, r26	; 0x09
    467a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    467c:	6f 81       	ldd	r22, Y+7	; 0x07
    467e:	78 85       	ldd	r23, Y+8	; 0x08
    4680:	89 85       	ldd	r24, Y+9	; 0x09
    4682:	9a 85       	ldd	r25, Y+10	; 0x0a
    4684:	20 e0       	ldi	r18, 0x00	; 0
    4686:	30 e0       	ldi	r19, 0x00	; 0
    4688:	40 e8       	ldi	r20, 0x80	; 128
    468a:	5f e3       	ldi	r21, 0x3F	; 63
    468c:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4690:	88 23       	and	r24, r24
    4692:	2c f4       	brge	.+10     	; 0x469e <LCD_clear_display+0x156>
		__ticks = 1;
    4694:	81 e0       	ldi	r24, 0x01	; 1
    4696:	90 e0       	ldi	r25, 0x00	; 0
    4698:	9e 83       	std	Y+6, r25	; 0x06
    469a:	8d 83       	std	Y+5, r24	; 0x05
    469c:	3f c0       	rjmp	.+126    	; 0x471c <LCD_clear_display+0x1d4>
	else if (__tmp > 65535)
    469e:	6f 81       	ldd	r22, Y+7	; 0x07
    46a0:	78 85       	ldd	r23, Y+8	; 0x08
    46a2:	89 85       	ldd	r24, Y+9	; 0x09
    46a4:	9a 85       	ldd	r25, Y+10	; 0x0a
    46a6:	20 e0       	ldi	r18, 0x00	; 0
    46a8:	3f ef       	ldi	r19, 0xFF	; 255
    46aa:	4f e7       	ldi	r20, 0x7F	; 127
    46ac:	57 e4       	ldi	r21, 0x47	; 71
    46ae:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    46b2:	18 16       	cp	r1, r24
    46b4:	4c f5       	brge	.+82     	; 0x4708 <LCD_clear_display+0x1c0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    46b6:	6b 85       	ldd	r22, Y+11	; 0x0b
    46b8:	7c 85       	ldd	r23, Y+12	; 0x0c
    46ba:	8d 85       	ldd	r24, Y+13	; 0x0d
    46bc:	9e 85       	ldd	r25, Y+14	; 0x0e
    46be:	20 e0       	ldi	r18, 0x00	; 0
    46c0:	30 e0       	ldi	r19, 0x00	; 0
    46c2:	40 e2       	ldi	r20, 0x20	; 32
    46c4:	51 e4       	ldi	r21, 0x41	; 65
    46c6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    46ca:	dc 01       	movw	r26, r24
    46cc:	cb 01       	movw	r24, r22
    46ce:	bc 01       	movw	r22, r24
    46d0:	cd 01       	movw	r24, r26
    46d2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    46d6:	dc 01       	movw	r26, r24
    46d8:	cb 01       	movw	r24, r22
    46da:	9e 83       	std	Y+6, r25	; 0x06
    46dc:	8d 83       	std	Y+5, r24	; 0x05
    46de:	0f c0       	rjmp	.+30     	; 0x46fe <LCD_clear_display+0x1b6>
    46e0:	88 ec       	ldi	r24, 0xC8	; 200
    46e2:	90 e0       	ldi	r25, 0x00	; 0
    46e4:	9c 83       	std	Y+4, r25	; 0x04
    46e6:	8b 83       	std	Y+3, r24	; 0x03
    46e8:	8b 81       	ldd	r24, Y+3	; 0x03
    46ea:	9c 81       	ldd	r25, Y+4	; 0x04
    46ec:	01 97       	sbiw	r24, 0x01	; 1
    46ee:	f1 f7       	brne	.-4      	; 0x46ec <LCD_clear_display+0x1a4>
    46f0:	9c 83       	std	Y+4, r25	; 0x04
    46f2:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    46f4:	8d 81       	ldd	r24, Y+5	; 0x05
    46f6:	9e 81       	ldd	r25, Y+6	; 0x06
    46f8:	01 97       	sbiw	r24, 0x01	; 1
    46fa:	9e 83       	std	Y+6, r25	; 0x06
    46fc:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    46fe:	8d 81       	ldd	r24, Y+5	; 0x05
    4700:	9e 81       	ldd	r25, Y+6	; 0x06
    4702:	00 97       	sbiw	r24, 0x00	; 0
    4704:	69 f7       	brne	.-38     	; 0x46e0 <LCD_clear_display+0x198>
    4706:	14 c0       	rjmp	.+40     	; 0x4730 <LCD_clear_display+0x1e8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4708:	6f 81       	ldd	r22, Y+7	; 0x07
    470a:	78 85       	ldd	r23, Y+8	; 0x08
    470c:	89 85       	ldd	r24, Y+9	; 0x09
    470e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4710:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4714:	dc 01       	movw	r26, r24
    4716:	cb 01       	movw	r24, r22
    4718:	9e 83       	std	Y+6, r25	; 0x06
    471a:	8d 83       	std	Y+5, r24	; 0x05
    471c:	8d 81       	ldd	r24, Y+5	; 0x05
    471e:	9e 81       	ldd	r25, Y+6	; 0x06
    4720:	9a 83       	std	Y+2, r25	; 0x02
    4722:	89 83       	std	Y+1, r24	; 0x01
    4724:	89 81       	ldd	r24, Y+1	; 0x01
    4726:	9a 81       	ldd	r25, Y+2	; 0x02
    4728:	01 97       	sbiw	r24, 0x01	; 1
    472a:	f1 f7       	brne	.-4      	; 0x4728 <LCD_clear_display+0x1e0>
    472c:	9a 83       	std	Y+2, r25	; 0x02
    472e:	89 83       	std	Y+1, r24	; 0x01
	// wait more han 1.53 ms
	_delay_ms(2);
#endif


}
    4730:	6c 96       	adiw	r28, 0x1c	; 28
    4732:	0f b6       	in	r0, 0x3f	; 63
    4734:	f8 94       	cli
    4736:	de bf       	out	0x3e, r29	; 62
    4738:	0f be       	out	0x3f, r0	; 63
    473a:	cd bf       	out	0x3d, r28	; 61
    473c:	cf 91       	pop	r28
    473e:	df 91       	pop	r29
    4740:	08 95       	ret

00004742 <LCD_write_char>:

void LCD_write_char(u8 copy_u8_char){
    4742:	df 93       	push	r29
    4744:	cf 93       	push	r28
    4746:	cd b7       	in	r28, 0x3d	; 61
    4748:	de b7       	in	r29, 0x3e	; 62
    474a:	69 97       	sbiw	r28, 0x19	; 25
    474c:	0f b6       	in	r0, 0x3f	; 63
    474e:	f8 94       	cli
    4750:	de bf       	out	0x3e, r29	; 62
    4752:	0f be       	out	0x3f, r0	; 63
    4754:	cd bf       	out	0x3d, r28	; 61
    4756:	89 8f       	std	Y+25, r24	; 0x19
	LCD_write_data_8bit(copy_u8_char);
	// wait more than 39 us
	_delay_us(50);
#elif LCD_interface_mode == interface_4bit
	// send character
	LCD_write_data_4bit(copy_u8_char);
    4758:	89 8d       	ldd	r24, Y+25	; 0x19
    475a:	0e 94 3b 0d 	call	0x1a76	; 0x1a76 <LCD_write_data_4bit>
    475e:	80 e0       	ldi	r24, 0x00	; 0
    4760:	90 e0       	ldi	r25, 0x00	; 0
    4762:	a8 e4       	ldi	r26, 0x48	; 72
    4764:	b2 e4       	ldi	r27, 0x42	; 66
    4766:	8d 8b       	std	Y+21, r24	; 0x15
    4768:	9e 8b       	std	Y+22, r25	; 0x16
    476a:	af 8b       	std	Y+23, r26	; 0x17
    476c:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    476e:	6d 89       	ldd	r22, Y+21	; 0x15
    4770:	7e 89       	ldd	r23, Y+22	; 0x16
    4772:	8f 89       	ldd	r24, Y+23	; 0x17
    4774:	98 8d       	ldd	r25, Y+24	; 0x18
    4776:	2b ea       	ldi	r18, 0xAB	; 171
    4778:	3a ea       	ldi	r19, 0xAA	; 170
    477a:	4a e2       	ldi	r20, 0x2A	; 42
    477c:	50 e4       	ldi	r21, 0x40	; 64
    477e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4782:	dc 01       	movw	r26, r24
    4784:	cb 01       	movw	r24, r22
    4786:	89 8b       	std	Y+17, r24	; 0x11
    4788:	9a 8b       	std	Y+18, r25	; 0x12
    478a:	ab 8b       	std	Y+19, r26	; 0x13
    478c:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    478e:	69 89       	ldd	r22, Y+17	; 0x11
    4790:	7a 89       	ldd	r23, Y+18	; 0x12
    4792:	8b 89       	ldd	r24, Y+19	; 0x13
    4794:	9c 89       	ldd	r25, Y+20	; 0x14
    4796:	20 e0       	ldi	r18, 0x00	; 0
    4798:	30 e0       	ldi	r19, 0x00	; 0
    479a:	40 e8       	ldi	r20, 0x80	; 128
    479c:	5f e3       	ldi	r21, 0x3F	; 63
    479e:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    47a2:	88 23       	and	r24, r24
    47a4:	1c f4       	brge	.+6      	; 0x47ac <LCD_write_char+0x6a>
		__ticks = 1;
    47a6:	81 e0       	ldi	r24, 0x01	; 1
    47a8:	88 8b       	std	Y+16, r24	; 0x10
    47aa:	91 c0       	rjmp	.+290    	; 0x48ce <LCD_write_char+0x18c>
	else if (__tmp > 255)
    47ac:	69 89       	ldd	r22, Y+17	; 0x11
    47ae:	7a 89       	ldd	r23, Y+18	; 0x12
    47b0:	8b 89       	ldd	r24, Y+19	; 0x13
    47b2:	9c 89       	ldd	r25, Y+20	; 0x14
    47b4:	20 e0       	ldi	r18, 0x00	; 0
    47b6:	30 e0       	ldi	r19, 0x00	; 0
    47b8:	4f e7       	ldi	r20, 0x7F	; 127
    47ba:	53 e4       	ldi	r21, 0x43	; 67
    47bc:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    47c0:	18 16       	cp	r1, r24
    47c2:	0c f0       	brlt	.+2      	; 0x47c6 <LCD_write_char+0x84>
    47c4:	7b c0       	rjmp	.+246    	; 0x48bc <LCD_write_char+0x17a>
	{
		_delay_ms(__us / 1000.0);
    47c6:	6d 89       	ldd	r22, Y+21	; 0x15
    47c8:	7e 89       	ldd	r23, Y+22	; 0x16
    47ca:	8f 89       	ldd	r24, Y+23	; 0x17
    47cc:	98 8d       	ldd	r25, Y+24	; 0x18
    47ce:	20 e0       	ldi	r18, 0x00	; 0
    47d0:	30 e0       	ldi	r19, 0x00	; 0
    47d2:	4a e7       	ldi	r20, 0x7A	; 122
    47d4:	54 e4       	ldi	r21, 0x44	; 68
    47d6:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    47da:	dc 01       	movw	r26, r24
    47dc:	cb 01       	movw	r24, r22
    47de:	8c 87       	std	Y+12, r24	; 0x0c
    47e0:	9d 87       	std	Y+13, r25	; 0x0d
    47e2:	ae 87       	std	Y+14, r26	; 0x0e
    47e4:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    47e6:	6c 85       	ldd	r22, Y+12	; 0x0c
    47e8:	7d 85       	ldd	r23, Y+13	; 0x0d
    47ea:	8e 85       	ldd	r24, Y+14	; 0x0e
    47ec:	9f 85       	ldd	r25, Y+15	; 0x0f
    47ee:	20 e0       	ldi	r18, 0x00	; 0
    47f0:	30 e0       	ldi	r19, 0x00	; 0
    47f2:	4a ef       	ldi	r20, 0xFA	; 250
    47f4:	54 e4       	ldi	r21, 0x44	; 68
    47f6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    47fa:	dc 01       	movw	r26, r24
    47fc:	cb 01       	movw	r24, r22
    47fe:	88 87       	std	Y+8, r24	; 0x08
    4800:	99 87       	std	Y+9, r25	; 0x09
    4802:	aa 87       	std	Y+10, r26	; 0x0a
    4804:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    4806:	68 85       	ldd	r22, Y+8	; 0x08
    4808:	79 85       	ldd	r23, Y+9	; 0x09
    480a:	8a 85       	ldd	r24, Y+10	; 0x0a
    480c:	9b 85       	ldd	r25, Y+11	; 0x0b
    480e:	20 e0       	ldi	r18, 0x00	; 0
    4810:	30 e0       	ldi	r19, 0x00	; 0
    4812:	40 e8       	ldi	r20, 0x80	; 128
    4814:	5f e3       	ldi	r21, 0x3F	; 63
    4816:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    481a:	88 23       	and	r24, r24
    481c:	2c f4       	brge	.+10     	; 0x4828 <LCD_write_char+0xe6>
		__ticks = 1;
    481e:	81 e0       	ldi	r24, 0x01	; 1
    4820:	90 e0       	ldi	r25, 0x00	; 0
    4822:	9f 83       	std	Y+7, r25	; 0x07
    4824:	8e 83       	std	Y+6, r24	; 0x06
    4826:	3f c0       	rjmp	.+126    	; 0x48a6 <LCD_write_char+0x164>
	else if (__tmp > 65535)
    4828:	68 85       	ldd	r22, Y+8	; 0x08
    482a:	79 85       	ldd	r23, Y+9	; 0x09
    482c:	8a 85       	ldd	r24, Y+10	; 0x0a
    482e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4830:	20 e0       	ldi	r18, 0x00	; 0
    4832:	3f ef       	ldi	r19, 0xFF	; 255
    4834:	4f e7       	ldi	r20, 0x7F	; 127
    4836:	57 e4       	ldi	r21, 0x47	; 71
    4838:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    483c:	18 16       	cp	r1, r24
    483e:	4c f5       	brge	.+82     	; 0x4892 <LCD_write_char+0x150>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4840:	6c 85       	ldd	r22, Y+12	; 0x0c
    4842:	7d 85       	ldd	r23, Y+13	; 0x0d
    4844:	8e 85       	ldd	r24, Y+14	; 0x0e
    4846:	9f 85       	ldd	r25, Y+15	; 0x0f
    4848:	20 e0       	ldi	r18, 0x00	; 0
    484a:	30 e0       	ldi	r19, 0x00	; 0
    484c:	40 e2       	ldi	r20, 0x20	; 32
    484e:	51 e4       	ldi	r21, 0x41	; 65
    4850:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4854:	dc 01       	movw	r26, r24
    4856:	cb 01       	movw	r24, r22
    4858:	bc 01       	movw	r22, r24
    485a:	cd 01       	movw	r24, r26
    485c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4860:	dc 01       	movw	r26, r24
    4862:	cb 01       	movw	r24, r22
    4864:	9f 83       	std	Y+7, r25	; 0x07
    4866:	8e 83       	std	Y+6, r24	; 0x06
    4868:	0f c0       	rjmp	.+30     	; 0x4888 <LCD_write_char+0x146>
    486a:	88 ec       	ldi	r24, 0xC8	; 200
    486c:	90 e0       	ldi	r25, 0x00	; 0
    486e:	9d 83       	std	Y+5, r25	; 0x05
    4870:	8c 83       	std	Y+4, r24	; 0x04
    4872:	8c 81       	ldd	r24, Y+4	; 0x04
    4874:	9d 81       	ldd	r25, Y+5	; 0x05
    4876:	01 97       	sbiw	r24, 0x01	; 1
    4878:	f1 f7       	brne	.-4      	; 0x4876 <LCD_write_char+0x134>
    487a:	9d 83       	std	Y+5, r25	; 0x05
    487c:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    487e:	8e 81       	ldd	r24, Y+6	; 0x06
    4880:	9f 81       	ldd	r25, Y+7	; 0x07
    4882:	01 97       	sbiw	r24, 0x01	; 1
    4884:	9f 83       	std	Y+7, r25	; 0x07
    4886:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4888:	8e 81       	ldd	r24, Y+6	; 0x06
    488a:	9f 81       	ldd	r25, Y+7	; 0x07
    488c:	00 97       	sbiw	r24, 0x00	; 0
    488e:	69 f7       	brne	.-38     	; 0x486a <LCD_write_char+0x128>
    4890:	24 c0       	rjmp	.+72     	; 0x48da <LCD_write_char+0x198>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4892:	68 85       	ldd	r22, Y+8	; 0x08
    4894:	79 85       	ldd	r23, Y+9	; 0x09
    4896:	8a 85       	ldd	r24, Y+10	; 0x0a
    4898:	9b 85       	ldd	r25, Y+11	; 0x0b
    489a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    489e:	dc 01       	movw	r26, r24
    48a0:	cb 01       	movw	r24, r22
    48a2:	9f 83       	std	Y+7, r25	; 0x07
    48a4:	8e 83       	std	Y+6, r24	; 0x06
    48a6:	8e 81       	ldd	r24, Y+6	; 0x06
    48a8:	9f 81       	ldd	r25, Y+7	; 0x07
    48aa:	9b 83       	std	Y+3, r25	; 0x03
    48ac:	8a 83       	std	Y+2, r24	; 0x02
    48ae:	8a 81       	ldd	r24, Y+2	; 0x02
    48b0:	9b 81       	ldd	r25, Y+3	; 0x03
    48b2:	01 97       	sbiw	r24, 0x01	; 1
    48b4:	f1 f7       	brne	.-4      	; 0x48b2 <LCD_write_char+0x170>
    48b6:	9b 83       	std	Y+3, r25	; 0x03
    48b8:	8a 83       	std	Y+2, r24	; 0x02
    48ba:	0f c0       	rjmp	.+30     	; 0x48da <LCD_write_char+0x198>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    48bc:	69 89       	ldd	r22, Y+17	; 0x11
    48be:	7a 89       	ldd	r23, Y+18	; 0x12
    48c0:	8b 89       	ldd	r24, Y+19	; 0x13
    48c2:	9c 89       	ldd	r25, Y+20	; 0x14
    48c4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    48c8:	dc 01       	movw	r26, r24
    48ca:	cb 01       	movw	r24, r22
    48cc:	88 8b       	std	Y+16, r24	; 0x10
    48ce:	88 89       	ldd	r24, Y+16	; 0x10
    48d0:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    48d2:	89 81       	ldd	r24, Y+1	; 0x01
    48d4:	8a 95       	dec	r24
    48d6:	f1 f7       	brne	.-4      	; 0x48d4 <LCD_write_char+0x192>
    48d8:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(50);
#endif

}
    48da:	69 96       	adiw	r28, 0x19	; 25
    48dc:	0f b6       	in	r0, 0x3f	; 63
    48de:	f8 94       	cli
    48e0:	de bf       	out	0x3e, r29	; 62
    48e2:	0f be       	out	0x3f, r0	; 63
    48e4:	cd bf       	out	0x3d, r28	; 61
    48e6:	cf 91       	pop	r28
    48e8:	df 91       	pop	r29
    48ea:	08 95       	ret

000048ec <LCD_write_string>:


void LCD_write_string(u8* Copy_pu8_str){
    48ec:	df 93       	push	r29
    48ee:	cf 93       	push	r28
    48f0:	00 d0       	rcall	.+0      	; 0x48f2 <LCD_write_string+0x6>
    48f2:	0f 92       	push	r0
    48f4:	cd b7       	in	r28, 0x3d	; 61
    48f6:	de b7       	in	r29, 0x3e	; 62
    48f8:	9b 83       	std	Y+3, r25	; 0x03
    48fa:	8a 83       	std	Y+2, r24	; 0x02
	 * this function takes a pointer to a string u8
	 * and send it to the lcd to write on it the desired string
	 *
	 */

	u8 i = 0;
    48fc:	19 82       	std	Y+1, r1	; 0x01
    48fe:	0e c0       	rjmp	.+28     	; 0x491c <LCD_write_string+0x30>

	while(Copy_pu8_str[i] != '\0'){

		LCD_write_char(Copy_pu8_str[i]);
    4900:	89 81       	ldd	r24, Y+1	; 0x01
    4902:	28 2f       	mov	r18, r24
    4904:	30 e0       	ldi	r19, 0x00	; 0
    4906:	8a 81       	ldd	r24, Y+2	; 0x02
    4908:	9b 81       	ldd	r25, Y+3	; 0x03
    490a:	fc 01       	movw	r30, r24
    490c:	e2 0f       	add	r30, r18
    490e:	f3 1f       	adc	r31, r19
    4910:	80 81       	ld	r24, Z
    4912:	0e 94 a1 23 	call	0x4742	; 0x4742 <LCD_write_char>
		i++;
    4916:	89 81       	ldd	r24, Y+1	; 0x01
    4918:	8f 5f       	subi	r24, 0xFF	; 255
    491a:	89 83       	std	Y+1, r24	; 0x01
	 *
	 */

	u8 i = 0;

	while(Copy_pu8_str[i] != '\0'){
    491c:	89 81       	ldd	r24, Y+1	; 0x01
    491e:	28 2f       	mov	r18, r24
    4920:	30 e0       	ldi	r19, 0x00	; 0
    4922:	8a 81       	ldd	r24, Y+2	; 0x02
    4924:	9b 81       	ldd	r25, Y+3	; 0x03
    4926:	fc 01       	movw	r30, r24
    4928:	e2 0f       	add	r30, r18
    492a:	f3 1f       	adc	r31, r19
    492c:	80 81       	ld	r24, Z
    492e:	88 23       	and	r24, r24
    4930:	39 f7       	brne	.-50     	; 0x4900 <LCD_write_string+0x14>

		LCD_write_char(Copy_pu8_str[i]);
		i++;
	}

}
    4932:	0f 90       	pop	r0
    4934:	0f 90       	pop	r0
    4936:	0f 90       	pop	r0
    4938:	cf 91       	pop	r28
    493a:	df 91       	pop	r29
    493c:	08 95       	ret

0000493e <LCD_write_number>:


void LCD_write_number(s32 copy_s32_number){
    493e:	0f 93       	push	r16
    4940:	1f 93       	push	r17
    4942:	df 93       	push	r29
    4944:	cf 93       	push	r28
    4946:	cd b7       	in	r28, 0x3d	; 61
    4948:	de b7       	in	r29, 0x3e	; 62
    494a:	60 97       	sbiw	r28, 0x10	; 16
    494c:	0f b6       	in	r0, 0x3f	; 63
    494e:	f8 94       	cli
    4950:	de bf       	out	0x3e, r29	; 62
    4952:	0f be       	out	0x3f, r0	; 63
    4954:	cd bf       	out	0x3d, r28	; 61
    4956:	6d 87       	std	Y+13, r22	; 0x0d
    4958:	7e 87       	std	Y+14, r23	; 0x0e
    495a:	8f 87       	std	Y+15, r24	; 0x0f
    495c:	98 8b       	std	Y+16, r25	; 0x10
	 *
	 *
	 */
	// if number is 0

	if(copy_s32_number == 0){
    495e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4960:	9e 85       	ldd	r25, Y+14	; 0x0e
    4962:	af 85       	ldd	r26, Y+15	; 0x0f
    4964:	b8 89       	ldd	r27, Y+16	; 0x10
    4966:	00 97       	sbiw	r24, 0x00	; 0
    4968:	a1 05       	cpc	r26, r1
    496a:	b1 05       	cpc	r27, r1
    496c:	21 f4       	brne	.+8      	; 0x4976 <LCD_write_number+0x38>

		LCD_write_char('0');
    496e:	80 e3       	ldi	r24, 0x30	; 48
    4970:	0e 94 a1 23 	call	0x4742	; 0x4742 <LCD_write_char>
    4974:	18 c0       	rjmp	.+48     	; 0x49a6 <LCD_write_number+0x68>
		//negative number
	}else if(copy_s32_number < 0){
    4976:	8d 85       	ldd	r24, Y+13	; 0x0d
    4978:	9e 85       	ldd	r25, Y+14	; 0x0e
    497a:	af 85       	ldd	r26, Y+15	; 0x0f
    497c:	b8 89       	ldd	r27, Y+16	; 0x10
    497e:	bb 23       	and	r27, r27
    4980:	94 f4       	brge	.+36     	; 0x49a6 <LCD_write_number+0x68>

		LCD_write_char('-');
    4982:	8d e2       	ldi	r24, 0x2D	; 45
    4984:	0e 94 a1 23 	call	0x4742	; 0x4742 <LCD_write_char>
		//convert the number to the absolute value
		copy_s32_number *= -1;
    4988:	8d 85       	ldd	r24, Y+13	; 0x0d
    498a:	9e 85       	ldd	r25, Y+14	; 0x0e
    498c:	af 85       	ldd	r26, Y+15	; 0x0f
    498e:	b8 89       	ldd	r27, Y+16	; 0x10
    4990:	b0 95       	com	r27
    4992:	a0 95       	com	r26
    4994:	90 95       	com	r25
    4996:	81 95       	neg	r24
    4998:	9f 4f       	sbci	r25, 0xFF	; 255
    499a:	af 4f       	sbci	r26, 0xFF	; 255
    499c:	bf 4f       	sbci	r27, 0xFF	; 255
    499e:	8d 87       	std	Y+13, r24	; 0x0d
    49a0:	9e 87       	std	Y+14, r25	; 0x0e
    49a2:	af 87       	std	Y+15, r26	; 0x0f
    49a4:	b8 8b       	std	Y+16, r27	; 0x10

	}
	if(copy_s32_number > 0){
    49a6:	8d 85       	ldd	r24, Y+13	; 0x0d
    49a8:	9e 85       	ldd	r25, Y+14	; 0x0e
    49aa:	af 85       	ldd	r26, Y+15	; 0x0f
    49ac:	b8 89       	ldd	r27, Y+16	; 0x10
    49ae:	18 16       	cp	r1, r24
    49b0:	19 06       	cpc	r1, r25
    49b2:	1a 06       	cpc	r1, r26
    49b4:	1b 06       	cpc	r1, r27
    49b6:	0c f0       	brlt	.+2      	; 0x49ba <LCD_write_number+0x7c>
    49b8:	51 c0       	rjmp	.+162    	; 0x4a5c <LCD_write_number+0x11e>
	//container to store the number
	u8 numbers[10];
	u8 i = 0;
    49ba:	1a 82       	std	Y+2, r1	; 0x02
    49bc:	2d c0       	rjmp	.+90     	; 0x4a18 <LCD_write_number+0xda>

	while(copy_s32_number != 0){

		//retreive the last digit from the number
		numbers[i] = copy_s32_number%10;
    49be:	8a 81       	ldd	r24, Y+2	; 0x02
    49c0:	08 2f       	mov	r16, r24
    49c2:	10 e0       	ldi	r17, 0x00	; 0
    49c4:	8d 85       	ldd	r24, Y+13	; 0x0d
    49c6:	9e 85       	ldd	r25, Y+14	; 0x0e
    49c8:	af 85       	ldd	r26, Y+15	; 0x0f
    49ca:	b8 89       	ldd	r27, Y+16	; 0x10
    49cc:	2a e0       	ldi	r18, 0x0A	; 10
    49ce:	30 e0       	ldi	r19, 0x00	; 0
    49d0:	40 e0       	ldi	r20, 0x00	; 0
    49d2:	50 e0       	ldi	r21, 0x00	; 0
    49d4:	bc 01       	movw	r22, r24
    49d6:	cd 01       	movw	r24, r26
    49d8:	0e 94 22 3e 	call	0x7c44	; 0x7c44 <__divmodsi4>
    49dc:	dc 01       	movw	r26, r24
    49de:	cb 01       	movw	r24, r22
    49e0:	28 2f       	mov	r18, r24
    49e2:	ce 01       	movw	r24, r28
    49e4:	03 96       	adiw	r24, 0x03	; 3
    49e6:	fc 01       	movw	r30, r24
    49e8:	e0 0f       	add	r30, r16
    49ea:	f1 1f       	adc	r31, r17
    49ec:	20 83       	st	Z, r18
		copy_s32_number /= 10;
    49ee:	8d 85       	ldd	r24, Y+13	; 0x0d
    49f0:	9e 85       	ldd	r25, Y+14	; 0x0e
    49f2:	af 85       	ldd	r26, Y+15	; 0x0f
    49f4:	b8 89       	ldd	r27, Y+16	; 0x10
    49f6:	2a e0       	ldi	r18, 0x0A	; 10
    49f8:	30 e0       	ldi	r19, 0x00	; 0
    49fa:	40 e0       	ldi	r20, 0x00	; 0
    49fc:	50 e0       	ldi	r21, 0x00	; 0
    49fe:	bc 01       	movw	r22, r24
    4a00:	cd 01       	movw	r24, r26
    4a02:	0e 94 22 3e 	call	0x7c44	; 0x7c44 <__divmodsi4>
    4a06:	da 01       	movw	r26, r20
    4a08:	c9 01       	movw	r24, r18
    4a0a:	8d 87       	std	Y+13, r24	; 0x0d
    4a0c:	9e 87       	std	Y+14, r25	; 0x0e
    4a0e:	af 87       	std	Y+15, r26	; 0x0f
    4a10:	b8 8b       	std	Y+16, r27	; 0x10
		i++;
    4a12:	8a 81       	ldd	r24, Y+2	; 0x02
    4a14:	8f 5f       	subi	r24, 0xFF	; 255
    4a16:	8a 83       	std	Y+2, r24	; 0x02
	if(copy_s32_number > 0){
	//container to store the number
	u8 numbers[10];
	u8 i = 0;

	while(copy_s32_number != 0){
    4a18:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a1a:	9e 85       	ldd	r25, Y+14	; 0x0e
    4a1c:	af 85       	ldd	r26, Y+15	; 0x0f
    4a1e:	b8 89       	ldd	r27, Y+16	; 0x10
    4a20:	00 97       	sbiw	r24, 0x00	; 0
    4a22:	a1 05       	cpc	r26, r1
    4a24:	b1 05       	cpc	r27, r1
    4a26:	59 f6       	brne	.-106    	; 0x49be <LCD_write_number+0x80>
		copy_s32_number /= 10;
		i++;
	}

	// reverse array order
	array_Swap(numbers, i);
    4a28:	ce 01       	movw	r24, r28
    4a2a:	03 96       	adiw	r24, 0x03	; 3
    4a2c:	6a 81       	ldd	r22, Y+2	; 0x02
    4a2e:	0e 94 78 09 	call	0x12f0	; 0x12f0 <array_Swap>

	// print the correct order of the number
	for(u8 j = 0; j < i; j++){
    4a32:	19 82       	std	Y+1, r1	; 0x01
    4a34:	0f c0       	rjmp	.+30     	; 0x4a54 <LCD_write_number+0x116>

		LCD_write_char(numbers[j]+'0');
    4a36:	89 81       	ldd	r24, Y+1	; 0x01
    4a38:	28 2f       	mov	r18, r24
    4a3a:	30 e0       	ldi	r19, 0x00	; 0
    4a3c:	ce 01       	movw	r24, r28
    4a3e:	03 96       	adiw	r24, 0x03	; 3
    4a40:	fc 01       	movw	r30, r24
    4a42:	e2 0f       	add	r30, r18
    4a44:	f3 1f       	adc	r31, r19
    4a46:	80 81       	ld	r24, Z
    4a48:	80 5d       	subi	r24, 0xD0	; 208
    4a4a:	0e 94 a1 23 	call	0x4742	; 0x4742 <LCD_write_char>

	// reverse array order
	array_Swap(numbers, i);

	// print the correct order of the number
	for(u8 j = 0; j < i; j++){
    4a4e:	89 81       	ldd	r24, Y+1	; 0x01
    4a50:	8f 5f       	subi	r24, 0xFF	; 255
    4a52:	89 83       	std	Y+1, r24	; 0x01
    4a54:	99 81       	ldd	r25, Y+1	; 0x01
    4a56:	8a 81       	ldd	r24, Y+2	; 0x02
    4a58:	98 17       	cp	r25, r24
    4a5a:	68 f3       	brcs	.-38     	; 0x4a36 <LCD_write_number+0xf8>

		LCD_write_char(numbers[j]+'0');
	}

	}
}
    4a5c:	60 96       	adiw	r28, 0x10	; 16
    4a5e:	0f b6       	in	r0, 0x3f	; 63
    4a60:	f8 94       	cli
    4a62:	de bf       	out	0x3e, r29	; 62
    4a64:	0f be       	out	0x3f, r0	; 63
    4a66:	cd bf       	out	0x3d, r28	; 61
    4a68:	cf 91       	pop	r28
    4a6a:	df 91       	pop	r29
    4a6c:	1f 91       	pop	r17
    4a6e:	0f 91       	pop	r16
    4a70:	08 95       	ret

00004a72 <LCD_write_float>:

void LCD_write_float(f32 copy_f32_number, u8 copy_decimal_point){
    4a72:	ef 92       	push	r14
    4a74:	ff 92       	push	r15
    4a76:	0f 93       	push	r16
    4a78:	1f 93       	push	r17
    4a7a:	df 93       	push	r29
    4a7c:	cf 93       	push	r28
    4a7e:	cd b7       	in	r28, 0x3d	; 61
    4a80:	de b7       	in	r29, 0x3e	; 62
    4a82:	2d 97       	sbiw	r28, 0x0d	; 13
    4a84:	0f b6       	in	r0, 0x3f	; 63
    4a86:	f8 94       	cli
    4a88:	de bf       	out	0x3e, r29	; 62
    4a8a:	0f be       	out	0x3f, r0	; 63
    4a8c:	cd bf       	out	0x3d, r28	; 61
    4a8e:	69 87       	std	Y+9, r22	; 0x09
    4a90:	7a 87       	std	Y+10, r23	; 0x0a
    4a92:	8b 87       	std	Y+11, r24	; 0x0b
    4a94:	9c 87       	std	Y+12, r25	; 0x0c
    4a96:	4d 87       	std	Y+13, r20	; 0x0d
	 * the function doesn't return anything
	 *
	 */

	// store the integer part
	s32 int_value = (s32)copy_f32_number;
    4a98:	69 85       	ldd	r22, Y+9	; 0x09
    4a9a:	7a 85       	ldd	r23, Y+10	; 0x0a
    4a9c:	8b 85       	ldd	r24, Y+11	; 0x0b
    4a9e:	9c 85       	ldd	r25, Y+12	; 0x0c
    4aa0:	0e 94 b3 04 	call	0x966	; 0x966 <__fixsfsi>
    4aa4:	dc 01       	movw	r26, r24
    4aa6:	cb 01       	movw	r24, r22
    4aa8:	8d 83       	std	Y+5, r24	; 0x05
    4aaa:	9e 83       	std	Y+6, r25	; 0x06
    4aac:	af 83       	std	Y+7, r26	; 0x07
    4aae:	b8 87       	std	Y+8, r27	; 0x08

	// store the decimal part
	s32 float_value = (s32)((copy_f32_number -(f32)int_value)*power_10(copy_decimal_point));
    4ab0:	6d 81       	ldd	r22, Y+5	; 0x05
    4ab2:	7e 81       	ldd	r23, Y+6	; 0x06
    4ab4:	8f 81       	ldd	r24, Y+7	; 0x07
    4ab6:	98 85       	ldd	r25, Y+8	; 0x08
    4ab8:	0e 94 55 04 	call	0x8aa	; 0x8aa <__floatsisf>
    4abc:	9b 01       	movw	r18, r22
    4abe:	ac 01       	movw	r20, r24
    4ac0:	69 85       	ldd	r22, Y+9	; 0x09
    4ac2:	7a 85       	ldd	r23, Y+10	; 0x0a
    4ac4:	8b 85       	ldd	r24, Y+11	; 0x0b
    4ac6:	9c 85       	ldd	r25, Y+12	; 0x0c
    4ac8:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    4acc:	dc 01       	movw	r26, r24
    4ace:	cb 01       	movw	r24, r22
    4ad0:	7c 01       	movw	r14, r24
    4ad2:	8d 01       	movw	r16, r26
    4ad4:	8d 85       	ldd	r24, Y+13	; 0x0d
    4ad6:	0e 94 c0 09 	call	0x1380	; 0x1380 <power_10>
    4ada:	dc 01       	movw	r26, r24
    4adc:	cb 01       	movw	r24, r22
    4ade:	bc 01       	movw	r22, r24
    4ae0:	cd 01       	movw	r24, r26
    4ae2:	0e 94 55 04 	call	0x8aa	; 0x8aa <__floatsisf>
    4ae6:	9b 01       	movw	r18, r22
    4ae8:	ac 01       	movw	r20, r24
    4aea:	c8 01       	movw	r24, r16
    4aec:	b7 01       	movw	r22, r14
    4aee:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4af2:	dc 01       	movw	r26, r24
    4af4:	cb 01       	movw	r24, r22
    4af6:	bc 01       	movw	r22, r24
    4af8:	cd 01       	movw	r24, r26
    4afa:	0e 94 b3 04 	call	0x966	; 0x966 <__fixsfsi>
    4afe:	dc 01       	movw	r26, r24
    4b00:	cb 01       	movw	r24, r22
    4b02:	89 83       	std	Y+1, r24	; 0x01
    4b04:	9a 83       	std	Y+2, r25	; 0x02
    4b06:	ab 83       	std	Y+3, r26	; 0x03
    4b08:	bc 83       	std	Y+4, r27	; 0x04

	// print the int part
	LCD_write_number(int_value);
    4b0a:	8d 81       	ldd	r24, Y+5	; 0x05
    4b0c:	9e 81       	ldd	r25, Y+6	; 0x06
    4b0e:	af 81       	ldd	r26, Y+7	; 0x07
    4b10:	b8 85       	ldd	r27, Y+8	; 0x08
    4b12:	bc 01       	movw	r22, r24
    4b14:	cd 01       	movw	r24, r26
    4b16:	0e 94 9f 24 	call	0x493e	; 0x493e <LCD_write_number>
	//print the floating point
	LCD_write_char('.');
    4b1a:	8e e2       	ldi	r24, 0x2E	; 46
    4b1c:	0e 94 a1 23 	call	0x4742	; 0x4742 <LCD_write_char>
	//print the decimal part
	if(float_value > 0 ){
    4b20:	89 81       	ldd	r24, Y+1	; 0x01
    4b22:	9a 81       	ldd	r25, Y+2	; 0x02
    4b24:	ab 81       	ldd	r26, Y+3	; 0x03
    4b26:	bc 81       	ldd	r27, Y+4	; 0x04
    4b28:	18 16       	cp	r1, r24
    4b2a:	19 06       	cpc	r1, r25
    4b2c:	1a 06       	cpc	r1, r26
    4b2e:	1b 06       	cpc	r1, r27
    4b30:	4c f4       	brge	.+18     	; 0x4b44 <LCD_write_float+0xd2>
	LCD_write_number(float_value);
    4b32:	89 81       	ldd	r24, Y+1	; 0x01
    4b34:	9a 81       	ldd	r25, Y+2	; 0x02
    4b36:	ab 81       	ldd	r26, Y+3	; 0x03
    4b38:	bc 81       	ldd	r27, Y+4	; 0x04
    4b3a:	bc 01       	movw	r22, r24
    4b3c:	cd 01       	movw	r24, r26
    4b3e:	0e 94 9f 24 	call	0x493e	; 0x493e <LCD_write_number>
    4b42:	0f c0       	rjmp	.+30     	; 0x4b62 <LCD_write_float+0xf0>
	}else{
	LCD_write_number((float_value * -1));
    4b44:	89 81       	ldd	r24, Y+1	; 0x01
    4b46:	9a 81       	ldd	r25, Y+2	; 0x02
    4b48:	ab 81       	ldd	r26, Y+3	; 0x03
    4b4a:	bc 81       	ldd	r27, Y+4	; 0x04
    4b4c:	b0 95       	com	r27
    4b4e:	a0 95       	com	r26
    4b50:	90 95       	com	r25
    4b52:	81 95       	neg	r24
    4b54:	9f 4f       	sbci	r25, 0xFF	; 255
    4b56:	af 4f       	sbci	r26, 0xFF	; 255
    4b58:	bf 4f       	sbci	r27, 0xFF	; 255
    4b5a:	bc 01       	movw	r22, r24
    4b5c:	cd 01       	movw	r24, r26
    4b5e:	0e 94 9f 24 	call	0x493e	; 0x493e <LCD_write_number>

	}


}
    4b62:	2d 96       	adiw	r28, 0x0d	; 13
    4b64:	0f b6       	in	r0, 0x3f	; 63
    4b66:	f8 94       	cli
    4b68:	de bf       	out	0x3e, r29	; 62
    4b6a:	0f be       	out	0x3f, r0	; 63
    4b6c:	cd bf       	out	0x3d, r28	; 61
    4b6e:	cf 91       	pop	r28
    4b70:	df 91       	pop	r29
    4b72:	1f 91       	pop	r17
    4b74:	0f 91       	pop	r16
    4b76:	ff 90       	pop	r15
    4b78:	ef 90       	pop	r14
    4b7a:	08 95       	ret

00004b7c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    4b7c:	df 93       	push	r29
    4b7e:	cf 93       	push	r28
    4b80:	00 d0       	rcall	.+0      	; 0x4b82 <pvPortMalloc+0x6>
    4b82:	00 d0       	rcall	.+0      	; 0x4b84 <pvPortMalloc+0x8>
    4b84:	cd b7       	in	r28, 0x3d	; 61
    4b86:	de b7       	in	r29, 0x3e	; 62
    4b88:	9c 83       	std	Y+4, r25	; 0x04
    4b8a:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    4b8c:	1a 82       	std	Y+2, r1	; 0x02
    4b8e:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    4b90:	0e 94 0b 35 	call	0x6a16	; 0x6a16 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    4b94:	80 91 92 01 	lds	r24, 0x0192
    4b98:	90 91 93 01 	lds	r25, 0x0193
    4b9c:	00 97       	sbiw	r24, 0x00	; 0
    4b9e:	31 f4       	brne	.+12     	; 0x4bac <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    4ba0:	85 e9       	ldi	r24, 0x95	; 149
    4ba2:	91 e0       	ldi	r25, 0x01	; 1
    4ba4:	90 93 93 01 	sts	0x0193, r25
    4ba8:	80 93 92 01 	sts	0x0192, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    4bac:	80 91 90 01 	lds	r24, 0x0190
    4bb0:	90 91 91 01 	lds	r25, 0x0191
    4bb4:	2b 81       	ldd	r18, Y+3	; 0x03
    4bb6:	3c 81       	ldd	r19, Y+4	; 0x04
    4bb8:	82 0f       	add	r24, r18
    4bba:	93 1f       	adc	r25, r19
    4bbc:	23 e0       	ldi	r18, 0x03	; 3
    4bbe:	8f 3f       	cpi	r24, 0xFF	; 255
    4bc0:	92 07       	cpc	r25, r18
    4bc2:	38 f5       	brcc	.+78     	; 0x4c12 <pvPortMalloc+0x96>
    4bc4:	20 91 90 01 	lds	r18, 0x0190
    4bc8:	30 91 91 01 	lds	r19, 0x0191
    4bcc:	8b 81       	ldd	r24, Y+3	; 0x03
    4bce:	9c 81       	ldd	r25, Y+4	; 0x04
    4bd0:	28 0f       	add	r18, r24
    4bd2:	39 1f       	adc	r19, r25
    4bd4:	80 91 90 01 	lds	r24, 0x0190
    4bd8:	90 91 91 01 	lds	r25, 0x0191
    4bdc:	82 17       	cp	r24, r18
    4bde:	93 07       	cpc	r25, r19
    4be0:	c0 f4       	brcc	.+48     	; 0x4c12 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    4be2:	20 91 92 01 	lds	r18, 0x0192
    4be6:	30 91 93 01 	lds	r19, 0x0193
    4bea:	80 91 90 01 	lds	r24, 0x0190
    4bee:	90 91 91 01 	lds	r25, 0x0191
    4bf2:	82 0f       	add	r24, r18
    4bf4:	93 1f       	adc	r25, r19
    4bf6:	9a 83       	std	Y+2, r25	; 0x02
    4bf8:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    4bfa:	20 91 90 01 	lds	r18, 0x0190
    4bfe:	30 91 91 01 	lds	r19, 0x0191
    4c02:	8b 81       	ldd	r24, Y+3	; 0x03
    4c04:	9c 81       	ldd	r25, Y+4	; 0x04
    4c06:	82 0f       	add	r24, r18
    4c08:	93 1f       	adc	r25, r19
    4c0a:	90 93 91 01 	sts	0x0191, r25
    4c0e:	80 93 90 01 	sts	0x0190, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    4c12:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    4c16:	89 81       	ldd	r24, Y+1	; 0x01
    4c18:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4c1a:	0f 90       	pop	r0
    4c1c:	0f 90       	pop	r0
    4c1e:	0f 90       	pop	r0
    4c20:	0f 90       	pop	r0
    4c22:	cf 91       	pop	r28
    4c24:	df 91       	pop	r29
    4c26:	08 95       	ret

00004c28 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    4c28:	df 93       	push	r29
    4c2a:	cf 93       	push	r28
    4c2c:	00 d0       	rcall	.+0      	; 0x4c2e <vPortFree+0x6>
    4c2e:	cd b7       	in	r28, 0x3d	; 61
    4c30:	de b7       	in	r29, 0x3e	; 62
    4c32:	9a 83       	std	Y+2, r25	; 0x02
    4c34:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    4c36:	0f 90       	pop	r0
    4c38:	0f 90       	pop	r0
    4c3a:	cf 91       	pop	r28
    4c3c:	df 91       	pop	r29
    4c3e:	08 95       	ret

00004c40 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    4c40:	df 93       	push	r29
    4c42:	cf 93       	push	r28
    4c44:	cd b7       	in	r28, 0x3d	; 61
    4c46:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    4c48:	10 92 91 01 	sts	0x0191, r1
    4c4c:	10 92 90 01 	sts	0x0190, r1
}
    4c50:	cf 91       	pop	r28
    4c52:	df 91       	pop	r29
    4c54:	08 95       	ret

00004c56 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    4c56:	df 93       	push	r29
    4c58:	cf 93       	push	r28
    4c5a:	cd b7       	in	r28, 0x3d	; 61
    4c5c:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    4c5e:	20 91 90 01 	lds	r18, 0x0190
    4c62:	30 91 91 01 	lds	r19, 0x0191
    4c66:	8f ef       	ldi	r24, 0xFF	; 255
    4c68:	93 e0       	ldi	r25, 0x03	; 3
    4c6a:	82 1b       	sub	r24, r18
    4c6c:	93 0b       	sbc	r25, r19
}
    4c6e:	cf 91       	pop	r28
    4c70:	df 91       	pop	r29
    4c72:	08 95       	ret

00004c74 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    4c74:	df 93       	push	r29
    4c76:	cf 93       	push	r28
    4c78:	00 d0       	rcall	.+0      	; 0x4c7a <vListInitialise+0x6>
    4c7a:	cd b7       	in	r28, 0x3d	; 61
    4c7c:	de b7       	in	r29, 0x3e	; 62
    4c7e:	9a 83       	std	Y+2, r25	; 0x02
    4c80:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    4c82:	89 81       	ldd	r24, Y+1	; 0x01
    4c84:	9a 81       	ldd	r25, Y+2	; 0x02
    4c86:	03 96       	adiw	r24, 0x03	; 3
    4c88:	e9 81       	ldd	r30, Y+1	; 0x01
    4c8a:	fa 81       	ldd	r31, Y+2	; 0x02
    4c8c:	92 83       	std	Z+2, r25	; 0x02
    4c8e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    4c90:	e9 81       	ldd	r30, Y+1	; 0x01
    4c92:	fa 81       	ldd	r31, Y+2	; 0x02
    4c94:	8f ef       	ldi	r24, 0xFF	; 255
    4c96:	9f ef       	ldi	r25, 0xFF	; 255
    4c98:	94 83       	std	Z+4, r25	; 0x04
    4c9a:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    4c9c:	89 81       	ldd	r24, Y+1	; 0x01
    4c9e:	9a 81       	ldd	r25, Y+2	; 0x02
    4ca0:	03 96       	adiw	r24, 0x03	; 3
    4ca2:	e9 81       	ldd	r30, Y+1	; 0x01
    4ca4:	fa 81       	ldd	r31, Y+2	; 0x02
    4ca6:	96 83       	std	Z+6, r25	; 0x06
    4ca8:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    4caa:	89 81       	ldd	r24, Y+1	; 0x01
    4cac:	9a 81       	ldd	r25, Y+2	; 0x02
    4cae:	03 96       	adiw	r24, 0x03	; 3
    4cb0:	e9 81       	ldd	r30, Y+1	; 0x01
    4cb2:	fa 81       	ldd	r31, Y+2	; 0x02
    4cb4:	90 87       	std	Z+8, r25	; 0x08
    4cb6:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    4cb8:	e9 81       	ldd	r30, Y+1	; 0x01
    4cba:	fa 81       	ldd	r31, Y+2	; 0x02
    4cbc:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    4cbe:	0f 90       	pop	r0
    4cc0:	0f 90       	pop	r0
    4cc2:	cf 91       	pop	r28
    4cc4:	df 91       	pop	r29
    4cc6:	08 95       	ret

00004cc8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    4cc8:	df 93       	push	r29
    4cca:	cf 93       	push	r28
    4ccc:	00 d0       	rcall	.+0      	; 0x4cce <vListInitialiseItem+0x6>
    4cce:	cd b7       	in	r28, 0x3d	; 61
    4cd0:	de b7       	in	r29, 0x3e	; 62
    4cd2:	9a 83       	std	Y+2, r25	; 0x02
    4cd4:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    4cd6:	e9 81       	ldd	r30, Y+1	; 0x01
    4cd8:	fa 81       	ldd	r31, Y+2	; 0x02
    4cda:	11 86       	std	Z+9, r1	; 0x09
    4cdc:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    4cde:	0f 90       	pop	r0
    4ce0:	0f 90       	pop	r0
    4ce2:	cf 91       	pop	r28
    4ce4:	df 91       	pop	r29
    4ce6:	08 95       	ret

00004ce8 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    4ce8:	df 93       	push	r29
    4cea:	cf 93       	push	r28
    4cec:	00 d0       	rcall	.+0      	; 0x4cee <vListInsertEnd+0x6>
    4cee:	00 d0       	rcall	.+0      	; 0x4cf0 <vListInsertEnd+0x8>
    4cf0:	00 d0       	rcall	.+0      	; 0x4cf2 <vListInsertEnd+0xa>
    4cf2:	cd b7       	in	r28, 0x3d	; 61
    4cf4:	de b7       	in	r29, 0x3e	; 62
    4cf6:	9c 83       	std	Y+4, r25	; 0x04
    4cf8:	8b 83       	std	Y+3, r24	; 0x03
    4cfa:	7e 83       	std	Y+6, r23	; 0x06
    4cfc:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    4cfe:	eb 81       	ldd	r30, Y+3	; 0x03
    4d00:	fc 81       	ldd	r31, Y+4	; 0x04
    4d02:	81 81       	ldd	r24, Z+1	; 0x01
    4d04:	92 81       	ldd	r25, Z+2	; 0x02
    4d06:	9a 83       	std	Y+2, r25	; 0x02
    4d08:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    4d0a:	ed 81       	ldd	r30, Y+5	; 0x05
    4d0c:	fe 81       	ldd	r31, Y+6	; 0x06
    4d0e:	89 81       	ldd	r24, Y+1	; 0x01
    4d10:	9a 81       	ldd	r25, Y+2	; 0x02
    4d12:	93 83       	std	Z+3, r25	; 0x03
    4d14:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    4d16:	e9 81       	ldd	r30, Y+1	; 0x01
    4d18:	fa 81       	ldd	r31, Y+2	; 0x02
    4d1a:	84 81       	ldd	r24, Z+4	; 0x04
    4d1c:	95 81       	ldd	r25, Z+5	; 0x05
    4d1e:	ed 81       	ldd	r30, Y+5	; 0x05
    4d20:	fe 81       	ldd	r31, Y+6	; 0x06
    4d22:	95 83       	std	Z+5, r25	; 0x05
    4d24:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    4d26:	e9 81       	ldd	r30, Y+1	; 0x01
    4d28:	fa 81       	ldd	r31, Y+2	; 0x02
    4d2a:	04 80       	ldd	r0, Z+4	; 0x04
    4d2c:	f5 81       	ldd	r31, Z+5	; 0x05
    4d2e:	e0 2d       	mov	r30, r0
    4d30:	8d 81       	ldd	r24, Y+5	; 0x05
    4d32:	9e 81       	ldd	r25, Y+6	; 0x06
    4d34:	93 83       	std	Z+3, r25	; 0x03
    4d36:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    4d38:	e9 81       	ldd	r30, Y+1	; 0x01
    4d3a:	fa 81       	ldd	r31, Y+2	; 0x02
    4d3c:	8d 81       	ldd	r24, Y+5	; 0x05
    4d3e:	9e 81       	ldd	r25, Y+6	; 0x06
    4d40:	95 83       	std	Z+5, r25	; 0x05
    4d42:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    4d44:	ed 81       	ldd	r30, Y+5	; 0x05
    4d46:	fe 81       	ldd	r31, Y+6	; 0x06
    4d48:	8b 81       	ldd	r24, Y+3	; 0x03
    4d4a:	9c 81       	ldd	r25, Y+4	; 0x04
    4d4c:	91 87       	std	Z+9, r25	; 0x09
    4d4e:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    4d50:	eb 81       	ldd	r30, Y+3	; 0x03
    4d52:	fc 81       	ldd	r31, Y+4	; 0x04
    4d54:	80 81       	ld	r24, Z
    4d56:	8f 5f       	subi	r24, 0xFF	; 255
    4d58:	eb 81       	ldd	r30, Y+3	; 0x03
    4d5a:	fc 81       	ldd	r31, Y+4	; 0x04
    4d5c:	80 83       	st	Z, r24
}
    4d5e:	26 96       	adiw	r28, 0x06	; 6
    4d60:	0f b6       	in	r0, 0x3f	; 63
    4d62:	f8 94       	cli
    4d64:	de bf       	out	0x3e, r29	; 62
    4d66:	0f be       	out	0x3f, r0	; 63
    4d68:	cd bf       	out	0x3d, r28	; 61
    4d6a:	cf 91       	pop	r28
    4d6c:	df 91       	pop	r29
    4d6e:	08 95       	ret

00004d70 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    4d70:	df 93       	push	r29
    4d72:	cf 93       	push	r28
    4d74:	cd b7       	in	r28, 0x3d	; 61
    4d76:	de b7       	in	r29, 0x3e	; 62
    4d78:	28 97       	sbiw	r28, 0x08	; 8
    4d7a:	0f b6       	in	r0, 0x3f	; 63
    4d7c:	f8 94       	cli
    4d7e:	de bf       	out	0x3e, r29	; 62
    4d80:	0f be       	out	0x3f, r0	; 63
    4d82:	cd bf       	out	0x3d, r28	; 61
    4d84:	9e 83       	std	Y+6, r25	; 0x06
    4d86:	8d 83       	std	Y+5, r24	; 0x05
    4d88:	78 87       	std	Y+8, r23	; 0x08
    4d8a:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    4d8c:	ef 81       	ldd	r30, Y+7	; 0x07
    4d8e:	f8 85       	ldd	r31, Y+8	; 0x08
    4d90:	80 81       	ld	r24, Z
    4d92:	91 81       	ldd	r25, Z+1	; 0x01
    4d94:	9a 83       	std	Y+2, r25	; 0x02
    4d96:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    4d98:	89 81       	ldd	r24, Y+1	; 0x01
    4d9a:	9a 81       	ldd	r25, Y+2	; 0x02
    4d9c:	2f ef       	ldi	r18, 0xFF	; 255
    4d9e:	8f 3f       	cpi	r24, 0xFF	; 255
    4da0:	92 07       	cpc	r25, r18
    4da2:	39 f4       	brne	.+14     	; 0x4db2 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    4da4:	ed 81       	ldd	r30, Y+5	; 0x05
    4da6:	fe 81       	ldd	r31, Y+6	; 0x06
    4da8:	87 81       	ldd	r24, Z+7	; 0x07
    4daa:	90 85       	ldd	r25, Z+8	; 0x08
    4dac:	9c 83       	std	Y+4, r25	; 0x04
    4dae:	8b 83       	std	Y+3, r24	; 0x03
    4db0:	18 c0       	rjmp	.+48     	; 0x4de2 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    4db2:	8d 81       	ldd	r24, Y+5	; 0x05
    4db4:	9e 81       	ldd	r25, Y+6	; 0x06
    4db6:	03 96       	adiw	r24, 0x03	; 3
    4db8:	9c 83       	std	Y+4, r25	; 0x04
    4dba:	8b 83       	std	Y+3, r24	; 0x03
    4dbc:	06 c0       	rjmp	.+12     	; 0x4dca <vListInsert+0x5a>
    4dbe:	eb 81       	ldd	r30, Y+3	; 0x03
    4dc0:	fc 81       	ldd	r31, Y+4	; 0x04
    4dc2:	82 81       	ldd	r24, Z+2	; 0x02
    4dc4:	93 81       	ldd	r25, Z+3	; 0x03
    4dc6:	9c 83       	std	Y+4, r25	; 0x04
    4dc8:	8b 83       	std	Y+3, r24	; 0x03
    4dca:	eb 81       	ldd	r30, Y+3	; 0x03
    4dcc:	fc 81       	ldd	r31, Y+4	; 0x04
    4dce:	02 80       	ldd	r0, Z+2	; 0x02
    4dd0:	f3 81       	ldd	r31, Z+3	; 0x03
    4dd2:	e0 2d       	mov	r30, r0
    4dd4:	20 81       	ld	r18, Z
    4dd6:	31 81       	ldd	r19, Z+1	; 0x01
    4dd8:	89 81       	ldd	r24, Y+1	; 0x01
    4dda:	9a 81       	ldd	r25, Y+2	; 0x02
    4ddc:	82 17       	cp	r24, r18
    4dde:	93 07       	cpc	r25, r19
    4de0:	70 f7       	brcc	.-36     	; 0x4dbe <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    4de2:	eb 81       	ldd	r30, Y+3	; 0x03
    4de4:	fc 81       	ldd	r31, Y+4	; 0x04
    4de6:	82 81       	ldd	r24, Z+2	; 0x02
    4de8:	93 81       	ldd	r25, Z+3	; 0x03
    4dea:	ef 81       	ldd	r30, Y+7	; 0x07
    4dec:	f8 85       	ldd	r31, Y+8	; 0x08
    4dee:	93 83       	std	Z+3, r25	; 0x03
    4df0:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    4df2:	ef 81       	ldd	r30, Y+7	; 0x07
    4df4:	f8 85       	ldd	r31, Y+8	; 0x08
    4df6:	02 80       	ldd	r0, Z+2	; 0x02
    4df8:	f3 81       	ldd	r31, Z+3	; 0x03
    4dfa:	e0 2d       	mov	r30, r0
    4dfc:	8f 81       	ldd	r24, Y+7	; 0x07
    4dfe:	98 85       	ldd	r25, Y+8	; 0x08
    4e00:	95 83       	std	Z+5, r25	; 0x05
    4e02:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    4e04:	ef 81       	ldd	r30, Y+7	; 0x07
    4e06:	f8 85       	ldd	r31, Y+8	; 0x08
    4e08:	8b 81       	ldd	r24, Y+3	; 0x03
    4e0a:	9c 81       	ldd	r25, Y+4	; 0x04
    4e0c:	95 83       	std	Z+5, r25	; 0x05
    4e0e:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    4e10:	eb 81       	ldd	r30, Y+3	; 0x03
    4e12:	fc 81       	ldd	r31, Y+4	; 0x04
    4e14:	8f 81       	ldd	r24, Y+7	; 0x07
    4e16:	98 85       	ldd	r25, Y+8	; 0x08
    4e18:	93 83       	std	Z+3, r25	; 0x03
    4e1a:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    4e1c:	ef 81       	ldd	r30, Y+7	; 0x07
    4e1e:	f8 85       	ldd	r31, Y+8	; 0x08
    4e20:	8d 81       	ldd	r24, Y+5	; 0x05
    4e22:	9e 81       	ldd	r25, Y+6	; 0x06
    4e24:	91 87       	std	Z+9, r25	; 0x09
    4e26:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    4e28:	ed 81       	ldd	r30, Y+5	; 0x05
    4e2a:	fe 81       	ldd	r31, Y+6	; 0x06
    4e2c:	80 81       	ld	r24, Z
    4e2e:	8f 5f       	subi	r24, 0xFF	; 255
    4e30:	ed 81       	ldd	r30, Y+5	; 0x05
    4e32:	fe 81       	ldd	r31, Y+6	; 0x06
    4e34:	80 83       	st	Z, r24
}
    4e36:	28 96       	adiw	r28, 0x08	; 8
    4e38:	0f b6       	in	r0, 0x3f	; 63
    4e3a:	f8 94       	cli
    4e3c:	de bf       	out	0x3e, r29	; 62
    4e3e:	0f be       	out	0x3f, r0	; 63
    4e40:	cd bf       	out	0x3d, r28	; 61
    4e42:	cf 91       	pop	r28
    4e44:	df 91       	pop	r29
    4e46:	08 95       	ret

00004e48 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    4e48:	df 93       	push	r29
    4e4a:	cf 93       	push	r28
    4e4c:	00 d0       	rcall	.+0      	; 0x4e4e <uxListRemove+0x6>
    4e4e:	00 d0       	rcall	.+0      	; 0x4e50 <uxListRemove+0x8>
    4e50:	cd b7       	in	r28, 0x3d	; 61
    4e52:	de b7       	in	r29, 0x3e	; 62
    4e54:	9c 83       	std	Y+4, r25	; 0x04
    4e56:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    4e58:	eb 81       	ldd	r30, Y+3	; 0x03
    4e5a:	fc 81       	ldd	r31, Y+4	; 0x04
    4e5c:	80 85       	ldd	r24, Z+8	; 0x08
    4e5e:	91 85       	ldd	r25, Z+9	; 0x09
    4e60:	9a 83       	std	Y+2, r25	; 0x02
    4e62:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    4e64:	eb 81       	ldd	r30, Y+3	; 0x03
    4e66:	fc 81       	ldd	r31, Y+4	; 0x04
    4e68:	a2 81       	ldd	r26, Z+2	; 0x02
    4e6a:	b3 81       	ldd	r27, Z+3	; 0x03
    4e6c:	eb 81       	ldd	r30, Y+3	; 0x03
    4e6e:	fc 81       	ldd	r31, Y+4	; 0x04
    4e70:	84 81       	ldd	r24, Z+4	; 0x04
    4e72:	95 81       	ldd	r25, Z+5	; 0x05
    4e74:	15 96       	adiw	r26, 0x05	; 5
    4e76:	9c 93       	st	X, r25
    4e78:	8e 93       	st	-X, r24
    4e7a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    4e7c:	eb 81       	ldd	r30, Y+3	; 0x03
    4e7e:	fc 81       	ldd	r31, Y+4	; 0x04
    4e80:	a4 81       	ldd	r26, Z+4	; 0x04
    4e82:	b5 81       	ldd	r27, Z+5	; 0x05
    4e84:	eb 81       	ldd	r30, Y+3	; 0x03
    4e86:	fc 81       	ldd	r31, Y+4	; 0x04
    4e88:	82 81       	ldd	r24, Z+2	; 0x02
    4e8a:	93 81       	ldd	r25, Z+3	; 0x03
    4e8c:	13 96       	adiw	r26, 0x03	; 3
    4e8e:	9c 93       	st	X, r25
    4e90:	8e 93       	st	-X, r24
    4e92:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    4e94:	e9 81       	ldd	r30, Y+1	; 0x01
    4e96:	fa 81       	ldd	r31, Y+2	; 0x02
    4e98:	21 81       	ldd	r18, Z+1	; 0x01
    4e9a:	32 81       	ldd	r19, Z+2	; 0x02
    4e9c:	8b 81       	ldd	r24, Y+3	; 0x03
    4e9e:	9c 81       	ldd	r25, Y+4	; 0x04
    4ea0:	28 17       	cp	r18, r24
    4ea2:	39 07       	cpc	r19, r25
    4ea4:	41 f4       	brne	.+16     	; 0x4eb6 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    4ea6:	eb 81       	ldd	r30, Y+3	; 0x03
    4ea8:	fc 81       	ldd	r31, Y+4	; 0x04
    4eaa:	84 81       	ldd	r24, Z+4	; 0x04
    4eac:	95 81       	ldd	r25, Z+5	; 0x05
    4eae:	e9 81       	ldd	r30, Y+1	; 0x01
    4eb0:	fa 81       	ldd	r31, Y+2	; 0x02
    4eb2:	92 83       	std	Z+2, r25	; 0x02
    4eb4:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    4eb6:	eb 81       	ldd	r30, Y+3	; 0x03
    4eb8:	fc 81       	ldd	r31, Y+4	; 0x04
    4eba:	11 86       	std	Z+9, r1	; 0x09
    4ebc:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    4ebe:	e9 81       	ldd	r30, Y+1	; 0x01
    4ec0:	fa 81       	ldd	r31, Y+2	; 0x02
    4ec2:	80 81       	ld	r24, Z
    4ec4:	81 50       	subi	r24, 0x01	; 1
    4ec6:	e9 81       	ldd	r30, Y+1	; 0x01
    4ec8:	fa 81       	ldd	r31, Y+2	; 0x02
    4eca:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    4ecc:	e9 81       	ldd	r30, Y+1	; 0x01
    4ece:	fa 81       	ldd	r31, Y+2	; 0x02
    4ed0:	80 81       	ld	r24, Z
}
    4ed2:	0f 90       	pop	r0
    4ed4:	0f 90       	pop	r0
    4ed6:	0f 90       	pop	r0
    4ed8:	0f 90       	pop	r0
    4eda:	cf 91       	pop	r28
    4edc:	df 91       	pop	r29
    4ede:	08 95       	ret

00004ee0 <scanButton>:
//CREATING A SEMAPHORE OBJECT

SemaphoreHandle_t x_semaphore;


void scanButton(void* pv){
    4ee0:	df 93       	push	r29
    4ee2:	cf 93       	push	r28
    4ee4:	00 d0       	rcall	.+0      	; 0x4ee6 <scanButton+0x6>
    4ee6:	00 d0       	rcall	.+0      	; 0x4ee8 <scanButton+0x8>
    4ee8:	cd b7       	in	r28, 0x3d	; 61
    4eea:	de b7       	in	r29, 0x3e	; 62
    4eec:	9c 83       	std	Y+4, r25	; 0x04
    4eee:	8b 83       	std	Y+3, r24	; 0x03


	u8 btn_State = pdFALSE;
    4ef0:	1a 82       	std	Y+2, r1	; 0x02
	u8 flag;


	while(1){
		flag = DIO_u8_get_pin(PORTA, PIN0);
    4ef2:	80 e0       	ldi	r24, 0x00	; 0
    4ef4:	60 e0       	ldi	r22, 0x00	; 0
    4ef6:	0e 94 53 09 	call	0x12a6	; 0x12a6 <DIO_u8_get_pin>
    4efa:	89 83       	std	Y+1, r24	; 0x01
		if((flag == 0) && (btn_State == pdFALSE)){
    4efc:	89 81       	ldd	r24, Y+1	; 0x01
    4efe:	88 23       	and	r24, r24
    4f00:	89 f4       	brne	.+34     	; 0x4f24 <scanButton+0x44>
    4f02:	8a 81       	ldd	r24, Y+2	; 0x02
    4f04:	88 23       	and	r24, r24
    4f06:	71 f4       	brne	.+28     	; 0x4f24 <scanButton+0x44>

			// button is pressed
			// change state to true
			btn_State = pdTRUE;
    4f08:	81 e0       	ldi	r24, 0x01	; 1
    4f0a:	8a 83       	std	Y+2, r24	; 0x02
			// give back the semaphore;
			xSemaphoreGive(x_semaphore);
    4f0c:	80 91 f1 05 	lds	r24, 0x05F1
    4f10:	90 91 f2 05 	lds	r25, 0x05F2
    4f14:	60 e0       	ldi	r22, 0x00	; 0
    4f16:	70 e0       	ldi	r23, 0x00	; 0
    4f18:	40 e0       	ldi	r20, 0x00	; 0
    4f1a:	50 e0       	ldi	r21, 0x00	; 0
    4f1c:	20 e0       	ldi	r18, 0x00	; 0
    4f1e:	0e 94 0b 2c 	call	0x5816	; 0x5816 <xQueueGenericSend>
    4f22:	0f c0       	rjmp	.+30     	; 0x4f42 <scanButton+0x62>

		}else if ((flag == 1)&&(btn_State == pdTRUE)){
    4f24:	89 81       	ldd	r24, Y+1	; 0x01
    4f26:	81 30       	cpi	r24, 0x01	; 1
    4f28:	61 f4       	brne	.+24     	; 0x4f42 <scanButton+0x62>
    4f2a:	8a 81       	ldd	r24, Y+2	; 0x02
    4f2c:	81 30       	cpi	r24, 0x01	; 1
    4f2e:	49 f4       	brne	.+18     	; 0x4f42 <scanButton+0x62>

			// button was pressed and now is released
			btn_State = pdFALSE;
    4f30:	1a 82       	std	Y+2, r1	; 0x02
			//try to take the semaphore
			xSemaphoreTake(x_semaphore,0);
    4f32:	80 91 f1 05 	lds	r24, 0x05F1
    4f36:	90 91 f2 05 	lds	r25, 0x05F2
    4f3a:	60 e0       	ldi	r22, 0x00	; 0
    4f3c:	70 e0       	ldi	r23, 0x00	; 0
    4f3e:	0e 94 0b 2e 	call	0x5c16	; 0x5c16 <xQueueSemaphoreTake>
		}


		vTaskDelay(10);
    4f42:	8a e0       	ldi	r24, 0x0A	; 10
    4f44:	90 e0       	ldi	r25, 0x00	; 0
    4f46:	0e 94 ab 34 	call	0x6956	; 0x6956 <vTaskDelay>
    4f4a:	d3 cf       	rjmp	.-90     	; 0x4ef2 <scanButton+0x12>

00004f4c <toggle_led>:
	}

}


void toggle_led(void* pv){
    4f4c:	df 93       	push	r29
    4f4e:	cf 93       	push	r28
    4f50:	00 d0       	rcall	.+0      	; 0x4f52 <toggle_led+0x6>
    4f52:	cd b7       	in	r28, 0x3d	; 61
    4f54:	de b7       	in	r29, 0x3e	; 62
    4f56:	9a 83       	std	Y+2, r25	; 0x02
    4f58:	89 83       	std	Y+1, r24	; 0x01
	while(1){


		//check on the semaphore if it is available (means button pressed)

		if(xSemaphoreTake(x_semaphore,10) == pdPASS){
    4f5a:	80 91 f1 05 	lds	r24, 0x05F1
    4f5e:	90 91 f2 05 	lds	r25, 0x05F2
    4f62:	6a e0       	ldi	r22, 0x0A	; 10
    4f64:	70 e0       	ldi	r23, 0x00	; 0
    4f66:	0e 94 0b 2e 	call	0x5c16	; 0x5c16 <xQueueSemaphoreTake>
    4f6a:	81 30       	cpi	r24, 0x01	; 1
    4f6c:	b1 f7       	brne	.-20     	; 0x4f5a <toggle_led+0xe>
		DIO_void_toggle_pin(PORTB, PIN0);
    4f6e:	81 e0       	ldi	r24, 0x01	; 1
    4f70:	60 e0       	ldi	r22, 0x00	; 0
    4f72:	0e 94 0d 09 	call	0x121a	; 0x121a <DIO_void_toggle_pin>
    4f76:	f1 cf       	rjmp	.-30     	; 0x4f5a <toggle_led+0xe>

00004f78 <main>:

	}

}

int main(){
    4f78:	ef 92       	push	r14
    4f7a:	ff 92       	push	r15
    4f7c:	0f 93       	push	r16
    4f7e:	df 93       	push	r29
    4f80:	cf 93       	push	r28
    4f82:	cd b7       	in	r28, 0x3d	; 61
    4f84:	de b7       	in	r29, 0x3e	; 62

	// BUTTON
	DIO_void_pin_pullup(PORTA, PIN0);
    4f86:	80 e0       	ldi	r24, 0x00	; 0
    4f88:	60 e0       	ldi	r22, 0x00	; 0
    4f8a:	0e 94 94 07 	call	0xf28	; 0xf28 <DIO_void_pin_pullup>
	// LED
	DIO_void_set_pin_dir(PORTB, PIN0, OUTPUT);
    4f8e:	81 e0       	ldi	r24, 0x01	; 1
    4f90:	60 e0       	ldi	r22, 0x00	; 0
    4f92:	41 e0       	ldi	r20, 0x01	; 1
    4f94:	0e 94 15 07 	call	0xe2a	; 0xe2a <DIO_void_set_pin_dir>
	//create binary semaphore
	vSemaphoreCreateBinary(x_semaphore);
    4f98:	81 e0       	ldi	r24, 0x01	; 1
    4f9a:	60 e0       	ldi	r22, 0x00	; 0
    4f9c:	43 e0       	ldi	r20, 0x03	; 3
    4f9e:	0e 94 5f 2b 	call	0x56be	; 0x56be <xQueueGenericCreate>
    4fa2:	90 93 f2 05 	sts	0x05F2, r25
    4fa6:	80 93 f1 05 	sts	0x05F1, r24
    4faa:	80 91 f1 05 	lds	r24, 0x05F1
    4fae:	90 91 f2 05 	lds	r25, 0x05F2
    4fb2:	00 97       	sbiw	r24, 0x00	; 0
    4fb4:	59 f0       	breq	.+22     	; 0x4fcc <main+0x54>
    4fb6:	80 91 f1 05 	lds	r24, 0x05F1
    4fba:	90 91 f2 05 	lds	r25, 0x05F2
    4fbe:	60 e0       	ldi	r22, 0x00	; 0
    4fc0:	70 e0       	ldi	r23, 0x00	; 0
    4fc2:	40 e0       	ldi	r20, 0x00	; 0
    4fc4:	50 e0       	ldi	r21, 0x00	; 0
    4fc6:	20 e0       	ldi	r18, 0x00	; 0
    4fc8:	0e 94 0b 2c 	call	0x5816	; 0x5816 <xQueueGenericSend>
	// allocate memory for the 2 tasks (Create them)
	xTaskCreate(scanButton,"button",250,NULL,2,NULL);
    4fcc:	80 e7       	ldi	r24, 0x70	; 112
    4fce:	97 e2       	ldi	r25, 0x27	; 39
    4fd0:	20 e6       	ldi	r18, 0x60	; 96
    4fd2:	30 e0       	ldi	r19, 0x00	; 0
    4fd4:	b9 01       	movw	r22, r18
    4fd6:	4a ef       	ldi	r20, 0xFA	; 250
    4fd8:	50 e0       	ldi	r21, 0x00	; 0
    4fda:	20 e0       	ldi	r18, 0x00	; 0
    4fdc:	30 e0       	ldi	r19, 0x00	; 0
    4fde:	02 e0       	ldi	r16, 0x02	; 2
    4fe0:	ee 24       	eor	r14, r14
    4fe2:	ff 24       	eor	r15, r15
    4fe4:	0e 94 1b 32 	call	0x6436	; 0x6436 <xTaskCreate>
	xTaskCreate(toggle_led,"led",250,NULL,1,NULL);
    4fe8:	86 ea       	ldi	r24, 0xA6	; 166
    4fea:	97 e2       	ldi	r25, 0x27	; 39
    4fec:	27 e6       	ldi	r18, 0x67	; 103
    4fee:	30 e0       	ldi	r19, 0x00	; 0
    4ff0:	b9 01       	movw	r22, r18
    4ff2:	4a ef       	ldi	r20, 0xFA	; 250
    4ff4:	50 e0       	ldi	r21, 0x00	; 0
    4ff6:	20 e0       	ldi	r18, 0x00	; 0
    4ff8:	30 e0       	ldi	r19, 0x00	; 0
    4ffa:	01 e0       	ldi	r16, 0x01	; 1
    4ffc:	ee 24       	eor	r14, r14
    4ffe:	ff 24       	eor	r15, r15
    5000:	0e 94 1b 32 	call	0x6436	; 0x6436 <xTaskCreate>


	//initiate the scheduler.
	vTaskStartScheduler();
    5004:	0e 94 cd 34 	call	0x699a	; 0x699a <vTaskStartScheduler>
    5008:	ff cf       	rjmp	.-2      	; 0x5008 <main+0x90>

0000500a <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    500a:	df 93       	push	r29
    500c:	cf 93       	push	r28
    500e:	cd b7       	in	r28, 0x3d	; 61
    5010:	de b7       	in	r29, 0x3e	; 62
    5012:	28 97       	sbiw	r28, 0x08	; 8
    5014:	0f b6       	in	r0, 0x3f	; 63
    5016:	f8 94       	cli
    5018:	de bf       	out	0x3e, r29	; 62
    501a:	0f be       	out	0x3f, r0	; 63
    501c:	cd bf       	out	0x3d, r28	; 61
    501e:	9c 83       	std	Y+4, r25	; 0x04
    5020:	8b 83       	std	Y+3, r24	; 0x03
    5022:	7e 83       	std	Y+6, r23	; 0x06
    5024:	6d 83       	std	Y+5, r22	; 0x05
    5026:	58 87       	std	Y+8, r21	; 0x08
    5028:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    502a:	eb 81       	ldd	r30, Y+3	; 0x03
    502c:	fc 81       	ldd	r31, Y+4	; 0x04
    502e:	81 e1       	ldi	r24, 0x11	; 17
    5030:	80 83       	st	Z, r24
	pxTopOfStack--;
    5032:	8b 81       	ldd	r24, Y+3	; 0x03
    5034:	9c 81       	ldd	r25, Y+4	; 0x04
    5036:	01 97       	sbiw	r24, 0x01	; 1
    5038:	9c 83       	std	Y+4, r25	; 0x04
    503a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    503c:	eb 81       	ldd	r30, Y+3	; 0x03
    503e:	fc 81       	ldd	r31, Y+4	; 0x04
    5040:	82 e2       	ldi	r24, 0x22	; 34
    5042:	80 83       	st	Z, r24
	pxTopOfStack--;
    5044:	8b 81       	ldd	r24, Y+3	; 0x03
    5046:	9c 81       	ldd	r25, Y+4	; 0x04
    5048:	01 97       	sbiw	r24, 0x01	; 1
    504a:	9c 83       	std	Y+4, r25	; 0x04
    504c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    504e:	eb 81       	ldd	r30, Y+3	; 0x03
    5050:	fc 81       	ldd	r31, Y+4	; 0x04
    5052:	83 e3       	ldi	r24, 0x33	; 51
    5054:	80 83       	st	Z, r24
	pxTopOfStack--;
    5056:	8b 81       	ldd	r24, Y+3	; 0x03
    5058:	9c 81       	ldd	r25, Y+4	; 0x04
    505a:	01 97       	sbiw	r24, 0x01	; 1
    505c:	9c 83       	std	Y+4, r25	; 0x04
    505e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    5060:	8d 81       	ldd	r24, Y+5	; 0x05
    5062:	9e 81       	ldd	r25, Y+6	; 0x06
    5064:	9a 83       	std	Y+2, r25	; 0x02
    5066:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    5068:	89 81       	ldd	r24, Y+1	; 0x01
    506a:	eb 81       	ldd	r30, Y+3	; 0x03
    506c:	fc 81       	ldd	r31, Y+4	; 0x04
    506e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5070:	8b 81       	ldd	r24, Y+3	; 0x03
    5072:	9c 81       	ldd	r25, Y+4	; 0x04
    5074:	01 97       	sbiw	r24, 0x01	; 1
    5076:	9c 83       	std	Y+4, r25	; 0x04
    5078:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    507a:	89 81       	ldd	r24, Y+1	; 0x01
    507c:	9a 81       	ldd	r25, Y+2	; 0x02
    507e:	89 2f       	mov	r24, r25
    5080:	99 27       	eor	r25, r25
    5082:	9a 83       	std	Y+2, r25	; 0x02
    5084:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    5086:	89 81       	ldd	r24, Y+1	; 0x01
    5088:	eb 81       	ldd	r30, Y+3	; 0x03
    508a:	fc 81       	ldd	r31, Y+4	; 0x04
    508c:	80 83       	st	Z, r24
	pxTopOfStack--;
    508e:	8b 81       	ldd	r24, Y+3	; 0x03
    5090:	9c 81       	ldd	r25, Y+4	; 0x04
    5092:	01 97       	sbiw	r24, 0x01	; 1
    5094:	9c 83       	std	Y+4, r25	; 0x04
    5096:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    5098:	eb 81       	ldd	r30, Y+3	; 0x03
    509a:	fc 81       	ldd	r31, Y+4	; 0x04
    509c:	10 82       	st	Z, r1
	pxTopOfStack--;
    509e:	8b 81       	ldd	r24, Y+3	; 0x03
    50a0:	9c 81       	ldd	r25, Y+4	; 0x04
    50a2:	01 97       	sbiw	r24, 0x01	; 1
    50a4:	9c 83       	std	Y+4, r25	; 0x04
    50a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    50a8:	eb 81       	ldd	r30, Y+3	; 0x03
    50aa:	fc 81       	ldd	r31, Y+4	; 0x04
    50ac:	80 e8       	ldi	r24, 0x80	; 128
    50ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    50b0:	8b 81       	ldd	r24, Y+3	; 0x03
    50b2:	9c 81       	ldd	r25, Y+4	; 0x04
    50b4:	01 97       	sbiw	r24, 0x01	; 1
    50b6:	9c 83       	std	Y+4, r25	; 0x04
    50b8:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    50ba:	eb 81       	ldd	r30, Y+3	; 0x03
    50bc:	fc 81       	ldd	r31, Y+4	; 0x04
    50be:	10 82       	st	Z, r1
	pxTopOfStack--;
    50c0:	8b 81       	ldd	r24, Y+3	; 0x03
    50c2:	9c 81       	ldd	r25, Y+4	; 0x04
    50c4:	01 97       	sbiw	r24, 0x01	; 1
    50c6:	9c 83       	std	Y+4, r25	; 0x04
    50c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    50ca:	eb 81       	ldd	r30, Y+3	; 0x03
    50cc:	fc 81       	ldd	r31, Y+4	; 0x04
    50ce:	82 e0       	ldi	r24, 0x02	; 2
    50d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    50d2:	8b 81       	ldd	r24, Y+3	; 0x03
    50d4:	9c 81       	ldd	r25, Y+4	; 0x04
    50d6:	01 97       	sbiw	r24, 0x01	; 1
    50d8:	9c 83       	std	Y+4, r25	; 0x04
    50da:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    50dc:	eb 81       	ldd	r30, Y+3	; 0x03
    50de:	fc 81       	ldd	r31, Y+4	; 0x04
    50e0:	83 e0       	ldi	r24, 0x03	; 3
    50e2:	80 83       	st	Z, r24
	pxTopOfStack--;
    50e4:	8b 81       	ldd	r24, Y+3	; 0x03
    50e6:	9c 81       	ldd	r25, Y+4	; 0x04
    50e8:	01 97       	sbiw	r24, 0x01	; 1
    50ea:	9c 83       	std	Y+4, r25	; 0x04
    50ec:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    50ee:	eb 81       	ldd	r30, Y+3	; 0x03
    50f0:	fc 81       	ldd	r31, Y+4	; 0x04
    50f2:	84 e0       	ldi	r24, 0x04	; 4
    50f4:	80 83       	st	Z, r24
	pxTopOfStack--;
    50f6:	8b 81       	ldd	r24, Y+3	; 0x03
    50f8:	9c 81       	ldd	r25, Y+4	; 0x04
    50fa:	01 97       	sbiw	r24, 0x01	; 1
    50fc:	9c 83       	std	Y+4, r25	; 0x04
    50fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    5100:	eb 81       	ldd	r30, Y+3	; 0x03
    5102:	fc 81       	ldd	r31, Y+4	; 0x04
    5104:	85 e0       	ldi	r24, 0x05	; 5
    5106:	80 83       	st	Z, r24
	pxTopOfStack--;
    5108:	8b 81       	ldd	r24, Y+3	; 0x03
    510a:	9c 81       	ldd	r25, Y+4	; 0x04
    510c:	01 97       	sbiw	r24, 0x01	; 1
    510e:	9c 83       	std	Y+4, r25	; 0x04
    5110:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    5112:	eb 81       	ldd	r30, Y+3	; 0x03
    5114:	fc 81       	ldd	r31, Y+4	; 0x04
    5116:	86 e0       	ldi	r24, 0x06	; 6
    5118:	80 83       	st	Z, r24
	pxTopOfStack--;
    511a:	8b 81       	ldd	r24, Y+3	; 0x03
    511c:	9c 81       	ldd	r25, Y+4	; 0x04
    511e:	01 97       	sbiw	r24, 0x01	; 1
    5120:	9c 83       	std	Y+4, r25	; 0x04
    5122:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    5124:	eb 81       	ldd	r30, Y+3	; 0x03
    5126:	fc 81       	ldd	r31, Y+4	; 0x04
    5128:	87 e0       	ldi	r24, 0x07	; 7
    512a:	80 83       	st	Z, r24
	pxTopOfStack--;
    512c:	8b 81       	ldd	r24, Y+3	; 0x03
    512e:	9c 81       	ldd	r25, Y+4	; 0x04
    5130:	01 97       	sbiw	r24, 0x01	; 1
    5132:	9c 83       	std	Y+4, r25	; 0x04
    5134:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    5136:	eb 81       	ldd	r30, Y+3	; 0x03
    5138:	fc 81       	ldd	r31, Y+4	; 0x04
    513a:	88 e0       	ldi	r24, 0x08	; 8
    513c:	80 83       	st	Z, r24
	pxTopOfStack--;
    513e:	8b 81       	ldd	r24, Y+3	; 0x03
    5140:	9c 81       	ldd	r25, Y+4	; 0x04
    5142:	01 97       	sbiw	r24, 0x01	; 1
    5144:	9c 83       	std	Y+4, r25	; 0x04
    5146:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    5148:	eb 81       	ldd	r30, Y+3	; 0x03
    514a:	fc 81       	ldd	r31, Y+4	; 0x04
    514c:	89 e0       	ldi	r24, 0x09	; 9
    514e:	80 83       	st	Z, r24
	pxTopOfStack--;
    5150:	8b 81       	ldd	r24, Y+3	; 0x03
    5152:	9c 81       	ldd	r25, Y+4	; 0x04
    5154:	01 97       	sbiw	r24, 0x01	; 1
    5156:	9c 83       	std	Y+4, r25	; 0x04
    5158:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    515a:	eb 81       	ldd	r30, Y+3	; 0x03
    515c:	fc 81       	ldd	r31, Y+4	; 0x04
    515e:	80 e1       	ldi	r24, 0x10	; 16
    5160:	80 83       	st	Z, r24
	pxTopOfStack--;
    5162:	8b 81       	ldd	r24, Y+3	; 0x03
    5164:	9c 81       	ldd	r25, Y+4	; 0x04
    5166:	01 97       	sbiw	r24, 0x01	; 1
    5168:	9c 83       	std	Y+4, r25	; 0x04
    516a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    516c:	eb 81       	ldd	r30, Y+3	; 0x03
    516e:	fc 81       	ldd	r31, Y+4	; 0x04
    5170:	81 e1       	ldi	r24, 0x11	; 17
    5172:	80 83       	st	Z, r24
	pxTopOfStack--;
    5174:	8b 81       	ldd	r24, Y+3	; 0x03
    5176:	9c 81       	ldd	r25, Y+4	; 0x04
    5178:	01 97       	sbiw	r24, 0x01	; 1
    517a:	9c 83       	std	Y+4, r25	; 0x04
    517c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    517e:	eb 81       	ldd	r30, Y+3	; 0x03
    5180:	fc 81       	ldd	r31, Y+4	; 0x04
    5182:	82 e1       	ldi	r24, 0x12	; 18
    5184:	80 83       	st	Z, r24
	pxTopOfStack--;
    5186:	8b 81       	ldd	r24, Y+3	; 0x03
    5188:	9c 81       	ldd	r25, Y+4	; 0x04
    518a:	01 97       	sbiw	r24, 0x01	; 1
    518c:	9c 83       	std	Y+4, r25	; 0x04
    518e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    5190:	eb 81       	ldd	r30, Y+3	; 0x03
    5192:	fc 81       	ldd	r31, Y+4	; 0x04
    5194:	83 e1       	ldi	r24, 0x13	; 19
    5196:	80 83       	st	Z, r24
	pxTopOfStack--;
    5198:	8b 81       	ldd	r24, Y+3	; 0x03
    519a:	9c 81       	ldd	r25, Y+4	; 0x04
    519c:	01 97       	sbiw	r24, 0x01	; 1
    519e:	9c 83       	std	Y+4, r25	; 0x04
    51a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    51a2:	eb 81       	ldd	r30, Y+3	; 0x03
    51a4:	fc 81       	ldd	r31, Y+4	; 0x04
    51a6:	84 e1       	ldi	r24, 0x14	; 20
    51a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    51aa:	8b 81       	ldd	r24, Y+3	; 0x03
    51ac:	9c 81       	ldd	r25, Y+4	; 0x04
    51ae:	01 97       	sbiw	r24, 0x01	; 1
    51b0:	9c 83       	std	Y+4, r25	; 0x04
    51b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    51b4:	eb 81       	ldd	r30, Y+3	; 0x03
    51b6:	fc 81       	ldd	r31, Y+4	; 0x04
    51b8:	85 e1       	ldi	r24, 0x15	; 21
    51ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    51bc:	8b 81       	ldd	r24, Y+3	; 0x03
    51be:	9c 81       	ldd	r25, Y+4	; 0x04
    51c0:	01 97       	sbiw	r24, 0x01	; 1
    51c2:	9c 83       	std	Y+4, r25	; 0x04
    51c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    51c6:	eb 81       	ldd	r30, Y+3	; 0x03
    51c8:	fc 81       	ldd	r31, Y+4	; 0x04
    51ca:	86 e1       	ldi	r24, 0x16	; 22
    51cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    51ce:	8b 81       	ldd	r24, Y+3	; 0x03
    51d0:	9c 81       	ldd	r25, Y+4	; 0x04
    51d2:	01 97       	sbiw	r24, 0x01	; 1
    51d4:	9c 83       	std	Y+4, r25	; 0x04
    51d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    51d8:	eb 81       	ldd	r30, Y+3	; 0x03
    51da:	fc 81       	ldd	r31, Y+4	; 0x04
    51dc:	87 e1       	ldi	r24, 0x17	; 23
    51de:	80 83       	st	Z, r24
	pxTopOfStack--;
    51e0:	8b 81       	ldd	r24, Y+3	; 0x03
    51e2:	9c 81       	ldd	r25, Y+4	; 0x04
    51e4:	01 97       	sbiw	r24, 0x01	; 1
    51e6:	9c 83       	std	Y+4, r25	; 0x04
    51e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    51ea:	eb 81       	ldd	r30, Y+3	; 0x03
    51ec:	fc 81       	ldd	r31, Y+4	; 0x04
    51ee:	88 e1       	ldi	r24, 0x18	; 24
    51f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    51f2:	8b 81       	ldd	r24, Y+3	; 0x03
    51f4:	9c 81       	ldd	r25, Y+4	; 0x04
    51f6:	01 97       	sbiw	r24, 0x01	; 1
    51f8:	9c 83       	std	Y+4, r25	; 0x04
    51fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    51fc:	eb 81       	ldd	r30, Y+3	; 0x03
    51fe:	fc 81       	ldd	r31, Y+4	; 0x04
    5200:	89 e1       	ldi	r24, 0x19	; 25
    5202:	80 83       	st	Z, r24
	pxTopOfStack--;
    5204:	8b 81       	ldd	r24, Y+3	; 0x03
    5206:	9c 81       	ldd	r25, Y+4	; 0x04
    5208:	01 97       	sbiw	r24, 0x01	; 1
    520a:	9c 83       	std	Y+4, r25	; 0x04
    520c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    520e:	eb 81       	ldd	r30, Y+3	; 0x03
    5210:	fc 81       	ldd	r31, Y+4	; 0x04
    5212:	80 e2       	ldi	r24, 0x20	; 32
    5214:	80 83       	st	Z, r24
	pxTopOfStack--;
    5216:	8b 81       	ldd	r24, Y+3	; 0x03
    5218:	9c 81       	ldd	r25, Y+4	; 0x04
    521a:	01 97       	sbiw	r24, 0x01	; 1
    521c:	9c 83       	std	Y+4, r25	; 0x04
    521e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    5220:	eb 81       	ldd	r30, Y+3	; 0x03
    5222:	fc 81       	ldd	r31, Y+4	; 0x04
    5224:	81 e2       	ldi	r24, 0x21	; 33
    5226:	80 83       	st	Z, r24
	pxTopOfStack--;
    5228:	8b 81       	ldd	r24, Y+3	; 0x03
    522a:	9c 81       	ldd	r25, Y+4	; 0x04
    522c:	01 97       	sbiw	r24, 0x01	; 1
    522e:	9c 83       	std	Y+4, r25	; 0x04
    5230:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    5232:	eb 81       	ldd	r30, Y+3	; 0x03
    5234:	fc 81       	ldd	r31, Y+4	; 0x04
    5236:	82 e2       	ldi	r24, 0x22	; 34
    5238:	80 83       	st	Z, r24
	pxTopOfStack--;
    523a:	8b 81       	ldd	r24, Y+3	; 0x03
    523c:	9c 81       	ldd	r25, Y+4	; 0x04
    523e:	01 97       	sbiw	r24, 0x01	; 1
    5240:	9c 83       	std	Y+4, r25	; 0x04
    5242:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    5244:	eb 81       	ldd	r30, Y+3	; 0x03
    5246:	fc 81       	ldd	r31, Y+4	; 0x04
    5248:	83 e2       	ldi	r24, 0x23	; 35
    524a:	80 83       	st	Z, r24
	pxTopOfStack--;
    524c:	8b 81       	ldd	r24, Y+3	; 0x03
    524e:	9c 81       	ldd	r25, Y+4	; 0x04
    5250:	01 97       	sbiw	r24, 0x01	; 1
    5252:	9c 83       	std	Y+4, r25	; 0x04
    5254:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    5256:	8f 81       	ldd	r24, Y+7	; 0x07
    5258:	98 85       	ldd	r25, Y+8	; 0x08
    525a:	9a 83       	std	Y+2, r25	; 0x02
    525c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    525e:	89 81       	ldd	r24, Y+1	; 0x01
    5260:	eb 81       	ldd	r30, Y+3	; 0x03
    5262:	fc 81       	ldd	r31, Y+4	; 0x04
    5264:	80 83       	st	Z, r24
	pxTopOfStack--;
    5266:	8b 81       	ldd	r24, Y+3	; 0x03
    5268:	9c 81       	ldd	r25, Y+4	; 0x04
    526a:	01 97       	sbiw	r24, 0x01	; 1
    526c:	9c 83       	std	Y+4, r25	; 0x04
    526e:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    5270:	89 81       	ldd	r24, Y+1	; 0x01
    5272:	9a 81       	ldd	r25, Y+2	; 0x02
    5274:	89 2f       	mov	r24, r25
    5276:	99 27       	eor	r25, r25
    5278:	9a 83       	std	Y+2, r25	; 0x02
    527a:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    527c:	89 81       	ldd	r24, Y+1	; 0x01
    527e:	eb 81       	ldd	r30, Y+3	; 0x03
    5280:	fc 81       	ldd	r31, Y+4	; 0x04
    5282:	80 83       	st	Z, r24
	pxTopOfStack--;
    5284:	8b 81       	ldd	r24, Y+3	; 0x03
    5286:	9c 81       	ldd	r25, Y+4	; 0x04
    5288:	01 97       	sbiw	r24, 0x01	; 1
    528a:	9c 83       	std	Y+4, r25	; 0x04
    528c:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    528e:	eb 81       	ldd	r30, Y+3	; 0x03
    5290:	fc 81       	ldd	r31, Y+4	; 0x04
    5292:	86 e2       	ldi	r24, 0x26	; 38
    5294:	80 83       	st	Z, r24
	pxTopOfStack--;
    5296:	8b 81       	ldd	r24, Y+3	; 0x03
    5298:	9c 81       	ldd	r25, Y+4	; 0x04
    529a:	01 97       	sbiw	r24, 0x01	; 1
    529c:	9c 83       	std	Y+4, r25	; 0x04
    529e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    52a0:	eb 81       	ldd	r30, Y+3	; 0x03
    52a2:	fc 81       	ldd	r31, Y+4	; 0x04
    52a4:	87 e2       	ldi	r24, 0x27	; 39
    52a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    52a8:	8b 81       	ldd	r24, Y+3	; 0x03
    52aa:	9c 81       	ldd	r25, Y+4	; 0x04
    52ac:	01 97       	sbiw	r24, 0x01	; 1
    52ae:	9c 83       	std	Y+4, r25	; 0x04
    52b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    52b2:	eb 81       	ldd	r30, Y+3	; 0x03
    52b4:	fc 81       	ldd	r31, Y+4	; 0x04
    52b6:	88 e2       	ldi	r24, 0x28	; 40
    52b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    52ba:	8b 81       	ldd	r24, Y+3	; 0x03
    52bc:	9c 81       	ldd	r25, Y+4	; 0x04
    52be:	01 97       	sbiw	r24, 0x01	; 1
    52c0:	9c 83       	std	Y+4, r25	; 0x04
    52c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    52c4:	eb 81       	ldd	r30, Y+3	; 0x03
    52c6:	fc 81       	ldd	r31, Y+4	; 0x04
    52c8:	89 e2       	ldi	r24, 0x29	; 41
    52ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    52cc:	8b 81       	ldd	r24, Y+3	; 0x03
    52ce:	9c 81       	ldd	r25, Y+4	; 0x04
    52d0:	01 97       	sbiw	r24, 0x01	; 1
    52d2:	9c 83       	std	Y+4, r25	; 0x04
    52d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    52d6:	eb 81       	ldd	r30, Y+3	; 0x03
    52d8:	fc 81       	ldd	r31, Y+4	; 0x04
    52da:	80 e3       	ldi	r24, 0x30	; 48
    52dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    52de:	8b 81       	ldd	r24, Y+3	; 0x03
    52e0:	9c 81       	ldd	r25, Y+4	; 0x04
    52e2:	01 97       	sbiw	r24, 0x01	; 1
    52e4:	9c 83       	std	Y+4, r25	; 0x04
    52e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    52e8:	eb 81       	ldd	r30, Y+3	; 0x03
    52ea:	fc 81       	ldd	r31, Y+4	; 0x04
    52ec:	81 e3       	ldi	r24, 0x31	; 49
    52ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    52f0:	8b 81       	ldd	r24, Y+3	; 0x03
    52f2:	9c 81       	ldd	r25, Y+4	; 0x04
    52f4:	01 97       	sbiw	r24, 0x01	; 1
    52f6:	9c 83       	std	Y+4, r25	; 0x04
    52f8:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    52fa:	8b 81       	ldd	r24, Y+3	; 0x03
    52fc:	9c 81       	ldd	r25, Y+4	; 0x04
}
    52fe:	28 96       	adiw	r28, 0x08	; 8
    5300:	0f b6       	in	r0, 0x3f	; 63
    5302:	f8 94       	cli
    5304:	de bf       	out	0x3e, r29	; 62
    5306:	0f be       	out	0x3f, r0	; 63
    5308:	cd bf       	out	0x3d, r28	; 61
    530a:	cf 91       	pop	r28
    530c:	df 91       	pop	r29
    530e:	08 95       	ret

00005310 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    5310:	df 93       	push	r29
    5312:	cf 93       	push	r28
    5314:	cd b7       	in	r28, 0x3d	; 61
    5316:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    5318:	0e 94 7a 2a 	call	0x54f4	; 0x54f4 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    531c:	a0 91 94 05 	lds	r26, 0x0594
    5320:	b0 91 95 05 	lds	r27, 0x0595
    5324:	cd 91       	ld	r28, X+
    5326:	cd bf       	out	0x3d, r28	; 61
    5328:	dd 91       	ld	r29, X+
    532a:	de bf       	out	0x3e, r29	; 62
    532c:	ff 91       	pop	r31
    532e:	ef 91       	pop	r30
    5330:	df 91       	pop	r29
    5332:	cf 91       	pop	r28
    5334:	bf 91       	pop	r27
    5336:	af 91       	pop	r26
    5338:	9f 91       	pop	r25
    533a:	8f 91       	pop	r24
    533c:	7f 91       	pop	r23
    533e:	6f 91       	pop	r22
    5340:	5f 91       	pop	r21
    5342:	4f 91       	pop	r20
    5344:	3f 91       	pop	r19
    5346:	2f 91       	pop	r18
    5348:	1f 91       	pop	r17
    534a:	0f 91       	pop	r16
    534c:	ff 90       	pop	r15
    534e:	ef 90       	pop	r14
    5350:	df 90       	pop	r13
    5352:	cf 90       	pop	r12
    5354:	bf 90       	pop	r11
    5356:	af 90       	pop	r10
    5358:	9f 90       	pop	r9
    535a:	8f 90       	pop	r8
    535c:	7f 90       	pop	r7
    535e:	6f 90       	pop	r6
    5360:	5f 90       	pop	r5
    5362:	4f 90       	pop	r4
    5364:	3f 90       	pop	r3
    5366:	2f 90       	pop	r2
    5368:	1f 90       	pop	r1
    536a:	0f 90       	pop	r0
    536c:	0f be       	out	0x3f, r0	; 63
    536e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    5370:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    5372:	81 e0       	ldi	r24, 0x01	; 1
}
    5374:	cf 91       	pop	r28
    5376:	df 91       	pop	r29
    5378:	08 95       	ret

0000537a <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    537a:	df 93       	push	r29
    537c:	cf 93       	push	r28
    537e:	cd b7       	in	r28, 0x3d	; 61
    5380:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    5382:	cf 91       	pop	r28
    5384:	df 91       	pop	r29
    5386:	08 95       	ret

00005388 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    5388:	0f 92       	push	r0
    538a:	0f b6       	in	r0, 0x3f	; 63
    538c:	f8 94       	cli
    538e:	0f 92       	push	r0
    5390:	1f 92       	push	r1
    5392:	11 24       	eor	r1, r1
    5394:	2f 92       	push	r2
    5396:	3f 92       	push	r3
    5398:	4f 92       	push	r4
    539a:	5f 92       	push	r5
    539c:	6f 92       	push	r6
    539e:	7f 92       	push	r7
    53a0:	8f 92       	push	r8
    53a2:	9f 92       	push	r9
    53a4:	af 92       	push	r10
    53a6:	bf 92       	push	r11
    53a8:	cf 92       	push	r12
    53aa:	df 92       	push	r13
    53ac:	ef 92       	push	r14
    53ae:	ff 92       	push	r15
    53b0:	0f 93       	push	r16
    53b2:	1f 93       	push	r17
    53b4:	2f 93       	push	r18
    53b6:	3f 93       	push	r19
    53b8:	4f 93       	push	r20
    53ba:	5f 93       	push	r21
    53bc:	6f 93       	push	r22
    53be:	7f 93       	push	r23
    53c0:	8f 93       	push	r24
    53c2:	9f 93       	push	r25
    53c4:	af 93       	push	r26
    53c6:	bf 93       	push	r27
    53c8:	cf 93       	push	r28
    53ca:	df 93       	push	r29
    53cc:	ef 93       	push	r30
    53ce:	ff 93       	push	r31
    53d0:	a0 91 94 05 	lds	r26, 0x0594
    53d4:	b0 91 95 05 	lds	r27, 0x0595
    53d8:	0d b6       	in	r0, 0x3d	; 61
    53da:	0d 92       	st	X+, r0
    53dc:	0e b6       	in	r0, 0x3e	; 62
    53de:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    53e0:	0e 94 ec 36 	call	0x6dd8	; 0x6dd8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    53e4:	a0 91 94 05 	lds	r26, 0x0594
    53e8:	b0 91 95 05 	lds	r27, 0x0595
    53ec:	cd 91       	ld	r28, X+
    53ee:	cd bf       	out	0x3d, r28	; 61
    53f0:	dd 91       	ld	r29, X+
    53f2:	de bf       	out	0x3e, r29	; 62
    53f4:	ff 91       	pop	r31
    53f6:	ef 91       	pop	r30
    53f8:	df 91       	pop	r29
    53fa:	cf 91       	pop	r28
    53fc:	bf 91       	pop	r27
    53fe:	af 91       	pop	r26
    5400:	9f 91       	pop	r25
    5402:	8f 91       	pop	r24
    5404:	7f 91       	pop	r23
    5406:	6f 91       	pop	r22
    5408:	5f 91       	pop	r21
    540a:	4f 91       	pop	r20
    540c:	3f 91       	pop	r19
    540e:	2f 91       	pop	r18
    5410:	1f 91       	pop	r17
    5412:	0f 91       	pop	r16
    5414:	ff 90       	pop	r15
    5416:	ef 90       	pop	r14
    5418:	df 90       	pop	r13
    541a:	cf 90       	pop	r12
    541c:	bf 90       	pop	r11
    541e:	af 90       	pop	r10
    5420:	9f 90       	pop	r9
    5422:	8f 90       	pop	r8
    5424:	7f 90       	pop	r7
    5426:	6f 90       	pop	r6
    5428:	5f 90       	pop	r5
    542a:	4f 90       	pop	r4
    542c:	3f 90       	pop	r3
    542e:	2f 90       	pop	r2
    5430:	1f 90       	pop	r1
    5432:	0f 90       	pop	r0
    5434:	0f be       	out	0x3f, r0	; 63
    5436:	0f 90       	pop	r0

	asm volatile ( "ret" );
    5438:	08 95       	ret

0000543a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    543a:	0f 92       	push	r0
    543c:	0f b6       	in	r0, 0x3f	; 63
    543e:	f8 94       	cli
    5440:	0f 92       	push	r0
    5442:	1f 92       	push	r1
    5444:	11 24       	eor	r1, r1
    5446:	2f 92       	push	r2
    5448:	3f 92       	push	r3
    544a:	4f 92       	push	r4
    544c:	5f 92       	push	r5
    544e:	6f 92       	push	r6
    5450:	7f 92       	push	r7
    5452:	8f 92       	push	r8
    5454:	9f 92       	push	r9
    5456:	af 92       	push	r10
    5458:	bf 92       	push	r11
    545a:	cf 92       	push	r12
    545c:	df 92       	push	r13
    545e:	ef 92       	push	r14
    5460:	ff 92       	push	r15
    5462:	0f 93       	push	r16
    5464:	1f 93       	push	r17
    5466:	2f 93       	push	r18
    5468:	3f 93       	push	r19
    546a:	4f 93       	push	r20
    546c:	5f 93       	push	r21
    546e:	6f 93       	push	r22
    5470:	7f 93       	push	r23
    5472:	8f 93       	push	r24
    5474:	9f 93       	push	r25
    5476:	af 93       	push	r26
    5478:	bf 93       	push	r27
    547a:	cf 93       	push	r28
    547c:	df 93       	push	r29
    547e:	ef 93       	push	r30
    5480:	ff 93       	push	r31
    5482:	a0 91 94 05 	lds	r26, 0x0594
    5486:	b0 91 95 05 	lds	r27, 0x0595
    548a:	0d b6       	in	r0, 0x3d	; 61
    548c:	0d 92       	st	X+, r0
    548e:	0e b6       	in	r0, 0x3e	; 62
    5490:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    5492:	0e 94 07 36 	call	0x6c0e	; 0x6c0e <xTaskIncrementTick>
    5496:	88 23       	and	r24, r24
    5498:	11 f0       	breq	.+4      	; 0x549e <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    549a:	0e 94 ec 36 	call	0x6dd8	; 0x6dd8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    549e:	a0 91 94 05 	lds	r26, 0x0594
    54a2:	b0 91 95 05 	lds	r27, 0x0595
    54a6:	cd 91       	ld	r28, X+
    54a8:	cd bf       	out	0x3d, r28	; 61
    54aa:	dd 91       	ld	r29, X+
    54ac:	de bf       	out	0x3e, r29	; 62
    54ae:	ff 91       	pop	r31
    54b0:	ef 91       	pop	r30
    54b2:	df 91       	pop	r29
    54b4:	cf 91       	pop	r28
    54b6:	bf 91       	pop	r27
    54b8:	af 91       	pop	r26
    54ba:	9f 91       	pop	r25
    54bc:	8f 91       	pop	r24
    54be:	7f 91       	pop	r23
    54c0:	6f 91       	pop	r22
    54c2:	5f 91       	pop	r21
    54c4:	4f 91       	pop	r20
    54c6:	3f 91       	pop	r19
    54c8:	2f 91       	pop	r18
    54ca:	1f 91       	pop	r17
    54cc:	0f 91       	pop	r16
    54ce:	ff 90       	pop	r15
    54d0:	ef 90       	pop	r14
    54d2:	df 90       	pop	r13
    54d4:	cf 90       	pop	r12
    54d6:	bf 90       	pop	r11
    54d8:	af 90       	pop	r10
    54da:	9f 90       	pop	r9
    54dc:	8f 90       	pop	r8
    54de:	7f 90       	pop	r7
    54e0:	6f 90       	pop	r6
    54e2:	5f 90       	pop	r5
    54e4:	4f 90       	pop	r4
    54e6:	3f 90       	pop	r3
    54e8:	2f 90       	pop	r2
    54ea:	1f 90       	pop	r1
    54ec:	0f 90       	pop	r0
    54ee:	0f be       	out	0x3f, r0	; 63
    54f0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    54f2:	08 95       	ret

000054f4 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    54f4:	df 93       	push	r29
    54f6:	cf 93       	push	r28
    54f8:	00 d0       	rcall	.+0      	; 0x54fa <prvSetupTimerInterrupt+0x6>
    54fa:	00 d0       	rcall	.+0      	; 0x54fc <prvSetupTimerInterrupt+0x8>
    54fc:	00 d0       	rcall	.+0      	; 0x54fe <prvSetupTimerInterrupt+0xa>
    54fe:	cd b7       	in	r28, 0x3d	; 61
    5500:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    5502:	80 e4       	ldi	r24, 0x40	; 64
    5504:	9f e1       	ldi	r25, 0x1F	; 31
    5506:	a0 e0       	ldi	r26, 0x00	; 0
    5508:	b0 e0       	ldi	r27, 0x00	; 0
    550a:	8b 83       	std	Y+3, r24	; 0x03
    550c:	9c 83       	std	Y+4, r25	; 0x04
    550e:	ad 83       	std	Y+5, r26	; 0x05
    5510:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    5512:	8b 81       	ldd	r24, Y+3	; 0x03
    5514:	9c 81       	ldd	r25, Y+4	; 0x04
    5516:	ad 81       	ldd	r26, Y+5	; 0x05
    5518:	be 81       	ldd	r27, Y+6	; 0x06
    551a:	68 94       	set
    551c:	15 f8       	bld	r1, 5
    551e:	b6 95       	lsr	r27
    5520:	a7 95       	ror	r26
    5522:	97 95       	ror	r25
    5524:	87 95       	ror	r24
    5526:	16 94       	lsr	r1
    5528:	d1 f7       	brne	.-12     	; 0x551e <prvSetupTimerInterrupt+0x2a>
    552a:	8b 83       	std	Y+3, r24	; 0x03
    552c:	9c 83       	std	Y+4, r25	; 0x04
    552e:	ad 83       	std	Y+5, r26	; 0x05
    5530:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    5532:	8b 81       	ldd	r24, Y+3	; 0x03
    5534:	9c 81       	ldd	r25, Y+4	; 0x04
    5536:	ad 81       	ldd	r26, Y+5	; 0x05
    5538:	be 81       	ldd	r27, Y+6	; 0x06
    553a:	01 97       	sbiw	r24, 0x01	; 1
    553c:	a1 09       	sbc	r26, r1
    553e:	b1 09       	sbc	r27, r1
    5540:	8b 83       	std	Y+3, r24	; 0x03
    5542:	9c 83       	std	Y+4, r25	; 0x04
    5544:	ad 83       	std	Y+5, r26	; 0x05
    5546:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    5548:	8b 81       	ldd	r24, Y+3	; 0x03
    554a:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    554c:	8b 81       	ldd	r24, Y+3	; 0x03
    554e:	9c 81       	ldd	r25, Y+4	; 0x04
    5550:	ad 81       	ldd	r26, Y+5	; 0x05
    5552:	be 81       	ldd	r27, Y+6	; 0x06
    5554:	89 2f       	mov	r24, r25
    5556:	9a 2f       	mov	r25, r26
    5558:	ab 2f       	mov	r26, r27
    555a:	bb 27       	eor	r27, r27
    555c:	8b 83       	std	Y+3, r24	; 0x03
    555e:	9c 83       	std	Y+4, r25	; 0x04
    5560:	ad 83       	std	Y+5, r26	; 0x05
    5562:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    5564:	8b 81       	ldd	r24, Y+3	; 0x03
    5566:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    5568:	eb e4       	ldi	r30, 0x4B	; 75
    556a:	f0 e0       	ldi	r31, 0x00	; 0
    556c:	8a 81       	ldd	r24, Y+2	; 0x02
    556e:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    5570:	ea e4       	ldi	r30, 0x4A	; 74
    5572:	f0 e0       	ldi	r31, 0x00	; 0
    5574:	89 81       	ldd	r24, Y+1	; 0x01
    5576:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    5578:	8b e0       	ldi	r24, 0x0B	; 11
    557a:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    557c:	ee e4       	ldi	r30, 0x4E	; 78
    557e:	f0 e0       	ldi	r31, 0x00	; 0
    5580:	89 81       	ldd	r24, Y+1	; 0x01
    5582:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    5584:	e9 e5       	ldi	r30, 0x59	; 89
    5586:	f0 e0       	ldi	r31, 0x00	; 0
    5588:	80 81       	ld	r24, Z
    558a:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    558c:	89 81       	ldd	r24, Y+1	; 0x01
    558e:	80 61       	ori	r24, 0x10	; 16
    5590:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    5592:	e9 e5       	ldi	r30, 0x59	; 89
    5594:	f0 e0       	ldi	r31, 0x00	; 0
    5596:	89 81       	ldd	r24, Y+1	; 0x01
    5598:	80 83       	st	Z, r24
}
    559a:	26 96       	adiw	r28, 0x06	; 6
    559c:	0f b6       	in	r0, 0x3f	; 63
    559e:	f8 94       	cli
    55a0:	de bf       	out	0x3e, r29	; 62
    55a2:	0f be       	out	0x3f, r0	; 63
    55a4:	cd bf       	out	0x3d, r28	; 61
    55a6:	cf 91       	pop	r28
    55a8:	df 91       	pop	r29
    55aa:	08 95       	ret

000055ac <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    55ac:	0e 94 1d 2a 	call	0x543a	; 0x543a <vPortYieldFromTick>
		asm volatile ( "reti" );
    55b0:	18 95       	reti

000055b2 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    55b2:	df 93       	push	r29
    55b4:	cf 93       	push	r28
    55b6:	00 d0       	rcall	.+0      	; 0x55b8 <xQueueGenericReset+0x6>
    55b8:	00 d0       	rcall	.+0      	; 0x55ba <xQueueGenericReset+0x8>
    55ba:	0f 92       	push	r0
    55bc:	cd b7       	in	r28, 0x3d	; 61
    55be:	de b7       	in	r29, 0x3e	; 62
    55c0:	9c 83       	std	Y+4, r25	; 0x04
    55c2:	8b 83       	std	Y+3, r24	; 0x03
    55c4:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    55c6:	8b 81       	ldd	r24, Y+3	; 0x03
    55c8:	9c 81       	ldd	r25, Y+4	; 0x04
    55ca:	9a 83       	std	Y+2, r25	; 0x02
    55cc:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    55ce:	0f b6       	in	r0, 0x3f	; 63
    55d0:	f8 94       	cli
    55d2:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    55d4:	e9 81       	ldd	r30, Y+1	; 0x01
    55d6:	fa 81       	ldd	r31, Y+2	; 0x02
    55d8:	40 81       	ld	r20, Z
    55da:	51 81       	ldd	r21, Z+1	; 0x01
    55dc:	e9 81       	ldd	r30, Y+1	; 0x01
    55de:	fa 81       	ldd	r31, Y+2	; 0x02
    55e0:	83 8d       	ldd	r24, Z+27	; 0x1b
    55e2:	28 2f       	mov	r18, r24
    55e4:	30 e0       	ldi	r19, 0x00	; 0
    55e6:	e9 81       	ldd	r30, Y+1	; 0x01
    55e8:	fa 81       	ldd	r31, Y+2	; 0x02
    55ea:	84 8d       	ldd	r24, Z+28	; 0x1c
    55ec:	88 2f       	mov	r24, r24
    55ee:	90 e0       	ldi	r25, 0x00	; 0
    55f0:	bc 01       	movw	r22, r24
    55f2:	26 9f       	mul	r18, r22
    55f4:	c0 01       	movw	r24, r0
    55f6:	27 9f       	mul	r18, r23
    55f8:	90 0d       	add	r25, r0
    55fa:	36 9f       	mul	r19, r22
    55fc:	90 0d       	add	r25, r0
    55fe:	11 24       	eor	r1, r1
    5600:	84 0f       	add	r24, r20
    5602:	95 1f       	adc	r25, r21
    5604:	e9 81       	ldd	r30, Y+1	; 0x01
    5606:	fa 81       	ldd	r31, Y+2	; 0x02
    5608:	95 83       	std	Z+5, r25	; 0x05
    560a:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    560c:	e9 81       	ldd	r30, Y+1	; 0x01
    560e:	fa 81       	ldd	r31, Y+2	; 0x02
    5610:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    5612:	e9 81       	ldd	r30, Y+1	; 0x01
    5614:	fa 81       	ldd	r31, Y+2	; 0x02
    5616:	80 81       	ld	r24, Z
    5618:	91 81       	ldd	r25, Z+1	; 0x01
    561a:	e9 81       	ldd	r30, Y+1	; 0x01
    561c:	fa 81       	ldd	r31, Y+2	; 0x02
    561e:	93 83       	std	Z+3, r25	; 0x03
    5620:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    5622:	e9 81       	ldd	r30, Y+1	; 0x01
    5624:	fa 81       	ldd	r31, Y+2	; 0x02
    5626:	40 81       	ld	r20, Z
    5628:	51 81       	ldd	r21, Z+1	; 0x01
    562a:	e9 81       	ldd	r30, Y+1	; 0x01
    562c:	fa 81       	ldd	r31, Y+2	; 0x02
    562e:	83 8d       	ldd	r24, Z+27	; 0x1b
    5630:	88 2f       	mov	r24, r24
    5632:	90 e0       	ldi	r25, 0x00	; 0
    5634:	9c 01       	movw	r18, r24
    5636:	21 50       	subi	r18, 0x01	; 1
    5638:	30 40       	sbci	r19, 0x00	; 0
    563a:	e9 81       	ldd	r30, Y+1	; 0x01
    563c:	fa 81       	ldd	r31, Y+2	; 0x02
    563e:	84 8d       	ldd	r24, Z+28	; 0x1c
    5640:	88 2f       	mov	r24, r24
    5642:	90 e0       	ldi	r25, 0x00	; 0
    5644:	bc 01       	movw	r22, r24
    5646:	26 9f       	mul	r18, r22
    5648:	c0 01       	movw	r24, r0
    564a:	27 9f       	mul	r18, r23
    564c:	90 0d       	add	r25, r0
    564e:	36 9f       	mul	r19, r22
    5650:	90 0d       	add	r25, r0
    5652:	11 24       	eor	r1, r1
    5654:	84 0f       	add	r24, r20
    5656:	95 1f       	adc	r25, r21
    5658:	e9 81       	ldd	r30, Y+1	; 0x01
    565a:	fa 81       	ldd	r31, Y+2	; 0x02
    565c:	97 83       	std	Z+7, r25	; 0x07
    565e:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    5660:	e9 81       	ldd	r30, Y+1	; 0x01
    5662:	fa 81       	ldd	r31, Y+2	; 0x02
    5664:	8f ef       	ldi	r24, 0xFF	; 255
    5666:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    5668:	e9 81       	ldd	r30, Y+1	; 0x01
    566a:	fa 81       	ldd	r31, Y+2	; 0x02
    566c:	8f ef       	ldi	r24, 0xFF	; 255
    566e:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    5670:	8d 81       	ldd	r24, Y+5	; 0x05
    5672:	88 23       	and	r24, r24
    5674:	79 f4       	brne	.+30     	; 0x5694 <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5676:	e9 81       	ldd	r30, Y+1	; 0x01
    5678:	fa 81       	ldd	r31, Y+2	; 0x02
    567a:	80 85       	ldd	r24, Z+8	; 0x08
    567c:	88 23       	and	r24, r24
    567e:	a1 f0       	breq	.+40     	; 0x56a8 <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5680:	89 81       	ldd	r24, Y+1	; 0x01
    5682:	9a 81       	ldd	r25, Y+2	; 0x02
    5684:	08 96       	adiw	r24, 0x08	; 8
    5686:	0e 94 ab 37 	call	0x6f56	; 0x6f56 <xTaskRemoveFromEventList>
    568a:	88 23       	and	r24, r24
    568c:	69 f0       	breq	.+26     	; 0x56a8 <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    568e:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
    5692:	0a c0       	rjmp	.+20     	; 0x56a8 <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    5694:	89 81       	ldd	r24, Y+1	; 0x01
    5696:	9a 81       	ldd	r25, Y+2	; 0x02
    5698:	08 96       	adiw	r24, 0x08	; 8
    569a:	0e 94 3a 26 	call	0x4c74	; 0x4c74 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    569e:	89 81       	ldd	r24, Y+1	; 0x01
    56a0:	9a 81       	ldd	r25, Y+2	; 0x02
    56a2:	41 96       	adiw	r24, 0x11	; 17
    56a4:	0e 94 3a 26 	call	0x4c74	; 0x4c74 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    56a8:	0f 90       	pop	r0
    56aa:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    56ac:	81 e0       	ldi	r24, 0x01	; 1
}
    56ae:	0f 90       	pop	r0
    56b0:	0f 90       	pop	r0
    56b2:	0f 90       	pop	r0
    56b4:	0f 90       	pop	r0
    56b6:	0f 90       	pop	r0
    56b8:	cf 91       	pop	r28
    56ba:	df 91       	pop	r29
    56bc:	08 95       	ret

000056be <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    56be:	0f 93       	push	r16
    56c0:	1f 93       	push	r17
    56c2:	df 93       	push	r29
    56c4:	cf 93       	push	r28
    56c6:	cd b7       	in	r28, 0x3d	; 61
    56c8:	de b7       	in	r29, 0x3e	; 62
    56ca:	29 97       	sbiw	r28, 0x09	; 9
    56cc:	0f b6       	in	r0, 0x3f	; 63
    56ce:	f8 94       	cli
    56d0:	de bf       	out	0x3e, r29	; 62
    56d2:	0f be       	out	0x3f, r0	; 63
    56d4:	cd bf       	out	0x3d, r28	; 61
    56d6:	8f 83       	std	Y+7, r24	; 0x07
    56d8:	68 87       	std	Y+8, r22	; 0x08
    56da:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    56dc:	88 85       	ldd	r24, Y+8	; 0x08
    56de:	88 23       	and	r24, r24
    56e0:	19 f4       	brne	.+6      	; 0x56e8 <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    56e2:	1c 82       	std	Y+4, r1	; 0x04
    56e4:	1b 82       	std	Y+3, r1	; 0x03
    56e6:	10 c0       	rjmp	.+32     	; 0x5708 <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    56e8:	8f 81       	ldd	r24, Y+7	; 0x07
    56ea:	28 2f       	mov	r18, r24
    56ec:	30 e0       	ldi	r19, 0x00	; 0
    56ee:	88 85       	ldd	r24, Y+8	; 0x08
    56f0:	88 2f       	mov	r24, r24
    56f2:	90 e0       	ldi	r25, 0x00	; 0
    56f4:	ac 01       	movw	r20, r24
    56f6:	24 9f       	mul	r18, r20
    56f8:	c0 01       	movw	r24, r0
    56fa:	25 9f       	mul	r18, r21
    56fc:	90 0d       	add	r25, r0
    56fe:	34 9f       	mul	r19, r20
    5700:	90 0d       	add	r25, r0
    5702:	11 24       	eor	r1, r1
    5704:	9c 83       	std	Y+4, r25	; 0x04
    5706:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    5708:	8b 81       	ldd	r24, Y+3	; 0x03
    570a:	9c 81       	ldd	r25, Y+4	; 0x04
    570c:	4f 96       	adiw	r24, 0x1f	; 31
    570e:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <pvPortMalloc>
    5712:	9e 83       	std	Y+6, r25	; 0x06
    5714:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    5716:	8d 81       	ldd	r24, Y+5	; 0x05
    5718:	9e 81       	ldd	r25, Y+6	; 0x06
    571a:	00 97       	sbiw	r24, 0x00	; 0
    571c:	a1 f0       	breq	.+40     	; 0x5746 <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    571e:	8d 81       	ldd	r24, Y+5	; 0x05
    5720:	9e 81       	ldd	r25, Y+6	; 0x06
    5722:	9a 83       	std	Y+2, r25	; 0x02
    5724:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    5726:	89 81       	ldd	r24, Y+1	; 0x01
    5728:	9a 81       	ldd	r25, Y+2	; 0x02
    572a:	4f 96       	adiw	r24, 0x1f	; 31
    572c:	9a 83       	std	Y+2, r25	; 0x02
    572e:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    5730:	29 81       	ldd	r18, Y+1	; 0x01
    5732:	3a 81       	ldd	r19, Y+2	; 0x02
    5734:	ed 81       	ldd	r30, Y+5	; 0x05
    5736:	fe 81       	ldd	r31, Y+6	; 0x06
    5738:	8f 81       	ldd	r24, Y+7	; 0x07
    573a:	68 85       	ldd	r22, Y+8	; 0x08
    573c:	a9 01       	movw	r20, r18
    573e:	29 85       	ldd	r18, Y+9	; 0x09
    5740:	8f 01       	movw	r16, r30
    5742:	0e 94 b0 2b 	call	0x5760	; 0x5760 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    5746:	8d 81       	ldd	r24, Y+5	; 0x05
    5748:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    574a:	29 96       	adiw	r28, 0x09	; 9
    574c:	0f b6       	in	r0, 0x3f	; 63
    574e:	f8 94       	cli
    5750:	de bf       	out	0x3e, r29	; 62
    5752:	0f be       	out	0x3f, r0	; 63
    5754:	cd bf       	out	0x3d, r28	; 61
    5756:	cf 91       	pop	r28
    5758:	df 91       	pop	r29
    575a:	1f 91       	pop	r17
    575c:	0f 91       	pop	r16
    575e:	08 95       	ret

00005760 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    5760:	0f 93       	push	r16
    5762:	1f 93       	push	r17
    5764:	df 93       	push	r29
    5766:	cf 93       	push	r28
    5768:	cd b7       	in	r28, 0x3d	; 61
    576a:	de b7       	in	r29, 0x3e	; 62
    576c:	27 97       	sbiw	r28, 0x07	; 7
    576e:	0f b6       	in	r0, 0x3f	; 63
    5770:	f8 94       	cli
    5772:	de bf       	out	0x3e, r29	; 62
    5774:	0f be       	out	0x3f, r0	; 63
    5776:	cd bf       	out	0x3d, r28	; 61
    5778:	89 83       	std	Y+1, r24	; 0x01
    577a:	6a 83       	std	Y+2, r22	; 0x02
    577c:	5c 83       	std	Y+4, r21	; 0x04
    577e:	4b 83       	std	Y+3, r20	; 0x03
    5780:	2d 83       	std	Y+5, r18	; 0x05
    5782:	1f 83       	std	Y+7, r17	; 0x07
    5784:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    5786:	8a 81       	ldd	r24, Y+2	; 0x02
    5788:	88 23       	and	r24, r24
    578a:	39 f4       	brne	.+14     	; 0x579a <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    578c:	8e 81       	ldd	r24, Y+6	; 0x06
    578e:	9f 81       	ldd	r25, Y+7	; 0x07
    5790:	ee 81       	ldd	r30, Y+6	; 0x06
    5792:	ff 81       	ldd	r31, Y+7	; 0x07
    5794:	91 83       	std	Z+1, r25	; 0x01
    5796:	80 83       	st	Z, r24
    5798:	06 c0       	rjmp	.+12     	; 0x57a6 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    579a:	8b 81       	ldd	r24, Y+3	; 0x03
    579c:	9c 81       	ldd	r25, Y+4	; 0x04
    579e:	ee 81       	ldd	r30, Y+6	; 0x06
    57a0:	ff 81       	ldd	r31, Y+7	; 0x07
    57a2:	91 83       	std	Z+1, r25	; 0x01
    57a4:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    57a6:	ee 81       	ldd	r30, Y+6	; 0x06
    57a8:	ff 81       	ldd	r31, Y+7	; 0x07
    57aa:	89 81       	ldd	r24, Y+1	; 0x01
    57ac:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    57ae:	ee 81       	ldd	r30, Y+6	; 0x06
    57b0:	ff 81       	ldd	r31, Y+7	; 0x07
    57b2:	8a 81       	ldd	r24, Y+2	; 0x02
    57b4:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    57b6:	8e 81       	ldd	r24, Y+6	; 0x06
    57b8:	9f 81       	ldd	r25, Y+7	; 0x07
    57ba:	61 e0       	ldi	r22, 0x01	; 1
    57bc:	0e 94 d9 2a 	call	0x55b2	; 0x55b2 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    57c0:	27 96       	adiw	r28, 0x07	; 7
    57c2:	0f b6       	in	r0, 0x3f	; 63
    57c4:	f8 94       	cli
    57c6:	de bf       	out	0x3e, r29	; 62
    57c8:	0f be       	out	0x3f, r0	; 63
    57ca:	cd bf       	out	0x3d, r28	; 61
    57cc:	cf 91       	pop	r28
    57ce:	df 91       	pop	r29
    57d0:	1f 91       	pop	r17
    57d2:	0f 91       	pop	r16
    57d4:	08 95       	ret

000057d6 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
    57d6:	df 93       	push	r29
    57d8:	cf 93       	push	r28
    57da:	00 d0       	rcall	.+0      	; 0x57dc <xQueueCreateCountingSemaphore+0x6>
    57dc:	00 d0       	rcall	.+0      	; 0x57de <xQueueCreateCountingSemaphore+0x8>
    57de:	cd b7       	in	r28, 0x3d	; 61
    57e0:	de b7       	in	r29, 0x3e	; 62
    57e2:	8b 83       	std	Y+3, r24	; 0x03
    57e4:	6c 83       	std	Y+4, r22	; 0x04
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    57e6:	8b 81       	ldd	r24, Y+3	; 0x03
    57e8:	60 e0       	ldi	r22, 0x00	; 0
    57ea:	42 e0       	ldi	r20, 0x02	; 2
    57ec:	0e 94 5f 2b 	call	0x56be	; 0x56be <xQueueGenericCreate>
    57f0:	9a 83       	std	Y+2, r25	; 0x02
    57f2:	89 83       	std	Y+1, r24	; 0x01

		if( xHandle != NULL )
    57f4:	89 81       	ldd	r24, Y+1	; 0x01
    57f6:	9a 81       	ldd	r25, Y+2	; 0x02
    57f8:	00 97       	sbiw	r24, 0x00	; 0
    57fa:	21 f0       	breq	.+8      	; 0x5804 <xQueueCreateCountingSemaphore+0x2e>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    57fc:	e9 81       	ldd	r30, Y+1	; 0x01
    57fe:	fa 81       	ldd	r31, Y+2	; 0x02
    5800:	8c 81       	ldd	r24, Y+4	; 0x04
    5802:	82 8f       	std	Z+26, r24	; 0x1a
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
    5804:	89 81       	ldd	r24, Y+1	; 0x01
    5806:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    5808:	0f 90       	pop	r0
    580a:	0f 90       	pop	r0
    580c:	0f 90       	pop	r0
    580e:	0f 90       	pop	r0
    5810:	cf 91       	pop	r28
    5812:	df 91       	pop	r29
    5814:	08 95       	ret

00005816 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    5816:	df 93       	push	r29
    5818:	cf 93       	push	r28
    581a:	cd b7       	in	r28, 0x3d	; 61
    581c:	de b7       	in	r29, 0x3e	; 62
    581e:	2f 97       	sbiw	r28, 0x0f	; 15
    5820:	0f b6       	in	r0, 0x3f	; 63
    5822:	f8 94       	cli
    5824:	de bf       	out	0x3e, r29	; 62
    5826:	0f be       	out	0x3f, r0	; 63
    5828:	cd bf       	out	0x3d, r28	; 61
    582a:	99 87       	std	Y+9, r25	; 0x09
    582c:	88 87       	std	Y+8, r24	; 0x08
    582e:	7b 87       	std	Y+11, r23	; 0x0b
    5830:	6a 87       	std	Y+10, r22	; 0x0a
    5832:	5d 87       	std	Y+13, r21	; 0x0d
    5834:	4c 87       	std	Y+12, r20	; 0x0c
    5836:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    5838:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    583a:	88 85       	ldd	r24, Y+8	; 0x08
    583c:	99 85       	ldd	r25, Y+9	; 0x09
    583e:	9a 83       	std	Y+2, r25	; 0x02
    5840:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    5842:	0f b6       	in	r0, 0x3f	; 63
    5844:	f8 94       	cli
    5846:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    5848:	e9 81       	ldd	r30, Y+1	; 0x01
    584a:	fa 81       	ldd	r31, Y+2	; 0x02
    584c:	92 8d       	ldd	r25, Z+26	; 0x1a
    584e:	e9 81       	ldd	r30, Y+1	; 0x01
    5850:	fa 81       	ldd	r31, Y+2	; 0x02
    5852:	83 8d       	ldd	r24, Z+27	; 0x1b
    5854:	98 17       	cp	r25, r24
    5856:	18 f0       	brcs	.+6      	; 0x585e <xQueueGenericSend+0x48>
    5858:	8e 85       	ldd	r24, Y+14	; 0x0e
    585a:	82 30       	cpi	r24, 0x02	; 2
    585c:	11 f5       	brne	.+68     	; 0x58a2 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    585e:	89 81       	ldd	r24, Y+1	; 0x01
    5860:	9a 81       	ldd	r25, Y+2	; 0x02
    5862:	2a 85       	ldd	r18, Y+10	; 0x0a
    5864:	3b 85       	ldd	r19, Y+11	; 0x0b
    5866:	b9 01       	movw	r22, r18
    5868:	4e 85       	ldd	r20, Y+14	; 0x0e
    586a:	0e 94 5d 30 	call	0x60ba	; 0x60ba <prvCopyDataToQueue>
    586e:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5870:	e9 81       	ldd	r30, Y+1	; 0x01
    5872:	fa 81       	ldd	r31, Y+2	; 0x02
    5874:	81 89       	ldd	r24, Z+17	; 0x11
    5876:	88 23       	and	r24, r24
    5878:	51 f0       	breq	.+20     	; 0x588e <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    587a:	89 81       	ldd	r24, Y+1	; 0x01
    587c:	9a 81       	ldd	r25, Y+2	; 0x02
    587e:	41 96       	adiw	r24, 0x11	; 17
    5880:	0e 94 ab 37 	call	0x6f56	; 0x6f56 <xTaskRemoveFromEventList>
    5884:	88 23       	and	r24, r24
    5886:	41 f0       	breq	.+16     	; 0x5898 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    5888:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
    588c:	05 c0       	rjmp	.+10     	; 0x5898 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    588e:	8b 81       	ldd	r24, Y+3	; 0x03
    5890:	88 23       	and	r24, r24
    5892:	11 f0       	breq	.+4      	; 0x5898 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    5894:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    5898:	0f 90       	pop	r0
    589a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    589c:	81 e0       	ldi	r24, 0x01	; 1
    589e:	8f 87       	std	Y+15, r24	; 0x0f
    58a0:	5c c0       	rjmp	.+184    	; 0x595a <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    58a2:	8c 85       	ldd	r24, Y+12	; 0x0c
    58a4:	9d 85       	ldd	r25, Y+13	; 0x0d
    58a6:	00 97       	sbiw	r24, 0x00	; 0
    58a8:	21 f4       	brne	.+8      	; 0x58b2 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    58aa:	0f 90       	pop	r0
    58ac:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    58ae:	1f 86       	std	Y+15, r1	; 0x0f
    58b0:	54 c0       	rjmp	.+168    	; 0x595a <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    58b2:	8c 81       	ldd	r24, Y+4	; 0x04
    58b4:	88 23       	and	r24, r24
    58b6:	31 f4       	brne	.+12     	; 0x58c4 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    58b8:	ce 01       	movw	r24, r28
    58ba:	05 96       	adiw	r24, 0x05	; 5
    58bc:	0e 94 91 38 	call	0x7122	; 0x7122 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    58c0:	81 e0       	ldi	r24, 0x01	; 1
    58c2:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    58c4:	0f 90       	pop	r0
    58c6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    58c8:	0e 94 0b 35 	call	0x6a16	; 0x6a16 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    58cc:	0f b6       	in	r0, 0x3f	; 63
    58ce:	f8 94       	cli
    58d0:	0f 92       	push	r0
    58d2:	e9 81       	ldd	r30, Y+1	; 0x01
    58d4:	fa 81       	ldd	r31, Y+2	; 0x02
    58d6:	85 8d       	ldd	r24, Z+29	; 0x1d
    58d8:	8f 3f       	cpi	r24, 0xFF	; 255
    58da:	19 f4       	brne	.+6      	; 0x58e2 <xQueueGenericSend+0xcc>
    58dc:	e9 81       	ldd	r30, Y+1	; 0x01
    58de:	fa 81       	ldd	r31, Y+2	; 0x02
    58e0:	15 8e       	std	Z+29, r1	; 0x1d
    58e2:	e9 81       	ldd	r30, Y+1	; 0x01
    58e4:	fa 81       	ldd	r31, Y+2	; 0x02
    58e6:	86 8d       	ldd	r24, Z+30	; 0x1e
    58e8:	8f 3f       	cpi	r24, 0xFF	; 255
    58ea:	19 f4       	brne	.+6      	; 0x58f2 <xQueueGenericSend+0xdc>
    58ec:	e9 81       	ldd	r30, Y+1	; 0x01
    58ee:	fa 81       	ldd	r31, Y+2	; 0x02
    58f0:	16 8e       	std	Z+30, r1	; 0x1e
    58f2:	0f 90       	pop	r0
    58f4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    58f6:	ce 01       	movw	r24, r28
    58f8:	05 96       	adiw	r24, 0x05	; 5
    58fa:	9e 01       	movw	r18, r28
    58fc:	24 5f       	subi	r18, 0xF4	; 244
    58fe:	3f 4f       	sbci	r19, 0xFF	; 255
    5900:	b9 01       	movw	r22, r18
    5902:	0e 94 aa 38 	call	0x7154	; 0x7154 <xTaskCheckForTimeOut>
    5906:	88 23       	and	r24, r24
    5908:	09 f5       	brne	.+66     	; 0x594c <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    590a:	89 81       	ldd	r24, Y+1	; 0x01
    590c:	9a 81       	ldd	r25, Y+2	; 0x02
    590e:	0e 94 d9 31 	call	0x63b2	; 0x63b2 <prvIsQueueFull>
    5912:	88 23       	and	r24, r24
    5914:	a1 f0       	breq	.+40     	; 0x593e <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    5916:	89 81       	ldd	r24, Y+1	; 0x01
    5918:	9a 81       	ldd	r25, Y+2	; 0x02
    591a:	08 96       	adiw	r24, 0x08	; 8
    591c:	2c 85       	ldd	r18, Y+12	; 0x0c
    591e:	3d 85       	ldd	r19, Y+13	; 0x0d
    5920:	b9 01       	movw	r22, r18
    5922:	0e 94 59 37 	call	0x6eb2	; 0x6eb2 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    5926:	89 81       	ldd	r24, Y+1	; 0x01
    5928:	9a 81       	ldd	r25, Y+2	; 0x02
    592a:	0e 94 4a 31 	call	0x6294	; 0x6294 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    592e:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <xTaskResumeAll>
    5932:	88 23       	and	r24, r24
    5934:	09 f0       	breq	.+2      	; 0x5938 <xQueueGenericSend+0x122>
    5936:	85 cf       	rjmp	.-246    	; 0x5842 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    5938:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
    593c:	82 cf       	rjmp	.-252    	; 0x5842 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    593e:	89 81       	ldd	r24, Y+1	; 0x01
    5940:	9a 81       	ldd	r25, Y+2	; 0x02
    5942:	0e 94 4a 31 	call	0x6294	; 0x6294 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5946:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <xTaskResumeAll>
    594a:	7b cf       	rjmp	.-266    	; 0x5842 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    594c:	89 81       	ldd	r24, Y+1	; 0x01
    594e:	9a 81       	ldd	r25, Y+2	; 0x02
    5950:	0e 94 4a 31 	call	0x6294	; 0x6294 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    5954:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    5958:	1f 86       	std	Y+15, r1	; 0x0f
    595a:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    595c:	2f 96       	adiw	r28, 0x0f	; 15
    595e:	0f b6       	in	r0, 0x3f	; 63
    5960:	f8 94       	cli
    5962:	de bf       	out	0x3e, r29	; 62
    5964:	0f be       	out	0x3f, r0	; 63
    5966:	cd bf       	out	0x3d, r28	; 61
    5968:	cf 91       	pop	r28
    596a:	df 91       	pop	r29
    596c:	08 95       	ret

0000596e <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    596e:	df 93       	push	r29
    5970:	cf 93       	push	r28
    5972:	cd b7       	in	r28, 0x3d	; 61
    5974:	de b7       	in	r29, 0x3e	; 62
    5976:	2c 97       	sbiw	r28, 0x0c	; 12
    5978:	0f b6       	in	r0, 0x3f	; 63
    597a:	f8 94       	cli
    597c:	de bf       	out	0x3e, r29	; 62
    597e:	0f be       	out	0x3f, r0	; 63
    5980:	cd bf       	out	0x3d, r28	; 61
    5982:	9f 83       	std	Y+7, r25	; 0x07
    5984:	8e 83       	std	Y+6, r24	; 0x06
    5986:	79 87       	std	Y+9, r23	; 0x09
    5988:	68 87       	std	Y+8, r22	; 0x08
    598a:	5b 87       	std	Y+11, r21	; 0x0b
    598c:	4a 87       	std	Y+10, r20	; 0x0a
    598e:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    5990:	8e 81       	ldd	r24, Y+6	; 0x06
    5992:	9f 81       	ldd	r25, Y+7	; 0x07
    5994:	9b 83       	std	Y+3, r25	; 0x03
    5996:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5998:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    599a:	ea 81       	ldd	r30, Y+2	; 0x02
    599c:	fb 81       	ldd	r31, Y+3	; 0x03
    599e:	92 8d       	ldd	r25, Z+26	; 0x1a
    59a0:	ea 81       	ldd	r30, Y+2	; 0x02
    59a2:	fb 81       	ldd	r31, Y+3	; 0x03
    59a4:	83 8d       	ldd	r24, Z+27	; 0x1b
    59a6:	98 17       	cp	r25, r24
    59a8:	18 f0       	brcs	.+6      	; 0x59b0 <xQueueGenericSendFromISR+0x42>
    59aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    59ac:	82 30       	cpi	r24, 0x02	; 2
    59ae:	61 f5       	brne	.+88     	; 0x5a08 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    59b0:	ea 81       	ldd	r30, Y+2	; 0x02
    59b2:	fb 81       	ldd	r31, Y+3	; 0x03
    59b4:	86 8d       	ldd	r24, Z+30	; 0x1e
    59b6:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    59b8:	8a 81       	ldd	r24, Y+2	; 0x02
    59ba:	9b 81       	ldd	r25, Y+3	; 0x03
    59bc:	28 85       	ldd	r18, Y+8	; 0x08
    59be:	39 85       	ldd	r19, Y+9	; 0x09
    59c0:	b9 01       	movw	r22, r18
    59c2:	4c 85       	ldd	r20, Y+12	; 0x0c
    59c4:	0e 94 5d 30 	call	0x60ba	; 0x60ba <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    59c8:	89 81       	ldd	r24, Y+1	; 0x01
    59ca:	8f 3f       	cpi	r24, 0xFF	; 255
    59cc:	a9 f4       	brne	.+42     	; 0x59f8 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    59ce:	ea 81       	ldd	r30, Y+2	; 0x02
    59d0:	fb 81       	ldd	r31, Y+3	; 0x03
    59d2:	81 89       	ldd	r24, Z+17	; 0x11
    59d4:	88 23       	and	r24, r24
    59d6:	a9 f0       	breq	.+42     	; 0x5a02 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    59d8:	8a 81       	ldd	r24, Y+2	; 0x02
    59da:	9b 81       	ldd	r25, Y+3	; 0x03
    59dc:	41 96       	adiw	r24, 0x11	; 17
    59de:	0e 94 ab 37 	call	0x6f56	; 0x6f56 <xTaskRemoveFromEventList>
    59e2:	88 23       	and	r24, r24
    59e4:	71 f0       	breq	.+28     	; 0x5a02 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    59e6:	8a 85       	ldd	r24, Y+10	; 0x0a
    59e8:	9b 85       	ldd	r25, Y+11	; 0x0b
    59ea:	00 97       	sbiw	r24, 0x00	; 0
    59ec:	51 f0       	breq	.+20     	; 0x5a02 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    59ee:	ea 85       	ldd	r30, Y+10	; 0x0a
    59f0:	fb 85       	ldd	r31, Y+11	; 0x0b
    59f2:	81 e0       	ldi	r24, 0x01	; 1
    59f4:	80 83       	st	Z, r24
    59f6:	05 c0       	rjmp	.+10     	; 0x5a02 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    59f8:	89 81       	ldd	r24, Y+1	; 0x01
    59fa:	8f 5f       	subi	r24, 0xFF	; 255
    59fc:	ea 81       	ldd	r30, Y+2	; 0x02
    59fe:	fb 81       	ldd	r31, Y+3	; 0x03
    5a00:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    5a02:	81 e0       	ldi	r24, 0x01	; 1
    5a04:	8d 83       	std	Y+5, r24	; 0x05
    5a06:	01 c0       	rjmp	.+2      	; 0x5a0a <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    5a08:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5a0a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    5a0c:	2c 96       	adiw	r28, 0x0c	; 12
    5a0e:	0f b6       	in	r0, 0x3f	; 63
    5a10:	f8 94       	cli
    5a12:	de bf       	out	0x3e, r29	; 62
    5a14:	0f be       	out	0x3f, r0	; 63
    5a16:	cd bf       	out	0x3d, r28	; 61
    5a18:	cf 91       	pop	r28
    5a1a:	df 91       	pop	r29
    5a1c:	08 95       	ret

00005a1e <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    5a1e:	df 93       	push	r29
    5a20:	cf 93       	push	r28
    5a22:	cd b7       	in	r28, 0x3d	; 61
    5a24:	de b7       	in	r29, 0x3e	; 62
    5a26:	2a 97       	sbiw	r28, 0x0a	; 10
    5a28:	0f b6       	in	r0, 0x3f	; 63
    5a2a:	f8 94       	cli
    5a2c:	de bf       	out	0x3e, r29	; 62
    5a2e:	0f be       	out	0x3f, r0	; 63
    5a30:	cd bf       	out	0x3d, r28	; 61
    5a32:	98 87       	std	Y+8, r25	; 0x08
    5a34:	8f 83       	std	Y+7, r24	; 0x07
    5a36:	7a 87       	std	Y+10, r23	; 0x0a
    5a38:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    5a3a:	8f 81       	ldd	r24, Y+7	; 0x07
    5a3c:	98 85       	ldd	r25, Y+8	; 0x08
    5a3e:	9c 83       	std	Y+4, r25	; 0x04
    5a40:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5a42:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    5a44:	eb 81       	ldd	r30, Y+3	; 0x03
    5a46:	fc 81       	ldd	r31, Y+4	; 0x04
    5a48:	82 8d       	ldd	r24, Z+26	; 0x1a
    5a4a:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    5a4c:	eb 81       	ldd	r30, Y+3	; 0x03
    5a4e:	fc 81       	ldd	r31, Y+4	; 0x04
    5a50:	93 8d       	ldd	r25, Z+27	; 0x1b
    5a52:	8a 81       	ldd	r24, Y+2	; 0x02
    5a54:	89 17       	cp	r24, r25
    5a56:	48 f5       	brcc	.+82     	; 0x5aaa <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    5a58:	eb 81       	ldd	r30, Y+3	; 0x03
    5a5a:	fc 81       	ldd	r31, Y+4	; 0x04
    5a5c:	86 8d       	ldd	r24, Z+30	; 0x1e
    5a5e:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    5a60:	8a 81       	ldd	r24, Y+2	; 0x02
    5a62:	8f 5f       	subi	r24, 0xFF	; 255
    5a64:	eb 81       	ldd	r30, Y+3	; 0x03
    5a66:	fc 81       	ldd	r31, Y+4	; 0x04
    5a68:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    5a6a:	89 81       	ldd	r24, Y+1	; 0x01
    5a6c:	8f 3f       	cpi	r24, 0xFF	; 255
    5a6e:	a9 f4       	brne	.+42     	; 0x5a9a <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5a70:	eb 81       	ldd	r30, Y+3	; 0x03
    5a72:	fc 81       	ldd	r31, Y+4	; 0x04
    5a74:	81 89       	ldd	r24, Z+17	; 0x11
    5a76:	88 23       	and	r24, r24
    5a78:	a9 f0       	breq	.+42     	; 0x5aa4 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5a7a:	8b 81       	ldd	r24, Y+3	; 0x03
    5a7c:	9c 81       	ldd	r25, Y+4	; 0x04
    5a7e:	41 96       	adiw	r24, 0x11	; 17
    5a80:	0e 94 ab 37 	call	0x6f56	; 0x6f56 <xTaskRemoveFromEventList>
    5a84:	88 23       	and	r24, r24
    5a86:	71 f0       	breq	.+28     	; 0x5aa4 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    5a88:	89 85       	ldd	r24, Y+9	; 0x09
    5a8a:	9a 85       	ldd	r25, Y+10	; 0x0a
    5a8c:	00 97       	sbiw	r24, 0x00	; 0
    5a8e:	51 f0       	breq	.+20     	; 0x5aa4 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    5a90:	e9 85       	ldd	r30, Y+9	; 0x09
    5a92:	fa 85       	ldd	r31, Y+10	; 0x0a
    5a94:	81 e0       	ldi	r24, 0x01	; 1
    5a96:	80 83       	st	Z, r24
    5a98:	05 c0       	rjmp	.+10     	; 0x5aa4 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    5a9a:	89 81       	ldd	r24, Y+1	; 0x01
    5a9c:	8f 5f       	subi	r24, 0xFF	; 255
    5a9e:	eb 81       	ldd	r30, Y+3	; 0x03
    5aa0:	fc 81       	ldd	r31, Y+4	; 0x04
    5aa2:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    5aa4:	81 e0       	ldi	r24, 0x01	; 1
    5aa6:	8e 83       	std	Y+6, r24	; 0x06
    5aa8:	01 c0       	rjmp	.+2      	; 0x5aac <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    5aaa:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5aac:	8e 81       	ldd	r24, Y+6	; 0x06
}
    5aae:	2a 96       	adiw	r28, 0x0a	; 10
    5ab0:	0f b6       	in	r0, 0x3f	; 63
    5ab2:	f8 94       	cli
    5ab4:	de bf       	out	0x3e, r29	; 62
    5ab6:	0f be       	out	0x3f, r0	; 63
    5ab8:	cd bf       	out	0x3d, r28	; 61
    5aba:	cf 91       	pop	r28
    5abc:	df 91       	pop	r29
    5abe:	08 95       	ret

00005ac0 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    5ac0:	df 93       	push	r29
    5ac2:	cf 93       	push	r28
    5ac4:	cd b7       	in	r28, 0x3d	; 61
    5ac6:	de b7       	in	r29, 0x3e	; 62
    5ac8:	2e 97       	sbiw	r28, 0x0e	; 14
    5aca:	0f b6       	in	r0, 0x3f	; 63
    5acc:	f8 94       	cli
    5ace:	de bf       	out	0x3e, r29	; 62
    5ad0:	0f be       	out	0x3f, r0	; 63
    5ad2:	cd bf       	out	0x3d, r28	; 61
    5ad4:	99 87       	std	Y+9, r25	; 0x09
    5ad6:	88 87       	std	Y+8, r24	; 0x08
    5ad8:	7b 87       	std	Y+11, r23	; 0x0b
    5ada:	6a 87       	std	Y+10, r22	; 0x0a
    5adc:	5d 87       	std	Y+13, r21	; 0x0d
    5ade:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    5ae0:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    5ae2:	88 85       	ldd	r24, Y+8	; 0x08
    5ae4:	99 85       	ldd	r25, Y+9	; 0x09
    5ae6:	9b 83       	std	Y+3, r25	; 0x03
    5ae8:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    5aea:	0f b6       	in	r0, 0x3f	; 63
    5aec:	f8 94       	cli
    5aee:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    5af0:	ea 81       	ldd	r30, Y+2	; 0x02
    5af2:	fb 81       	ldd	r31, Y+3	; 0x03
    5af4:	82 8d       	ldd	r24, Z+26	; 0x1a
    5af6:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    5af8:	89 81       	ldd	r24, Y+1	; 0x01
    5afa:	88 23       	and	r24, r24
    5afc:	f9 f0       	breq	.+62     	; 0x5b3c <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    5afe:	8a 81       	ldd	r24, Y+2	; 0x02
    5b00:	9b 81       	ldd	r25, Y+3	; 0x03
    5b02:	2a 85       	ldd	r18, Y+10	; 0x0a
    5b04:	3b 85       	ldd	r19, Y+11	; 0x0b
    5b06:	b9 01       	movw	r22, r18
    5b08:	0e 94 03 31 	call	0x6206	; 0x6206 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    5b0c:	89 81       	ldd	r24, Y+1	; 0x01
    5b0e:	81 50       	subi	r24, 0x01	; 1
    5b10:	ea 81       	ldd	r30, Y+2	; 0x02
    5b12:	fb 81       	ldd	r31, Y+3	; 0x03
    5b14:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5b16:	ea 81       	ldd	r30, Y+2	; 0x02
    5b18:	fb 81       	ldd	r31, Y+3	; 0x03
    5b1a:	80 85       	ldd	r24, Z+8	; 0x08
    5b1c:	88 23       	and	r24, r24
    5b1e:	49 f0       	breq	.+18     	; 0x5b32 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5b20:	8a 81       	ldd	r24, Y+2	; 0x02
    5b22:	9b 81       	ldd	r25, Y+3	; 0x03
    5b24:	08 96       	adiw	r24, 0x08	; 8
    5b26:	0e 94 ab 37 	call	0x6f56	; 0x6f56 <xTaskRemoveFromEventList>
    5b2a:	88 23       	and	r24, r24
    5b2c:	11 f0       	breq	.+4      	; 0x5b32 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    5b2e:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    5b32:	0f 90       	pop	r0
    5b34:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    5b36:	81 e0       	ldi	r24, 0x01	; 1
    5b38:	8e 87       	std	Y+14, r24	; 0x0e
    5b3a:	63 c0       	rjmp	.+198    	; 0x5c02 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    5b3c:	8c 85       	ldd	r24, Y+12	; 0x0c
    5b3e:	9d 85       	ldd	r25, Y+13	; 0x0d
    5b40:	00 97       	sbiw	r24, 0x00	; 0
    5b42:	21 f4       	brne	.+8      	; 0x5b4c <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    5b44:	0f 90       	pop	r0
    5b46:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    5b48:	1e 86       	std	Y+14, r1	; 0x0e
    5b4a:	5b c0       	rjmp	.+182    	; 0x5c02 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    5b4c:	8c 81       	ldd	r24, Y+4	; 0x04
    5b4e:	88 23       	and	r24, r24
    5b50:	31 f4       	brne	.+12     	; 0x5b5e <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    5b52:	ce 01       	movw	r24, r28
    5b54:	05 96       	adiw	r24, 0x05	; 5
    5b56:	0e 94 91 38 	call	0x7122	; 0x7122 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    5b5a:	81 e0       	ldi	r24, 0x01	; 1
    5b5c:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    5b5e:	0f 90       	pop	r0
    5b60:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    5b62:	0e 94 0b 35 	call	0x6a16	; 0x6a16 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5b66:	0f b6       	in	r0, 0x3f	; 63
    5b68:	f8 94       	cli
    5b6a:	0f 92       	push	r0
    5b6c:	ea 81       	ldd	r30, Y+2	; 0x02
    5b6e:	fb 81       	ldd	r31, Y+3	; 0x03
    5b70:	85 8d       	ldd	r24, Z+29	; 0x1d
    5b72:	8f 3f       	cpi	r24, 0xFF	; 255
    5b74:	19 f4       	brne	.+6      	; 0x5b7c <xQueueReceive+0xbc>
    5b76:	ea 81       	ldd	r30, Y+2	; 0x02
    5b78:	fb 81       	ldd	r31, Y+3	; 0x03
    5b7a:	15 8e       	std	Z+29, r1	; 0x1d
    5b7c:	ea 81       	ldd	r30, Y+2	; 0x02
    5b7e:	fb 81       	ldd	r31, Y+3	; 0x03
    5b80:	86 8d       	ldd	r24, Z+30	; 0x1e
    5b82:	8f 3f       	cpi	r24, 0xFF	; 255
    5b84:	19 f4       	brne	.+6      	; 0x5b8c <xQueueReceive+0xcc>
    5b86:	ea 81       	ldd	r30, Y+2	; 0x02
    5b88:	fb 81       	ldd	r31, Y+3	; 0x03
    5b8a:	16 8e       	std	Z+30, r1	; 0x1e
    5b8c:	0f 90       	pop	r0
    5b8e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5b90:	ce 01       	movw	r24, r28
    5b92:	05 96       	adiw	r24, 0x05	; 5
    5b94:	9e 01       	movw	r18, r28
    5b96:	24 5f       	subi	r18, 0xF4	; 244
    5b98:	3f 4f       	sbci	r19, 0xFF	; 255
    5b9a:	b9 01       	movw	r22, r18
    5b9c:	0e 94 aa 38 	call	0x7154	; 0x7154 <xTaskCheckForTimeOut>
    5ba0:	88 23       	and	r24, r24
    5ba2:	09 f5       	brne	.+66     	; 0x5be6 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    5ba4:	8a 81       	ldd	r24, Y+2	; 0x02
    5ba6:	9b 81       	ldd	r25, Y+3	; 0x03
    5ba8:	0e 94 9d 31 	call	0x633a	; 0x633a <prvIsQueueEmpty>
    5bac:	88 23       	and	r24, r24
    5bae:	a1 f0       	breq	.+40     	; 0x5bd8 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    5bb0:	8a 81       	ldd	r24, Y+2	; 0x02
    5bb2:	9b 81       	ldd	r25, Y+3	; 0x03
    5bb4:	41 96       	adiw	r24, 0x11	; 17
    5bb6:	2c 85       	ldd	r18, Y+12	; 0x0c
    5bb8:	3d 85       	ldd	r19, Y+13	; 0x0d
    5bba:	b9 01       	movw	r22, r18
    5bbc:	0e 94 59 37 	call	0x6eb2	; 0x6eb2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    5bc0:	8a 81       	ldd	r24, Y+2	; 0x02
    5bc2:	9b 81       	ldd	r25, Y+3	; 0x03
    5bc4:	0e 94 4a 31 	call	0x6294	; 0x6294 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    5bc8:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <xTaskResumeAll>
    5bcc:	88 23       	and	r24, r24
    5bce:	09 f0       	breq	.+2      	; 0x5bd2 <xQueueReceive+0x112>
    5bd0:	8c cf       	rjmp	.-232    	; 0x5aea <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    5bd2:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
    5bd6:	89 cf       	rjmp	.-238    	; 0x5aea <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    5bd8:	8a 81       	ldd	r24, Y+2	; 0x02
    5bda:	9b 81       	ldd	r25, Y+3	; 0x03
    5bdc:	0e 94 4a 31 	call	0x6294	; 0x6294 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5be0:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <xTaskResumeAll>
    5be4:	82 cf       	rjmp	.-252    	; 0x5aea <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    5be6:	8a 81       	ldd	r24, Y+2	; 0x02
    5be8:	9b 81       	ldd	r25, Y+3	; 0x03
    5bea:	0e 94 4a 31 	call	0x6294	; 0x6294 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    5bee:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    5bf2:	8a 81       	ldd	r24, Y+2	; 0x02
    5bf4:	9b 81       	ldd	r25, Y+3	; 0x03
    5bf6:	0e 94 9d 31 	call	0x633a	; 0x633a <prvIsQueueEmpty>
    5bfa:	88 23       	and	r24, r24
    5bfc:	09 f4       	brne	.+2      	; 0x5c00 <xQueueReceive+0x140>
    5bfe:	75 cf       	rjmp	.-278    	; 0x5aea <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    5c00:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    5c02:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    5c04:	2e 96       	adiw	r28, 0x0e	; 14
    5c06:	0f b6       	in	r0, 0x3f	; 63
    5c08:	f8 94       	cli
    5c0a:	de bf       	out	0x3e, r29	; 62
    5c0c:	0f be       	out	0x3f, r0	; 63
    5c0e:	cd bf       	out	0x3d, r28	; 61
    5c10:	cf 91       	pop	r28
    5c12:	df 91       	pop	r29
    5c14:	08 95       	ret

00005c16 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    5c16:	df 93       	push	r29
    5c18:	cf 93       	push	r28
    5c1a:	cd b7       	in	r28, 0x3d	; 61
    5c1c:	de b7       	in	r29, 0x3e	; 62
    5c1e:	2c 97       	sbiw	r28, 0x0c	; 12
    5c20:	0f b6       	in	r0, 0x3f	; 63
    5c22:	f8 94       	cli
    5c24:	de bf       	out	0x3e, r29	; 62
    5c26:	0f be       	out	0x3f, r0	; 63
    5c28:	cd bf       	out	0x3d, r28	; 61
    5c2a:	99 87       	std	Y+9, r25	; 0x09
    5c2c:	88 87       	std	Y+8, r24	; 0x08
    5c2e:	7b 87       	std	Y+11, r23	; 0x0b
    5c30:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    5c32:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    5c34:	88 85       	ldd	r24, Y+8	; 0x08
    5c36:	99 85       	ldd	r25, Y+9	; 0x09
    5c38:	9b 83       	std	Y+3, r25	; 0x03
    5c3a:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    5c3c:	0f b6       	in	r0, 0x3f	; 63
    5c3e:	f8 94       	cli
    5c40:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    5c42:	ea 81       	ldd	r30, Y+2	; 0x02
    5c44:	fb 81       	ldd	r31, Y+3	; 0x03
    5c46:	82 8d       	ldd	r24, Z+26	; 0x1a
    5c48:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    5c4a:	89 81       	ldd	r24, Y+1	; 0x01
    5c4c:	88 23       	and	r24, r24
    5c4e:	c1 f0       	breq	.+48     	; 0x5c80 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    5c50:	89 81       	ldd	r24, Y+1	; 0x01
    5c52:	81 50       	subi	r24, 0x01	; 1
    5c54:	ea 81       	ldd	r30, Y+2	; 0x02
    5c56:	fb 81       	ldd	r31, Y+3	; 0x03
    5c58:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5c5a:	ea 81       	ldd	r30, Y+2	; 0x02
    5c5c:	fb 81       	ldd	r31, Y+3	; 0x03
    5c5e:	80 85       	ldd	r24, Z+8	; 0x08
    5c60:	88 23       	and	r24, r24
    5c62:	49 f0       	breq	.+18     	; 0x5c76 <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5c64:	8a 81       	ldd	r24, Y+2	; 0x02
    5c66:	9b 81       	ldd	r25, Y+3	; 0x03
    5c68:	08 96       	adiw	r24, 0x08	; 8
    5c6a:	0e 94 ab 37 	call	0x6f56	; 0x6f56 <xTaskRemoveFromEventList>
    5c6e:	88 23       	and	r24, r24
    5c70:	11 f0       	breq	.+4      	; 0x5c76 <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    5c72:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    5c76:	0f 90       	pop	r0
    5c78:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    5c7a:	81 e0       	ldi	r24, 0x01	; 1
    5c7c:	8c 87       	std	Y+12, r24	; 0x0c
    5c7e:	63 c0       	rjmp	.+198    	; 0x5d46 <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    5c80:	8a 85       	ldd	r24, Y+10	; 0x0a
    5c82:	9b 85       	ldd	r25, Y+11	; 0x0b
    5c84:	00 97       	sbiw	r24, 0x00	; 0
    5c86:	21 f4       	brne	.+8      	; 0x5c90 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    5c88:	0f 90       	pop	r0
    5c8a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    5c8c:	1c 86       	std	Y+12, r1	; 0x0c
    5c8e:	5b c0       	rjmp	.+182    	; 0x5d46 <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    5c90:	8c 81       	ldd	r24, Y+4	; 0x04
    5c92:	88 23       	and	r24, r24
    5c94:	31 f4       	brne	.+12     	; 0x5ca2 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    5c96:	ce 01       	movw	r24, r28
    5c98:	05 96       	adiw	r24, 0x05	; 5
    5c9a:	0e 94 91 38 	call	0x7122	; 0x7122 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    5c9e:	81 e0       	ldi	r24, 0x01	; 1
    5ca0:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    5ca2:	0f 90       	pop	r0
    5ca4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    5ca6:	0e 94 0b 35 	call	0x6a16	; 0x6a16 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5caa:	0f b6       	in	r0, 0x3f	; 63
    5cac:	f8 94       	cli
    5cae:	0f 92       	push	r0
    5cb0:	ea 81       	ldd	r30, Y+2	; 0x02
    5cb2:	fb 81       	ldd	r31, Y+3	; 0x03
    5cb4:	85 8d       	ldd	r24, Z+29	; 0x1d
    5cb6:	8f 3f       	cpi	r24, 0xFF	; 255
    5cb8:	19 f4       	brne	.+6      	; 0x5cc0 <xQueueSemaphoreTake+0xaa>
    5cba:	ea 81       	ldd	r30, Y+2	; 0x02
    5cbc:	fb 81       	ldd	r31, Y+3	; 0x03
    5cbe:	15 8e       	std	Z+29, r1	; 0x1d
    5cc0:	ea 81       	ldd	r30, Y+2	; 0x02
    5cc2:	fb 81       	ldd	r31, Y+3	; 0x03
    5cc4:	86 8d       	ldd	r24, Z+30	; 0x1e
    5cc6:	8f 3f       	cpi	r24, 0xFF	; 255
    5cc8:	19 f4       	brne	.+6      	; 0x5cd0 <xQueueSemaphoreTake+0xba>
    5cca:	ea 81       	ldd	r30, Y+2	; 0x02
    5ccc:	fb 81       	ldd	r31, Y+3	; 0x03
    5cce:	16 8e       	std	Z+30, r1	; 0x1e
    5cd0:	0f 90       	pop	r0
    5cd2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5cd4:	ce 01       	movw	r24, r28
    5cd6:	05 96       	adiw	r24, 0x05	; 5
    5cd8:	9e 01       	movw	r18, r28
    5cda:	26 5f       	subi	r18, 0xF6	; 246
    5cdc:	3f 4f       	sbci	r19, 0xFF	; 255
    5cde:	b9 01       	movw	r22, r18
    5ce0:	0e 94 aa 38 	call	0x7154	; 0x7154 <xTaskCheckForTimeOut>
    5ce4:	88 23       	and	r24, r24
    5ce6:	09 f5       	brne	.+66     	; 0x5d2a <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    5ce8:	8a 81       	ldd	r24, Y+2	; 0x02
    5cea:	9b 81       	ldd	r25, Y+3	; 0x03
    5cec:	0e 94 9d 31 	call	0x633a	; 0x633a <prvIsQueueEmpty>
    5cf0:	88 23       	and	r24, r24
    5cf2:	a1 f0       	breq	.+40     	; 0x5d1c <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    5cf4:	8a 81       	ldd	r24, Y+2	; 0x02
    5cf6:	9b 81       	ldd	r25, Y+3	; 0x03
    5cf8:	41 96       	adiw	r24, 0x11	; 17
    5cfa:	2a 85       	ldd	r18, Y+10	; 0x0a
    5cfc:	3b 85       	ldd	r19, Y+11	; 0x0b
    5cfe:	b9 01       	movw	r22, r18
    5d00:	0e 94 59 37 	call	0x6eb2	; 0x6eb2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    5d04:	8a 81       	ldd	r24, Y+2	; 0x02
    5d06:	9b 81       	ldd	r25, Y+3	; 0x03
    5d08:	0e 94 4a 31 	call	0x6294	; 0x6294 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    5d0c:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <xTaskResumeAll>
    5d10:	88 23       	and	r24, r24
    5d12:	09 f0       	breq	.+2      	; 0x5d16 <xQueueSemaphoreTake+0x100>
    5d14:	93 cf       	rjmp	.-218    	; 0x5c3c <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    5d16:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
    5d1a:	90 cf       	rjmp	.-224    	; 0x5c3c <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    5d1c:	8a 81       	ldd	r24, Y+2	; 0x02
    5d1e:	9b 81       	ldd	r25, Y+3	; 0x03
    5d20:	0e 94 4a 31 	call	0x6294	; 0x6294 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5d24:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <xTaskResumeAll>
    5d28:	89 cf       	rjmp	.-238    	; 0x5c3c <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    5d2a:	8a 81       	ldd	r24, Y+2	; 0x02
    5d2c:	9b 81       	ldd	r25, Y+3	; 0x03
    5d2e:	0e 94 4a 31 	call	0x6294	; 0x6294 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    5d32:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    5d36:	8a 81       	ldd	r24, Y+2	; 0x02
    5d38:	9b 81       	ldd	r25, Y+3	; 0x03
    5d3a:	0e 94 9d 31 	call	0x633a	; 0x633a <prvIsQueueEmpty>
    5d3e:	88 23       	and	r24, r24
    5d40:	09 f4       	brne	.+2      	; 0x5d44 <xQueueSemaphoreTake+0x12e>
    5d42:	7c cf       	rjmp	.-264    	; 0x5c3c <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    5d44:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    5d46:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    5d48:	2c 96       	adiw	r28, 0x0c	; 12
    5d4a:	0f b6       	in	r0, 0x3f	; 63
    5d4c:	f8 94       	cli
    5d4e:	de bf       	out	0x3e, r29	; 62
    5d50:	0f be       	out	0x3f, r0	; 63
    5d52:	cd bf       	out	0x3d, r28	; 61
    5d54:	cf 91       	pop	r28
    5d56:	df 91       	pop	r29
    5d58:	08 95       	ret

00005d5a <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    5d5a:	df 93       	push	r29
    5d5c:	cf 93       	push	r28
    5d5e:	cd b7       	in	r28, 0x3d	; 61
    5d60:	de b7       	in	r29, 0x3e	; 62
    5d62:	60 97       	sbiw	r28, 0x10	; 16
    5d64:	0f b6       	in	r0, 0x3f	; 63
    5d66:	f8 94       	cli
    5d68:	de bf       	out	0x3e, r29	; 62
    5d6a:	0f be       	out	0x3f, r0	; 63
    5d6c:	cd bf       	out	0x3d, r28	; 61
    5d6e:	9b 87       	std	Y+11, r25	; 0x0b
    5d70:	8a 87       	std	Y+10, r24	; 0x0a
    5d72:	7d 87       	std	Y+13, r23	; 0x0d
    5d74:	6c 87       	std	Y+12, r22	; 0x0c
    5d76:	5f 87       	std	Y+15, r21	; 0x0f
    5d78:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    5d7a:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    5d7c:	8a 85       	ldd	r24, Y+10	; 0x0a
    5d7e:	9b 85       	ldd	r25, Y+11	; 0x0b
    5d80:	9b 83       	std	Y+3, r25	; 0x03
    5d82:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    5d84:	0f b6       	in	r0, 0x3f	; 63
    5d86:	f8 94       	cli
    5d88:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    5d8a:	ea 81       	ldd	r30, Y+2	; 0x02
    5d8c:	fb 81       	ldd	r31, Y+3	; 0x03
    5d8e:	82 8d       	ldd	r24, Z+26	; 0x1a
    5d90:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    5d92:	89 81       	ldd	r24, Y+1	; 0x01
    5d94:	88 23       	and	r24, r24
    5d96:	31 f1       	breq	.+76     	; 0x5de4 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    5d98:	ea 81       	ldd	r30, Y+2	; 0x02
    5d9a:	fb 81       	ldd	r31, Y+3	; 0x03
    5d9c:	86 81       	ldd	r24, Z+6	; 0x06
    5d9e:	97 81       	ldd	r25, Z+7	; 0x07
    5da0:	9d 83       	std	Y+5, r25	; 0x05
    5da2:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    5da4:	8a 81       	ldd	r24, Y+2	; 0x02
    5da6:	9b 81       	ldd	r25, Y+3	; 0x03
    5da8:	2c 85       	ldd	r18, Y+12	; 0x0c
    5daa:	3d 85       	ldd	r19, Y+13	; 0x0d
    5dac:	b9 01       	movw	r22, r18
    5dae:	0e 94 03 31 	call	0x6206	; 0x6206 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    5db2:	ea 81       	ldd	r30, Y+2	; 0x02
    5db4:	fb 81       	ldd	r31, Y+3	; 0x03
    5db6:	8c 81       	ldd	r24, Y+4	; 0x04
    5db8:	9d 81       	ldd	r25, Y+5	; 0x05
    5dba:	97 83       	std	Z+7, r25	; 0x07
    5dbc:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    5dbe:	ea 81       	ldd	r30, Y+2	; 0x02
    5dc0:	fb 81       	ldd	r31, Y+3	; 0x03
    5dc2:	81 89       	ldd	r24, Z+17	; 0x11
    5dc4:	88 23       	and	r24, r24
    5dc6:	49 f0       	breq	.+18     	; 0x5dda <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    5dc8:	8a 81       	ldd	r24, Y+2	; 0x02
    5dca:	9b 81       	ldd	r25, Y+3	; 0x03
    5dcc:	41 96       	adiw	r24, 0x11	; 17
    5dce:	0e 94 ab 37 	call	0x6f56	; 0x6f56 <xTaskRemoveFromEventList>
    5dd2:	88 23       	and	r24, r24
    5dd4:	11 f0       	breq	.+4      	; 0x5dda <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    5dd6:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    5dda:	0f 90       	pop	r0
    5ddc:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    5dde:	81 e0       	ldi	r24, 0x01	; 1
    5de0:	88 8b       	std	Y+16, r24	; 0x10
    5de2:	63 c0       	rjmp	.+198    	; 0x5eaa <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    5de4:	8e 85       	ldd	r24, Y+14	; 0x0e
    5de6:	9f 85       	ldd	r25, Y+15	; 0x0f
    5de8:	00 97       	sbiw	r24, 0x00	; 0
    5dea:	21 f4       	brne	.+8      	; 0x5df4 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    5dec:	0f 90       	pop	r0
    5dee:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    5df0:	18 8a       	std	Y+16, r1	; 0x10
    5df2:	5b c0       	rjmp	.+182    	; 0x5eaa <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    5df4:	8e 81       	ldd	r24, Y+6	; 0x06
    5df6:	88 23       	and	r24, r24
    5df8:	31 f4       	brne	.+12     	; 0x5e06 <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    5dfa:	ce 01       	movw	r24, r28
    5dfc:	07 96       	adiw	r24, 0x07	; 7
    5dfe:	0e 94 91 38 	call	0x7122	; 0x7122 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    5e02:	81 e0       	ldi	r24, 0x01	; 1
    5e04:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    5e06:	0f 90       	pop	r0
    5e08:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    5e0a:	0e 94 0b 35 	call	0x6a16	; 0x6a16 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    5e0e:	0f b6       	in	r0, 0x3f	; 63
    5e10:	f8 94       	cli
    5e12:	0f 92       	push	r0
    5e14:	ea 81       	ldd	r30, Y+2	; 0x02
    5e16:	fb 81       	ldd	r31, Y+3	; 0x03
    5e18:	85 8d       	ldd	r24, Z+29	; 0x1d
    5e1a:	8f 3f       	cpi	r24, 0xFF	; 255
    5e1c:	19 f4       	brne	.+6      	; 0x5e24 <xQueuePeek+0xca>
    5e1e:	ea 81       	ldd	r30, Y+2	; 0x02
    5e20:	fb 81       	ldd	r31, Y+3	; 0x03
    5e22:	15 8e       	std	Z+29, r1	; 0x1d
    5e24:	ea 81       	ldd	r30, Y+2	; 0x02
    5e26:	fb 81       	ldd	r31, Y+3	; 0x03
    5e28:	86 8d       	ldd	r24, Z+30	; 0x1e
    5e2a:	8f 3f       	cpi	r24, 0xFF	; 255
    5e2c:	19 f4       	brne	.+6      	; 0x5e34 <xQueuePeek+0xda>
    5e2e:	ea 81       	ldd	r30, Y+2	; 0x02
    5e30:	fb 81       	ldd	r31, Y+3	; 0x03
    5e32:	16 8e       	std	Z+30, r1	; 0x1e
    5e34:	0f 90       	pop	r0
    5e36:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    5e38:	ce 01       	movw	r24, r28
    5e3a:	07 96       	adiw	r24, 0x07	; 7
    5e3c:	9e 01       	movw	r18, r28
    5e3e:	22 5f       	subi	r18, 0xF2	; 242
    5e40:	3f 4f       	sbci	r19, 0xFF	; 255
    5e42:	b9 01       	movw	r22, r18
    5e44:	0e 94 aa 38 	call	0x7154	; 0x7154 <xTaskCheckForTimeOut>
    5e48:	88 23       	and	r24, r24
    5e4a:	09 f5       	brne	.+66     	; 0x5e8e <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    5e4c:	8a 81       	ldd	r24, Y+2	; 0x02
    5e4e:	9b 81       	ldd	r25, Y+3	; 0x03
    5e50:	0e 94 9d 31 	call	0x633a	; 0x633a <prvIsQueueEmpty>
    5e54:	88 23       	and	r24, r24
    5e56:	a1 f0       	breq	.+40     	; 0x5e80 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    5e58:	8a 81       	ldd	r24, Y+2	; 0x02
    5e5a:	9b 81       	ldd	r25, Y+3	; 0x03
    5e5c:	41 96       	adiw	r24, 0x11	; 17
    5e5e:	2e 85       	ldd	r18, Y+14	; 0x0e
    5e60:	3f 85       	ldd	r19, Y+15	; 0x0f
    5e62:	b9 01       	movw	r22, r18
    5e64:	0e 94 59 37 	call	0x6eb2	; 0x6eb2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    5e68:	8a 81       	ldd	r24, Y+2	; 0x02
    5e6a:	9b 81       	ldd	r25, Y+3	; 0x03
    5e6c:	0e 94 4a 31 	call	0x6294	; 0x6294 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    5e70:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <xTaskResumeAll>
    5e74:	88 23       	and	r24, r24
    5e76:	09 f0       	breq	.+2      	; 0x5e7a <xQueuePeek+0x120>
    5e78:	85 cf       	rjmp	.-246    	; 0x5d84 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    5e7a:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
    5e7e:	82 cf       	rjmp	.-252    	; 0x5d84 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    5e80:	8a 81       	ldd	r24, Y+2	; 0x02
    5e82:	9b 81       	ldd	r25, Y+3	; 0x03
    5e84:	0e 94 4a 31 	call	0x6294	; 0x6294 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    5e88:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <xTaskResumeAll>
    5e8c:	7b cf       	rjmp	.-266    	; 0x5d84 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    5e8e:	8a 81       	ldd	r24, Y+2	; 0x02
    5e90:	9b 81       	ldd	r25, Y+3	; 0x03
    5e92:	0e 94 4a 31 	call	0x6294	; 0x6294 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    5e96:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    5e9a:	8a 81       	ldd	r24, Y+2	; 0x02
    5e9c:	9b 81       	ldd	r25, Y+3	; 0x03
    5e9e:	0e 94 9d 31 	call	0x633a	; 0x633a <prvIsQueueEmpty>
    5ea2:	88 23       	and	r24, r24
    5ea4:	09 f4       	brne	.+2      	; 0x5ea8 <xQueuePeek+0x14e>
    5ea6:	6e cf       	rjmp	.-292    	; 0x5d84 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    5ea8:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    5eaa:	88 89       	ldd	r24, Y+16	; 0x10
}
    5eac:	60 96       	adiw	r28, 0x10	; 16
    5eae:	0f b6       	in	r0, 0x3f	; 63
    5eb0:	f8 94       	cli
    5eb2:	de bf       	out	0x3e, r29	; 62
    5eb4:	0f be       	out	0x3f, r0	; 63
    5eb6:	cd bf       	out	0x3d, r28	; 61
    5eb8:	cf 91       	pop	r28
    5eba:	df 91       	pop	r29
    5ebc:	08 95       	ret

00005ebe <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    5ebe:	df 93       	push	r29
    5ec0:	cf 93       	push	r28
    5ec2:	cd b7       	in	r28, 0x3d	; 61
    5ec4:	de b7       	in	r29, 0x3e	; 62
    5ec6:	2c 97       	sbiw	r28, 0x0c	; 12
    5ec8:	0f b6       	in	r0, 0x3f	; 63
    5eca:	f8 94       	cli
    5ecc:	de bf       	out	0x3e, r29	; 62
    5ece:	0f be       	out	0x3f, r0	; 63
    5ed0:	cd bf       	out	0x3d, r28	; 61
    5ed2:	98 87       	std	Y+8, r25	; 0x08
    5ed4:	8f 83       	std	Y+7, r24	; 0x07
    5ed6:	7a 87       	std	Y+10, r23	; 0x0a
    5ed8:	69 87       	std	Y+9, r22	; 0x09
    5eda:	5c 87       	std	Y+12, r21	; 0x0c
    5edc:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    5ede:	8f 81       	ldd	r24, Y+7	; 0x07
    5ee0:	98 85       	ldd	r25, Y+8	; 0x08
    5ee2:	9c 83       	std	Y+4, r25	; 0x04
    5ee4:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5ee6:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    5ee8:	eb 81       	ldd	r30, Y+3	; 0x03
    5eea:	fc 81       	ldd	r31, Y+4	; 0x04
    5eec:	82 8d       	ldd	r24, Z+26	; 0x1a
    5eee:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    5ef0:	8a 81       	ldd	r24, Y+2	; 0x02
    5ef2:	88 23       	and	r24, r24
    5ef4:	81 f1       	breq	.+96     	; 0x5f56 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    5ef6:	eb 81       	ldd	r30, Y+3	; 0x03
    5ef8:	fc 81       	ldd	r31, Y+4	; 0x04
    5efa:	85 8d       	ldd	r24, Z+29	; 0x1d
    5efc:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    5efe:	8b 81       	ldd	r24, Y+3	; 0x03
    5f00:	9c 81       	ldd	r25, Y+4	; 0x04
    5f02:	29 85       	ldd	r18, Y+9	; 0x09
    5f04:	3a 85       	ldd	r19, Y+10	; 0x0a
    5f06:	b9 01       	movw	r22, r18
    5f08:	0e 94 03 31 	call	0x6206	; 0x6206 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    5f0c:	8a 81       	ldd	r24, Y+2	; 0x02
    5f0e:	81 50       	subi	r24, 0x01	; 1
    5f10:	eb 81       	ldd	r30, Y+3	; 0x03
    5f12:	fc 81       	ldd	r31, Y+4	; 0x04
    5f14:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    5f16:	89 81       	ldd	r24, Y+1	; 0x01
    5f18:	8f 3f       	cpi	r24, 0xFF	; 255
    5f1a:	a9 f4       	brne	.+42     	; 0x5f46 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    5f1c:	eb 81       	ldd	r30, Y+3	; 0x03
    5f1e:	fc 81       	ldd	r31, Y+4	; 0x04
    5f20:	80 85       	ldd	r24, Z+8	; 0x08
    5f22:	88 23       	and	r24, r24
    5f24:	a9 f0       	breq	.+42     	; 0x5f50 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    5f26:	8b 81       	ldd	r24, Y+3	; 0x03
    5f28:	9c 81       	ldd	r25, Y+4	; 0x04
    5f2a:	08 96       	adiw	r24, 0x08	; 8
    5f2c:	0e 94 ab 37 	call	0x6f56	; 0x6f56 <xTaskRemoveFromEventList>
    5f30:	88 23       	and	r24, r24
    5f32:	71 f0       	breq	.+28     	; 0x5f50 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    5f34:	8b 85       	ldd	r24, Y+11	; 0x0b
    5f36:	9c 85       	ldd	r25, Y+12	; 0x0c
    5f38:	00 97       	sbiw	r24, 0x00	; 0
    5f3a:	51 f0       	breq	.+20     	; 0x5f50 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    5f3c:	eb 85       	ldd	r30, Y+11	; 0x0b
    5f3e:	fc 85       	ldd	r31, Y+12	; 0x0c
    5f40:	81 e0       	ldi	r24, 0x01	; 1
    5f42:	80 83       	st	Z, r24
    5f44:	05 c0       	rjmp	.+10     	; 0x5f50 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    5f46:	89 81       	ldd	r24, Y+1	; 0x01
    5f48:	8f 5f       	subi	r24, 0xFF	; 255
    5f4a:	eb 81       	ldd	r30, Y+3	; 0x03
    5f4c:	fc 81       	ldd	r31, Y+4	; 0x04
    5f4e:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    5f50:	81 e0       	ldi	r24, 0x01	; 1
    5f52:	8e 83       	std	Y+6, r24	; 0x06
    5f54:	01 c0       	rjmp	.+2      	; 0x5f58 <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    5f56:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5f58:	8e 81       	ldd	r24, Y+6	; 0x06
}
    5f5a:	2c 96       	adiw	r28, 0x0c	; 12
    5f5c:	0f b6       	in	r0, 0x3f	; 63
    5f5e:	f8 94       	cli
    5f60:	de bf       	out	0x3e, r29	; 62
    5f62:	0f be       	out	0x3f, r0	; 63
    5f64:	cd bf       	out	0x3d, r28	; 61
    5f66:	cf 91       	pop	r28
    5f68:	df 91       	pop	r29
    5f6a:	08 95       	ret

00005f6c <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    5f6c:	df 93       	push	r29
    5f6e:	cf 93       	push	r28
    5f70:	cd b7       	in	r28, 0x3d	; 61
    5f72:	de b7       	in	r29, 0x3e	; 62
    5f74:	2a 97       	sbiw	r28, 0x0a	; 10
    5f76:	0f b6       	in	r0, 0x3f	; 63
    5f78:	f8 94       	cli
    5f7a:	de bf       	out	0x3e, r29	; 62
    5f7c:	0f be       	out	0x3f, r0	; 63
    5f7e:	cd bf       	out	0x3d, r28	; 61
    5f80:	98 87       	std	Y+8, r25	; 0x08
    5f82:	8f 83       	std	Y+7, r24	; 0x07
    5f84:	7a 87       	std	Y+10, r23	; 0x0a
    5f86:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    5f88:	8f 81       	ldd	r24, Y+7	; 0x07
    5f8a:	98 85       	ldd	r25, Y+8	; 0x08
    5f8c:	9a 83       	std	Y+2, r25	; 0x02
    5f8e:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    5f90:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    5f92:	e9 81       	ldd	r30, Y+1	; 0x01
    5f94:	fa 81       	ldd	r31, Y+2	; 0x02
    5f96:	82 8d       	ldd	r24, Z+26	; 0x1a
    5f98:	88 23       	and	r24, r24
    5f9a:	b1 f0       	breq	.+44     	; 0x5fc8 <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    5f9c:	e9 81       	ldd	r30, Y+1	; 0x01
    5f9e:	fa 81       	ldd	r31, Y+2	; 0x02
    5fa0:	86 81       	ldd	r24, Z+6	; 0x06
    5fa2:	97 81       	ldd	r25, Z+7	; 0x07
    5fa4:	9c 83       	std	Y+4, r25	; 0x04
    5fa6:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    5fa8:	89 81       	ldd	r24, Y+1	; 0x01
    5faa:	9a 81       	ldd	r25, Y+2	; 0x02
    5fac:	29 85       	ldd	r18, Y+9	; 0x09
    5fae:	3a 85       	ldd	r19, Y+10	; 0x0a
    5fb0:	b9 01       	movw	r22, r18
    5fb2:	0e 94 03 31 	call	0x6206	; 0x6206 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    5fb6:	e9 81       	ldd	r30, Y+1	; 0x01
    5fb8:	fa 81       	ldd	r31, Y+2	; 0x02
    5fba:	8b 81       	ldd	r24, Y+3	; 0x03
    5fbc:	9c 81       	ldd	r25, Y+4	; 0x04
    5fbe:	97 83       	std	Z+7, r25	; 0x07
    5fc0:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    5fc2:	81 e0       	ldi	r24, 0x01	; 1
    5fc4:	8e 83       	std	Y+6, r24	; 0x06
    5fc6:	01 c0       	rjmp	.+2      	; 0x5fca <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    5fc8:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    5fca:	8e 81       	ldd	r24, Y+6	; 0x06
}
    5fcc:	2a 96       	adiw	r28, 0x0a	; 10
    5fce:	0f b6       	in	r0, 0x3f	; 63
    5fd0:	f8 94       	cli
    5fd2:	de bf       	out	0x3e, r29	; 62
    5fd4:	0f be       	out	0x3f, r0	; 63
    5fd6:	cd bf       	out	0x3d, r28	; 61
    5fd8:	cf 91       	pop	r28
    5fda:	df 91       	pop	r29
    5fdc:	08 95       	ret

00005fde <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    5fde:	df 93       	push	r29
    5fe0:	cf 93       	push	r28
    5fe2:	00 d0       	rcall	.+0      	; 0x5fe4 <uxQueueMessagesWaiting+0x6>
    5fe4:	0f 92       	push	r0
    5fe6:	cd b7       	in	r28, 0x3d	; 61
    5fe8:	de b7       	in	r29, 0x3e	; 62
    5fea:	9b 83       	std	Y+3, r25	; 0x03
    5fec:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    5fee:	0f b6       	in	r0, 0x3f	; 63
    5ff0:	f8 94       	cli
    5ff2:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    5ff4:	ea 81       	ldd	r30, Y+2	; 0x02
    5ff6:	fb 81       	ldd	r31, Y+3	; 0x03
    5ff8:	82 8d       	ldd	r24, Z+26	; 0x1a
    5ffa:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    5ffc:	0f 90       	pop	r0
    5ffe:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    6000:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    6002:	0f 90       	pop	r0
    6004:	0f 90       	pop	r0
    6006:	0f 90       	pop	r0
    6008:	cf 91       	pop	r28
    600a:	df 91       	pop	r29
    600c:	08 95       	ret

0000600e <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    600e:	df 93       	push	r29
    6010:	cf 93       	push	r28
    6012:	00 d0       	rcall	.+0      	; 0x6014 <uxQueueSpacesAvailable+0x6>
    6014:	00 d0       	rcall	.+0      	; 0x6016 <uxQueueSpacesAvailable+0x8>
    6016:	0f 92       	push	r0
    6018:	cd b7       	in	r28, 0x3d	; 61
    601a:	de b7       	in	r29, 0x3e	; 62
    601c:	9d 83       	std	Y+5, r25	; 0x05
    601e:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    6020:	8c 81       	ldd	r24, Y+4	; 0x04
    6022:	9d 81       	ldd	r25, Y+5	; 0x05
    6024:	9a 83       	std	Y+2, r25	; 0x02
    6026:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    6028:	0f b6       	in	r0, 0x3f	; 63
    602a:	f8 94       	cli
    602c:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    602e:	e9 81       	ldd	r30, Y+1	; 0x01
    6030:	fa 81       	ldd	r31, Y+2	; 0x02
    6032:	93 8d       	ldd	r25, Z+27	; 0x1b
    6034:	e9 81       	ldd	r30, Y+1	; 0x01
    6036:	fa 81       	ldd	r31, Y+2	; 0x02
    6038:	82 8d       	ldd	r24, Z+26	; 0x1a
    603a:	29 2f       	mov	r18, r25
    603c:	28 1b       	sub	r18, r24
    603e:	82 2f       	mov	r24, r18
    6040:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    6042:	0f 90       	pop	r0
    6044:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    6046:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    6048:	0f 90       	pop	r0
    604a:	0f 90       	pop	r0
    604c:	0f 90       	pop	r0
    604e:	0f 90       	pop	r0
    6050:	0f 90       	pop	r0
    6052:	cf 91       	pop	r28
    6054:	df 91       	pop	r29
    6056:	08 95       	ret

00006058 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    6058:	df 93       	push	r29
    605a:	cf 93       	push	r28
    605c:	00 d0       	rcall	.+0      	; 0x605e <uxQueueMessagesWaitingFromISR+0x6>
    605e:	00 d0       	rcall	.+0      	; 0x6060 <uxQueueMessagesWaitingFromISR+0x8>
    6060:	0f 92       	push	r0
    6062:	cd b7       	in	r28, 0x3d	; 61
    6064:	de b7       	in	r29, 0x3e	; 62
    6066:	9d 83       	std	Y+5, r25	; 0x05
    6068:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    606a:	8c 81       	ldd	r24, Y+4	; 0x04
    606c:	9d 81       	ldd	r25, Y+5	; 0x05
    606e:	9a 83       	std	Y+2, r25	; 0x02
    6070:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    6072:	e9 81       	ldd	r30, Y+1	; 0x01
    6074:	fa 81       	ldd	r31, Y+2	; 0x02
    6076:	82 8d       	ldd	r24, Z+26	; 0x1a
    6078:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    607a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    607c:	0f 90       	pop	r0
    607e:	0f 90       	pop	r0
    6080:	0f 90       	pop	r0
    6082:	0f 90       	pop	r0
    6084:	0f 90       	pop	r0
    6086:	cf 91       	pop	r28
    6088:	df 91       	pop	r29
    608a:	08 95       	ret

0000608c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    608c:	df 93       	push	r29
    608e:	cf 93       	push	r28
    6090:	00 d0       	rcall	.+0      	; 0x6092 <vQueueDelete+0x6>
    6092:	00 d0       	rcall	.+0      	; 0x6094 <vQueueDelete+0x8>
    6094:	cd b7       	in	r28, 0x3d	; 61
    6096:	de b7       	in	r29, 0x3e	; 62
    6098:	9c 83       	std	Y+4, r25	; 0x04
    609a:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    609c:	8b 81       	ldd	r24, Y+3	; 0x03
    609e:	9c 81       	ldd	r25, Y+4	; 0x04
    60a0:	9a 83       	std	Y+2, r25	; 0x02
    60a2:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    60a4:	89 81       	ldd	r24, Y+1	; 0x01
    60a6:	9a 81       	ldd	r25, Y+2	; 0x02
    60a8:	0e 94 14 26 	call	0x4c28	; 0x4c28 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    60ac:	0f 90       	pop	r0
    60ae:	0f 90       	pop	r0
    60b0:	0f 90       	pop	r0
    60b2:	0f 90       	pop	r0
    60b4:	cf 91       	pop	r28
    60b6:	df 91       	pop	r29
    60b8:	08 95       	ret

000060ba <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    60ba:	df 93       	push	r29
    60bc:	cf 93       	push	r28
    60be:	cd b7       	in	r28, 0x3d	; 61
    60c0:	de b7       	in	r29, 0x3e	; 62
    60c2:	27 97       	sbiw	r28, 0x07	; 7
    60c4:	0f b6       	in	r0, 0x3f	; 63
    60c6:	f8 94       	cli
    60c8:	de bf       	out	0x3e, r29	; 62
    60ca:	0f be       	out	0x3f, r0	; 63
    60cc:	cd bf       	out	0x3d, r28	; 61
    60ce:	9c 83       	std	Y+4, r25	; 0x04
    60d0:	8b 83       	std	Y+3, r24	; 0x03
    60d2:	7e 83       	std	Y+6, r23	; 0x06
    60d4:	6d 83       	std	Y+5, r22	; 0x05
    60d6:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    60d8:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    60da:	eb 81       	ldd	r30, Y+3	; 0x03
    60dc:	fc 81       	ldd	r31, Y+4	; 0x04
    60de:	82 8d       	ldd	r24, Z+26	; 0x1a
    60e0:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    60e2:	eb 81       	ldd	r30, Y+3	; 0x03
    60e4:	fc 81       	ldd	r31, Y+4	; 0x04
    60e6:	84 8d       	ldd	r24, Z+28	; 0x1c
    60e8:	88 23       	and	r24, r24
    60ea:	09 f4       	brne	.+2      	; 0x60ee <prvCopyDataToQueue+0x34>
    60ec:	7d c0       	rjmp	.+250    	; 0x61e8 <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    60ee:	8f 81       	ldd	r24, Y+7	; 0x07
    60f0:	88 23       	and	r24, r24
    60f2:	99 f5       	brne	.+102    	; 0x615a <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    60f4:	eb 81       	ldd	r30, Y+3	; 0x03
    60f6:	fc 81       	ldd	r31, Y+4	; 0x04
    60f8:	62 81       	ldd	r22, Z+2	; 0x02
    60fa:	73 81       	ldd	r23, Z+3	; 0x03
    60fc:	eb 81       	ldd	r30, Y+3	; 0x03
    60fe:	fc 81       	ldd	r31, Y+4	; 0x04
    6100:	84 8d       	ldd	r24, Z+28	; 0x1c
    6102:	48 2f       	mov	r20, r24
    6104:	50 e0       	ldi	r21, 0x00	; 0
    6106:	2d 81       	ldd	r18, Y+5	; 0x05
    6108:	3e 81       	ldd	r19, Y+6	; 0x06
    610a:	cb 01       	movw	r24, r22
    610c:	b9 01       	movw	r22, r18
    610e:	0e 94 96 3e 	call	0x7d2c	; 0x7d2c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    6112:	eb 81       	ldd	r30, Y+3	; 0x03
    6114:	fc 81       	ldd	r31, Y+4	; 0x04
    6116:	22 81       	ldd	r18, Z+2	; 0x02
    6118:	33 81       	ldd	r19, Z+3	; 0x03
    611a:	eb 81       	ldd	r30, Y+3	; 0x03
    611c:	fc 81       	ldd	r31, Y+4	; 0x04
    611e:	84 8d       	ldd	r24, Z+28	; 0x1c
    6120:	88 2f       	mov	r24, r24
    6122:	90 e0       	ldi	r25, 0x00	; 0
    6124:	82 0f       	add	r24, r18
    6126:	93 1f       	adc	r25, r19
    6128:	eb 81       	ldd	r30, Y+3	; 0x03
    612a:	fc 81       	ldd	r31, Y+4	; 0x04
    612c:	93 83       	std	Z+3, r25	; 0x03
    612e:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    6130:	eb 81       	ldd	r30, Y+3	; 0x03
    6132:	fc 81       	ldd	r31, Y+4	; 0x04
    6134:	22 81       	ldd	r18, Z+2	; 0x02
    6136:	33 81       	ldd	r19, Z+3	; 0x03
    6138:	eb 81       	ldd	r30, Y+3	; 0x03
    613a:	fc 81       	ldd	r31, Y+4	; 0x04
    613c:	84 81       	ldd	r24, Z+4	; 0x04
    613e:	95 81       	ldd	r25, Z+5	; 0x05
    6140:	28 17       	cp	r18, r24
    6142:	39 07       	cpc	r19, r25
    6144:	08 f4       	brcc	.+2      	; 0x6148 <prvCopyDataToQueue+0x8e>
    6146:	50 c0       	rjmp	.+160    	; 0x61e8 <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    6148:	eb 81       	ldd	r30, Y+3	; 0x03
    614a:	fc 81       	ldd	r31, Y+4	; 0x04
    614c:	80 81       	ld	r24, Z
    614e:	91 81       	ldd	r25, Z+1	; 0x01
    6150:	eb 81       	ldd	r30, Y+3	; 0x03
    6152:	fc 81       	ldd	r31, Y+4	; 0x04
    6154:	93 83       	std	Z+3, r25	; 0x03
    6156:	82 83       	std	Z+2, r24	; 0x02
    6158:	47 c0       	rjmp	.+142    	; 0x61e8 <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    615a:	eb 81       	ldd	r30, Y+3	; 0x03
    615c:	fc 81       	ldd	r31, Y+4	; 0x04
    615e:	66 81       	ldd	r22, Z+6	; 0x06
    6160:	77 81       	ldd	r23, Z+7	; 0x07
    6162:	eb 81       	ldd	r30, Y+3	; 0x03
    6164:	fc 81       	ldd	r31, Y+4	; 0x04
    6166:	84 8d       	ldd	r24, Z+28	; 0x1c
    6168:	48 2f       	mov	r20, r24
    616a:	50 e0       	ldi	r21, 0x00	; 0
    616c:	2d 81       	ldd	r18, Y+5	; 0x05
    616e:	3e 81       	ldd	r19, Y+6	; 0x06
    6170:	cb 01       	movw	r24, r22
    6172:	b9 01       	movw	r22, r18
    6174:	0e 94 96 3e 	call	0x7d2c	; 0x7d2c <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    6178:	eb 81       	ldd	r30, Y+3	; 0x03
    617a:	fc 81       	ldd	r31, Y+4	; 0x04
    617c:	26 81       	ldd	r18, Z+6	; 0x06
    617e:	37 81       	ldd	r19, Z+7	; 0x07
    6180:	eb 81       	ldd	r30, Y+3	; 0x03
    6182:	fc 81       	ldd	r31, Y+4	; 0x04
    6184:	84 8d       	ldd	r24, Z+28	; 0x1c
    6186:	88 2f       	mov	r24, r24
    6188:	90 e0       	ldi	r25, 0x00	; 0
    618a:	90 95       	com	r25
    618c:	81 95       	neg	r24
    618e:	9f 4f       	sbci	r25, 0xFF	; 255
    6190:	82 0f       	add	r24, r18
    6192:	93 1f       	adc	r25, r19
    6194:	eb 81       	ldd	r30, Y+3	; 0x03
    6196:	fc 81       	ldd	r31, Y+4	; 0x04
    6198:	97 83       	std	Z+7, r25	; 0x07
    619a:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    619c:	eb 81       	ldd	r30, Y+3	; 0x03
    619e:	fc 81       	ldd	r31, Y+4	; 0x04
    61a0:	26 81       	ldd	r18, Z+6	; 0x06
    61a2:	37 81       	ldd	r19, Z+7	; 0x07
    61a4:	eb 81       	ldd	r30, Y+3	; 0x03
    61a6:	fc 81       	ldd	r31, Y+4	; 0x04
    61a8:	80 81       	ld	r24, Z
    61aa:	91 81       	ldd	r25, Z+1	; 0x01
    61ac:	28 17       	cp	r18, r24
    61ae:	39 07       	cpc	r19, r25
    61b0:	90 f4       	brcc	.+36     	; 0x61d6 <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    61b2:	eb 81       	ldd	r30, Y+3	; 0x03
    61b4:	fc 81       	ldd	r31, Y+4	; 0x04
    61b6:	24 81       	ldd	r18, Z+4	; 0x04
    61b8:	35 81       	ldd	r19, Z+5	; 0x05
    61ba:	eb 81       	ldd	r30, Y+3	; 0x03
    61bc:	fc 81       	ldd	r31, Y+4	; 0x04
    61be:	84 8d       	ldd	r24, Z+28	; 0x1c
    61c0:	88 2f       	mov	r24, r24
    61c2:	90 e0       	ldi	r25, 0x00	; 0
    61c4:	90 95       	com	r25
    61c6:	81 95       	neg	r24
    61c8:	9f 4f       	sbci	r25, 0xFF	; 255
    61ca:	82 0f       	add	r24, r18
    61cc:	93 1f       	adc	r25, r19
    61ce:	eb 81       	ldd	r30, Y+3	; 0x03
    61d0:	fc 81       	ldd	r31, Y+4	; 0x04
    61d2:	97 83       	std	Z+7, r25	; 0x07
    61d4:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    61d6:	8f 81       	ldd	r24, Y+7	; 0x07
    61d8:	82 30       	cpi	r24, 0x02	; 2
    61da:	31 f4       	brne	.+12     	; 0x61e8 <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    61dc:	89 81       	ldd	r24, Y+1	; 0x01
    61de:	88 23       	and	r24, r24
    61e0:	19 f0       	breq	.+6      	; 0x61e8 <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    61e2:	89 81       	ldd	r24, Y+1	; 0x01
    61e4:	81 50       	subi	r24, 0x01	; 1
    61e6:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    61e8:	89 81       	ldd	r24, Y+1	; 0x01
    61ea:	8f 5f       	subi	r24, 0xFF	; 255
    61ec:	eb 81       	ldd	r30, Y+3	; 0x03
    61ee:	fc 81       	ldd	r31, Y+4	; 0x04
    61f0:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    61f2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    61f4:	27 96       	adiw	r28, 0x07	; 7
    61f6:	0f b6       	in	r0, 0x3f	; 63
    61f8:	f8 94       	cli
    61fa:	de bf       	out	0x3e, r29	; 62
    61fc:	0f be       	out	0x3f, r0	; 63
    61fe:	cd bf       	out	0x3d, r28	; 61
    6200:	cf 91       	pop	r28
    6202:	df 91       	pop	r29
    6204:	08 95       	ret

00006206 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    6206:	df 93       	push	r29
    6208:	cf 93       	push	r28
    620a:	00 d0       	rcall	.+0      	; 0x620c <prvCopyDataFromQueue+0x6>
    620c:	00 d0       	rcall	.+0      	; 0x620e <prvCopyDataFromQueue+0x8>
    620e:	cd b7       	in	r28, 0x3d	; 61
    6210:	de b7       	in	r29, 0x3e	; 62
    6212:	9a 83       	std	Y+2, r25	; 0x02
    6214:	89 83       	std	Y+1, r24	; 0x01
    6216:	7c 83       	std	Y+4, r23	; 0x04
    6218:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    621a:	e9 81       	ldd	r30, Y+1	; 0x01
    621c:	fa 81       	ldd	r31, Y+2	; 0x02
    621e:	84 8d       	ldd	r24, Z+28	; 0x1c
    6220:	88 23       	and	r24, r24
    6222:	89 f1       	breq	.+98     	; 0x6286 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    6224:	e9 81       	ldd	r30, Y+1	; 0x01
    6226:	fa 81       	ldd	r31, Y+2	; 0x02
    6228:	26 81       	ldd	r18, Z+6	; 0x06
    622a:	37 81       	ldd	r19, Z+7	; 0x07
    622c:	e9 81       	ldd	r30, Y+1	; 0x01
    622e:	fa 81       	ldd	r31, Y+2	; 0x02
    6230:	84 8d       	ldd	r24, Z+28	; 0x1c
    6232:	88 2f       	mov	r24, r24
    6234:	90 e0       	ldi	r25, 0x00	; 0
    6236:	82 0f       	add	r24, r18
    6238:	93 1f       	adc	r25, r19
    623a:	e9 81       	ldd	r30, Y+1	; 0x01
    623c:	fa 81       	ldd	r31, Y+2	; 0x02
    623e:	97 83       	std	Z+7, r25	; 0x07
    6240:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    6242:	e9 81       	ldd	r30, Y+1	; 0x01
    6244:	fa 81       	ldd	r31, Y+2	; 0x02
    6246:	26 81       	ldd	r18, Z+6	; 0x06
    6248:	37 81       	ldd	r19, Z+7	; 0x07
    624a:	e9 81       	ldd	r30, Y+1	; 0x01
    624c:	fa 81       	ldd	r31, Y+2	; 0x02
    624e:	84 81       	ldd	r24, Z+4	; 0x04
    6250:	95 81       	ldd	r25, Z+5	; 0x05
    6252:	28 17       	cp	r18, r24
    6254:	39 07       	cpc	r19, r25
    6256:	40 f0       	brcs	.+16     	; 0x6268 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    6258:	e9 81       	ldd	r30, Y+1	; 0x01
    625a:	fa 81       	ldd	r31, Y+2	; 0x02
    625c:	80 81       	ld	r24, Z
    625e:	91 81       	ldd	r25, Z+1	; 0x01
    6260:	e9 81       	ldd	r30, Y+1	; 0x01
    6262:	fa 81       	ldd	r31, Y+2	; 0x02
    6264:	97 83       	std	Z+7, r25	; 0x07
    6266:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    6268:	e9 81       	ldd	r30, Y+1	; 0x01
    626a:	fa 81       	ldd	r31, Y+2	; 0x02
    626c:	46 81       	ldd	r20, Z+6	; 0x06
    626e:	57 81       	ldd	r21, Z+7	; 0x07
    6270:	e9 81       	ldd	r30, Y+1	; 0x01
    6272:	fa 81       	ldd	r31, Y+2	; 0x02
    6274:	84 8d       	ldd	r24, Z+28	; 0x1c
    6276:	28 2f       	mov	r18, r24
    6278:	30 e0       	ldi	r19, 0x00	; 0
    627a:	8b 81       	ldd	r24, Y+3	; 0x03
    627c:	9c 81       	ldd	r25, Y+4	; 0x04
    627e:	ba 01       	movw	r22, r20
    6280:	a9 01       	movw	r20, r18
    6282:	0e 94 96 3e 	call	0x7d2c	; 0x7d2c <memcpy>
	}
}
    6286:	0f 90       	pop	r0
    6288:	0f 90       	pop	r0
    628a:	0f 90       	pop	r0
    628c:	0f 90       	pop	r0
    628e:	cf 91       	pop	r28
    6290:	df 91       	pop	r29
    6292:	08 95       	ret

00006294 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    6294:	df 93       	push	r29
    6296:	cf 93       	push	r28
    6298:	00 d0       	rcall	.+0      	; 0x629a <prvUnlockQueue+0x6>
    629a:	00 d0       	rcall	.+0      	; 0x629c <prvUnlockQueue+0x8>
    629c:	cd b7       	in	r28, 0x3d	; 61
    629e:	de b7       	in	r29, 0x3e	; 62
    62a0:	9c 83       	std	Y+4, r25	; 0x04
    62a2:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    62a4:	0f b6       	in	r0, 0x3f	; 63
    62a6:	f8 94       	cli
    62a8:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    62aa:	eb 81       	ldd	r30, Y+3	; 0x03
    62ac:	fc 81       	ldd	r31, Y+4	; 0x04
    62ae:	86 8d       	ldd	r24, Z+30	; 0x1e
    62b0:	8a 83       	std	Y+2, r24	; 0x02
    62b2:	11 c0       	rjmp	.+34     	; 0x62d6 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    62b4:	eb 81       	ldd	r30, Y+3	; 0x03
    62b6:	fc 81       	ldd	r31, Y+4	; 0x04
    62b8:	81 89       	ldd	r24, Z+17	; 0x11
    62ba:	88 23       	and	r24, r24
    62bc:	79 f0       	breq	.+30     	; 0x62dc <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    62be:	8b 81       	ldd	r24, Y+3	; 0x03
    62c0:	9c 81       	ldd	r25, Y+4	; 0x04
    62c2:	41 96       	adiw	r24, 0x11	; 17
    62c4:	0e 94 ab 37 	call	0x6f56	; 0x6f56 <xTaskRemoveFromEventList>
    62c8:	88 23       	and	r24, r24
    62ca:	11 f0       	breq	.+4      	; 0x62d0 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    62cc:	0e 94 0d 39 	call	0x721a	; 0x721a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    62d0:	8a 81       	ldd	r24, Y+2	; 0x02
    62d2:	81 50       	subi	r24, 0x01	; 1
    62d4:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    62d6:	8a 81       	ldd	r24, Y+2	; 0x02
    62d8:	18 16       	cp	r1, r24
    62da:	64 f3       	brlt	.-40     	; 0x62b4 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    62dc:	eb 81       	ldd	r30, Y+3	; 0x03
    62de:	fc 81       	ldd	r31, Y+4	; 0x04
    62e0:	8f ef       	ldi	r24, 0xFF	; 255
    62e2:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    62e4:	0f 90       	pop	r0
    62e6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    62e8:	0f b6       	in	r0, 0x3f	; 63
    62ea:	f8 94       	cli
    62ec:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    62ee:	eb 81       	ldd	r30, Y+3	; 0x03
    62f0:	fc 81       	ldd	r31, Y+4	; 0x04
    62f2:	85 8d       	ldd	r24, Z+29	; 0x1d
    62f4:	89 83       	std	Y+1, r24	; 0x01
    62f6:	11 c0       	rjmp	.+34     	; 0x631a <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    62f8:	eb 81       	ldd	r30, Y+3	; 0x03
    62fa:	fc 81       	ldd	r31, Y+4	; 0x04
    62fc:	80 85       	ldd	r24, Z+8	; 0x08
    62fe:	88 23       	and	r24, r24
    6300:	79 f0       	breq	.+30     	; 0x6320 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    6302:	8b 81       	ldd	r24, Y+3	; 0x03
    6304:	9c 81       	ldd	r25, Y+4	; 0x04
    6306:	08 96       	adiw	r24, 0x08	; 8
    6308:	0e 94 ab 37 	call	0x6f56	; 0x6f56 <xTaskRemoveFromEventList>
    630c:	88 23       	and	r24, r24
    630e:	11 f0       	breq	.+4      	; 0x6314 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    6310:	0e 94 0d 39 	call	0x721a	; 0x721a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    6314:	89 81       	ldd	r24, Y+1	; 0x01
    6316:	81 50       	subi	r24, 0x01	; 1
    6318:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    631a:	89 81       	ldd	r24, Y+1	; 0x01
    631c:	18 16       	cp	r1, r24
    631e:	64 f3       	brlt	.-40     	; 0x62f8 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    6320:	eb 81       	ldd	r30, Y+3	; 0x03
    6322:	fc 81       	ldd	r31, Y+4	; 0x04
    6324:	8f ef       	ldi	r24, 0xFF	; 255
    6326:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    6328:	0f 90       	pop	r0
    632a:	0f be       	out	0x3f, r0	; 63
}
    632c:	0f 90       	pop	r0
    632e:	0f 90       	pop	r0
    6330:	0f 90       	pop	r0
    6332:	0f 90       	pop	r0
    6334:	cf 91       	pop	r28
    6336:	df 91       	pop	r29
    6338:	08 95       	ret

0000633a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    633a:	df 93       	push	r29
    633c:	cf 93       	push	r28
    633e:	00 d0       	rcall	.+0      	; 0x6340 <prvIsQueueEmpty+0x6>
    6340:	0f 92       	push	r0
    6342:	cd b7       	in	r28, 0x3d	; 61
    6344:	de b7       	in	r29, 0x3e	; 62
    6346:	9b 83       	std	Y+3, r25	; 0x03
    6348:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    634a:	0f b6       	in	r0, 0x3f	; 63
    634c:	f8 94       	cli
    634e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    6350:	ea 81       	ldd	r30, Y+2	; 0x02
    6352:	fb 81       	ldd	r31, Y+3	; 0x03
    6354:	82 8d       	ldd	r24, Z+26	; 0x1a
    6356:	88 23       	and	r24, r24
    6358:	19 f4       	brne	.+6      	; 0x6360 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    635a:	81 e0       	ldi	r24, 0x01	; 1
    635c:	89 83       	std	Y+1, r24	; 0x01
    635e:	01 c0       	rjmp	.+2      	; 0x6362 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    6360:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    6362:	0f 90       	pop	r0
    6364:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    6366:	89 81       	ldd	r24, Y+1	; 0x01
}
    6368:	0f 90       	pop	r0
    636a:	0f 90       	pop	r0
    636c:	0f 90       	pop	r0
    636e:	cf 91       	pop	r28
    6370:	df 91       	pop	r29
    6372:	08 95       	ret

00006374 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    6374:	df 93       	push	r29
    6376:	cf 93       	push	r28
    6378:	00 d0       	rcall	.+0      	; 0x637a <xQueueIsQueueEmptyFromISR+0x6>
    637a:	00 d0       	rcall	.+0      	; 0x637c <xQueueIsQueueEmptyFromISR+0x8>
    637c:	0f 92       	push	r0
    637e:	cd b7       	in	r28, 0x3d	; 61
    6380:	de b7       	in	r29, 0x3e	; 62
    6382:	9d 83       	std	Y+5, r25	; 0x05
    6384:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    6386:	8c 81       	ldd	r24, Y+4	; 0x04
    6388:	9d 81       	ldd	r25, Y+5	; 0x05
    638a:	9a 83       	std	Y+2, r25	; 0x02
    638c:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    638e:	e9 81       	ldd	r30, Y+1	; 0x01
    6390:	fa 81       	ldd	r31, Y+2	; 0x02
    6392:	82 8d       	ldd	r24, Z+26	; 0x1a
    6394:	88 23       	and	r24, r24
    6396:	19 f4       	brne	.+6      	; 0x639e <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    6398:	81 e0       	ldi	r24, 0x01	; 1
    639a:	8b 83       	std	Y+3, r24	; 0x03
    639c:	01 c0       	rjmp	.+2      	; 0x63a0 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    639e:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    63a0:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    63a2:	0f 90       	pop	r0
    63a4:	0f 90       	pop	r0
    63a6:	0f 90       	pop	r0
    63a8:	0f 90       	pop	r0
    63aa:	0f 90       	pop	r0
    63ac:	cf 91       	pop	r28
    63ae:	df 91       	pop	r29
    63b0:	08 95       	ret

000063b2 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    63b2:	df 93       	push	r29
    63b4:	cf 93       	push	r28
    63b6:	00 d0       	rcall	.+0      	; 0x63b8 <prvIsQueueFull+0x6>
    63b8:	0f 92       	push	r0
    63ba:	cd b7       	in	r28, 0x3d	; 61
    63bc:	de b7       	in	r29, 0x3e	; 62
    63be:	9b 83       	std	Y+3, r25	; 0x03
    63c0:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    63c2:	0f b6       	in	r0, 0x3f	; 63
    63c4:	f8 94       	cli
    63c6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    63c8:	ea 81       	ldd	r30, Y+2	; 0x02
    63ca:	fb 81       	ldd	r31, Y+3	; 0x03
    63cc:	92 8d       	ldd	r25, Z+26	; 0x1a
    63ce:	ea 81       	ldd	r30, Y+2	; 0x02
    63d0:	fb 81       	ldd	r31, Y+3	; 0x03
    63d2:	83 8d       	ldd	r24, Z+27	; 0x1b
    63d4:	98 17       	cp	r25, r24
    63d6:	19 f4       	brne	.+6      	; 0x63de <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    63d8:	81 e0       	ldi	r24, 0x01	; 1
    63da:	89 83       	std	Y+1, r24	; 0x01
    63dc:	01 c0       	rjmp	.+2      	; 0x63e0 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    63de:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    63e0:	0f 90       	pop	r0
    63e2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    63e4:	89 81       	ldd	r24, Y+1	; 0x01
}
    63e6:	0f 90       	pop	r0
    63e8:	0f 90       	pop	r0
    63ea:	0f 90       	pop	r0
    63ec:	cf 91       	pop	r28
    63ee:	df 91       	pop	r29
    63f0:	08 95       	ret

000063f2 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    63f2:	df 93       	push	r29
    63f4:	cf 93       	push	r28
    63f6:	00 d0       	rcall	.+0      	; 0x63f8 <xQueueIsQueueFullFromISR+0x6>
    63f8:	00 d0       	rcall	.+0      	; 0x63fa <xQueueIsQueueFullFromISR+0x8>
    63fa:	0f 92       	push	r0
    63fc:	cd b7       	in	r28, 0x3d	; 61
    63fe:	de b7       	in	r29, 0x3e	; 62
    6400:	9d 83       	std	Y+5, r25	; 0x05
    6402:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    6404:	8c 81       	ldd	r24, Y+4	; 0x04
    6406:	9d 81       	ldd	r25, Y+5	; 0x05
    6408:	9a 83       	std	Y+2, r25	; 0x02
    640a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    640c:	e9 81       	ldd	r30, Y+1	; 0x01
    640e:	fa 81       	ldd	r31, Y+2	; 0x02
    6410:	92 8d       	ldd	r25, Z+26	; 0x1a
    6412:	e9 81       	ldd	r30, Y+1	; 0x01
    6414:	fa 81       	ldd	r31, Y+2	; 0x02
    6416:	83 8d       	ldd	r24, Z+27	; 0x1b
    6418:	98 17       	cp	r25, r24
    641a:	19 f4       	brne	.+6      	; 0x6422 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    641c:	81 e0       	ldi	r24, 0x01	; 1
    641e:	8b 83       	std	Y+3, r24	; 0x03
    6420:	01 c0       	rjmp	.+2      	; 0x6424 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    6422:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    6424:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    6426:	0f 90       	pop	r0
    6428:	0f 90       	pop	r0
    642a:	0f 90       	pop	r0
    642c:	0f 90       	pop	r0
    642e:	0f 90       	pop	r0
    6430:	cf 91       	pop	r28
    6432:	df 91       	pop	r29
    6434:	08 95       	ret

00006436 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    6436:	8f 92       	push	r8
    6438:	9f 92       	push	r9
    643a:	af 92       	push	r10
    643c:	bf 92       	push	r11
    643e:	cf 92       	push	r12
    6440:	df 92       	push	r13
    6442:	ef 92       	push	r14
    6444:	ff 92       	push	r15
    6446:	0f 93       	push	r16
    6448:	1f 93       	push	r17
    644a:	df 93       	push	r29
    644c:	cf 93       	push	r28
    644e:	cd b7       	in	r28, 0x3d	; 61
    6450:	de b7       	in	r29, 0x3e	; 62
    6452:	60 97       	sbiw	r28, 0x10	; 16
    6454:	0f b6       	in	r0, 0x3f	; 63
    6456:	f8 94       	cli
    6458:	de bf       	out	0x3e, r29	; 62
    645a:	0f be       	out	0x3f, r0	; 63
    645c:	cd bf       	out	0x3d, r28	; 61
    645e:	9f 83       	std	Y+7, r25	; 0x07
    6460:	8e 83       	std	Y+6, r24	; 0x06
    6462:	79 87       	std	Y+9, r23	; 0x09
    6464:	68 87       	std	Y+8, r22	; 0x08
    6466:	5b 87       	std	Y+11, r21	; 0x0b
    6468:	4a 87       	std	Y+10, r20	; 0x0a
    646a:	3d 87       	std	Y+13, r19	; 0x0d
    646c:	2c 87       	std	Y+12, r18	; 0x0c
    646e:	0e 87       	std	Y+14, r16	; 0x0e
    6470:	f8 8a       	std	Y+16, r15	; 0x10
    6472:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    6474:	8a 85       	ldd	r24, Y+10	; 0x0a
    6476:	9b 85       	ldd	r25, Y+11	; 0x0b
    6478:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <pvPortMalloc>
    647c:	9a 83       	std	Y+2, r25	; 0x02
    647e:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    6480:	89 81       	ldd	r24, Y+1	; 0x01
    6482:	9a 81       	ldd	r25, Y+2	; 0x02
    6484:	00 97       	sbiw	r24, 0x00	; 0
    6486:	b1 f0       	breq	.+44     	; 0x64b4 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    6488:	86 e2       	ldi	r24, 0x26	; 38
    648a:	90 e0       	ldi	r25, 0x00	; 0
    648c:	0e 94 be 25 	call	0x4b7c	; 0x4b7c <pvPortMalloc>
    6490:	9d 83       	std	Y+5, r25	; 0x05
    6492:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    6494:	8c 81       	ldd	r24, Y+4	; 0x04
    6496:	9d 81       	ldd	r25, Y+5	; 0x05
    6498:	00 97       	sbiw	r24, 0x00	; 0
    649a:	39 f0       	breq	.+14     	; 0x64aa <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    649c:	ec 81       	ldd	r30, Y+4	; 0x04
    649e:	fd 81       	ldd	r31, Y+5	; 0x05
    64a0:	89 81       	ldd	r24, Y+1	; 0x01
    64a2:	9a 81       	ldd	r25, Y+2	; 0x02
    64a4:	90 8f       	std	Z+24, r25	; 0x18
    64a6:	87 8b       	std	Z+23, r24	; 0x17
    64a8:	07 c0       	rjmp	.+14     	; 0x64b8 <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    64aa:	89 81       	ldd	r24, Y+1	; 0x01
    64ac:	9a 81       	ldd	r25, Y+2	; 0x02
    64ae:	0e 94 14 26 	call	0x4c28	; 0x4c28 <vPortFree>
    64b2:	02 c0       	rjmp	.+4      	; 0x64b8 <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    64b4:	1d 82       	std	Y+5, r1	; 0x05
    64b6:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    64b8:	8c 81       	ldd	r24, Y+4	; 0x04
    64ba:	9d 81       	ldd	r25, Y+5	; 0x05
    64bc:	00 97       	sbiw	r24, 0x00	; 0
    64be:	e9 f0       	breq	.+58     	; 0x64fa <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    64c0:	8a 85       	ldd	r24, Y+10	; 0x0a
    64c2:	9b 85       	ldd	r25, Y+11	; 0x0b
    64c4:	9c 01       	movw	r18, r24
    64c6:	40 e0       	ldi	r20, 0x00	; 0
    64c8:	50 e0       	ldi	r21, 0x00	; 0
    64ca:	8e 81       	ldd	r24, Y+6	; 0x06
    64cc:	9f 81       	ldd	r25, Y+7	; 0x07
    64ce:	68 85       	ldd	r22, Y+8	; 0x08
    64d0:	79 85       	ldd	r23, Y+9	; 0x09
    64d2:	ec 85       	ldd	r30, Y+12	; 0x0c
    64d4:	fd 85       	ldd	r31, Y+13	; 0x0d
    64d6:	af 85       	ldd	r26, Y+15	; 0x0f
    64d8:	b8 89       	ldd	r27, Y+16	; 0x10
    64da:	ac 80       	ldd	r10, Y+4	; 0x04
    64dc:	bd 80       	ldd	r11, Y+5	; 0x05
    64de:	8f 01       	movw	r16, r30
    64e0:	ee 84       	ldd	r14, Y+14	; 0x0e
    64e2:	6d 01       	movw	r12, r26
    64e4:	88 24       	eor	r8, r8
    64e6:	99 24       	eor	r9, r9
    64e8:	0e 94 93 32 	call	0x6526	; 0x6526 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    64ec:	8c 81       	ldd	r24, Y+4	; 0x04
    64ee:	9d 81       	ldd	r25, Y+5	; 0x05
    64f0:	0e 94 4f 33 	call	0x669e	; 0x669e <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    64f4:	81 e0       	ldi	r24, 0x01	; 1
    64f6:	8b 83       	std	Y+3, r24	; 0x03
    64f8:	02 c0       	rjmp	.+4      	; 0x64fe <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    64fa:	8f ef       	ldi	r24, 0xFF	; 255
    64fc:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    64fe:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    6500:	60 96       	adiw	r28, 0x10	; 16
    6502:	0f b6       	in	r0, 0x3f	; 63
    6504:	f8 94       	cli
    6506:	de bf       	out	0x3e, r29	; 62
    6508:	0f be       	out	0x3f, r0	; 63
    650a:	cd bf       	out	0x3d, r28	; 61
    650c:	cf 91       	pop	r28
    650e:	df 91       	pop	r29
    6510:	1f 91       	pop	r17
    6512:	0f 91       	pop	r16
    6514:	ff 90       	pop	r15
    6516:	ef 90       	pop	r14
    6518:	df 90       	pop	r13
    651a:	cf 90       	pop	r12
    651c:	bf 90       	pop	r11
    651e:	af 90       	pop	r10
    6520:	9f 90       	pop	r9
    6522:	8f 90       	pop	r8
    6524:	08 95       	ret

00006526 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    6526:	8f 92       	push	r8
    6528:	9f 92       	push	r9
    652a:	af 92       	push	r10
    652c:	bf 92       	push	r11
    652e:	cf 92       	push	r12
    6530:	df 92       	push	r13
    6532:	ef 92       	push	r14
    6534:	0f 93       	push	r16
    6536:	1f 93       	push	r17
    6538:	df 93       	push	r29
    653a:	cf 93       	push	r28
    653c:	cd b7       	in	r28, 0x3d	; 61
    653e:	de b7       	in	r29, 0x3e	; 62
    6540:	64 97       	sbiw	r28, 0x14	; 20
    6542:	0f b6       	in	r0, 0x3f	; 63
    6544:	f8 94       	cli
    6546:	de bf       	out	0x3e, r29	; 62
    6548:	0f be       	out	0x3f, r0	; 63
    654a:	cd bf       	out	0x3d, r28	; 61
    654c:	9d 83       	std	Y+5, r25	; 0x05
    654e:	8c 83       	std	Y+4, r24	; 0x04
    6550:	7f 83       	std	Y+7, r23	; 0x07
    6552:	6e 83       	std	Y+6, r22	; 0x06
    6554:	28 87       	std	Y+8, r18	; 0x08
    6556:	39 87       	std	Y+9, r19	; 0x09
    6558:	4a 87       	std	Y+10, r20	; 0x0a
    655a:	5b 87       	std	Y+11, r21	; 0x0b
    655c:	1d 87       	std	Y+13, r17	; 0x0d
    655e:	0c 87       	std	Y+12, r16	; 0x0c
    6560:	ee 86       	std	Y+14, r14	; 0x0e
    6562:	d8 8a       	std	Y+16, r13	; 0x10
    6564:	cf 86       	std	Y+15, r12	; 0x0f
    6566:	ba 8a       	std	Y+18, r11	; 0x12
    6568:	a9 8a       	std	Y+17, r10	; 0x11
    656a:	9c 8a       	std	Y+20, r9	; 0x14
    656c:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    656e:	e9 89       	ldd	r30, Y+17	; 0x11
    6570:	fa 89       	ldd	r31, Y+18	; 0x12
    6572:	27 89       	ldd	r18, Z+23	; 0x17
    6574:	30 8d       	ldd	r19, Z+24	; 0x18
    6576:	88 85       	ldd	r24, Y+8	; 0x08
    6578:	99 85       	ldd	r25, Y+9	; 0x09
    657a:	01 97       	sbiw	r24, 0x01	; 1
    657c:	82 0f       	add	r24, r18
    657e:	93 1f       	adc	r25, r19
    6580:	9b 83       	std	Y+3, r25	; 0x03
    6582:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    6584:	8e 81       	ldd	r24, Y+6	; 0x06
    6586:	9f 81       	ldd	r25, Y+7	; 0x07
    6588:	00 97       	sbiw	r24, 0x00	; 0
    658a:	51 f1       	breq	.+84     	; 0x65e0 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    658c:	19 82       	std	Y+1, r1	; 0x01
    658e:	21 c0       	rjmp	.+66     	; 0x65d2 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    6590:	89 81       	ldd	r24, Y+1	; 0x01
    6592:	48 2f       	mov	r20, r24
    6594:	50 e0       	ldi	r21, 0x00	; 0
    6596:	89 81       	ldd	r24, Y+1	; 0x01
    6598:	28 2f       	mov	r18, r24
    659a:	30 e0       	ldi	r19, 0x00	; 0
    659c:	8e 81       	ldd	r24, Y+6	; 0x06
    659e:	9f 81       	ldd	r25, Y+7	; 0x07
    65a0:	fc 01       	movw	r30, r24
    65a2:	e2 0f       	add	r30, r18
    65a4:	f3 1f       	adc	r31, r19
    65a6:	20 81       	ld	r18, Z
    65a8:	89 89       	ldd	r24, Y+17	; 0x11
    65aa:	9a 89       	ldd	r25, Y+18	; 0x12
    65ac:	84 0f       	add	r24, r20
    65ae:	95 1f       	adc	r25, r21
    65b0:	fc 01       	movw	r30, r24
    65b2:	79 96       	adiw	r30, 0x19	; 25
    65b4:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    65b6:	89 81       	ldd	r24, Y+1	; 0x01
    65b8:	28 2f       	mov	r18, r24
    65ba:	30 e0       	ldi	r19, 0x00	; 0
    65bc:	8e 81       	ldd	r24, Y+6	; 0x06
    65be:	9f 81       	ldd	r25, Y+7	; 0x07
    65c0:	fc 01       	movw	r30, r24
    65c2:	e2 0f       	add	r30, r18
    65c4:	f3 1f       	adc	r31, r19
    65c6:	80 81       	ld	r24, Z
    65c8:	88 23       	and	r24, r24
    65ca:	31 f0       	breq	.+12     	; 0x65d8 <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    65cc:	89 81       	ldd	r24, Y+1	; 0x01
    65ce:	8f 5f       	subi	r24, 0xFF	; 255
    65d0:	89 83       	std	Y+1, r24	; 0x01
    65d2:	89 81       	ldd	r24, Y+1	; 0x01
    65d4:	88 30       	cpi	r24, 0x08	; 8
    65d6:	e0 f2       	brcs	.-72     	; 0x6590 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    65d8:	e9 89       	ldd	r30, Y+17	; 0x11
    65da:	fa 89       	ldd	r31, Y+18	; 0x12
    65dc:	10 a2       	std	Z+32, r1	; 0x20
    65de:	03 c0       	rjmp	.+6      	; 0x65e6 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    65e0:	e9 89       	ldd	r30, Y+17	; 0x11
    65e2:	fa 89       	ldd	r31, Y+18	; 0x12
    65e4:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    65e6:	8e 85       	ldd	r24, Y+14	; 0x0e
    65e8:	84 30       	cpi	r24, 0x04	; 4
    65ea:	10 f0       	brcs	.+4      	; 0x65f0 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    65ec:	83 e0       	ldi	r24, 0x03	; 3
    65ee:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    65f0:	e9 89       	ldd	r30, Y+17	; 0x11
    65f2:	fa 89       	ldd	r31, Y+18	; 0x12
    65f4:	8e 85       	ldd	r24, Y+14	; 0x0e
    65f6:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    65f8:	89 89       	ldd	r24, Y+17	; 0x11
    65fa:	9a 89       	ldd	r25, Y+18	; 0x12
    65fc:	02 96       	adiw	r24, 0x02	; 2
    65fe:	0e 94 64 26 	call	0x4cc8	; 0x4cc8 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    6602:	89 89       	ldd	r24, Y+17	; 0x11
    6604:	9a 89       	ldd	r25, Y+18	; 0x12
    6606:	0c 96       	adiw	r24, 0x0c	; 12
    6608:	0e 94 64 26 	call	0x4cc8	; 0x4cc8 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    660c:	e9 89       	ldd	r30, Y+17	; 0x11
    660e:	fa 89       	ldd	r31, Y+18	; 0x12
    6610:	89 89       	ldd	r24, Y+17	; 0x11
    6612:	9a 89       	ldd	r25, Y+18	; 0x12
    6614:	91 87       	std	Z+9, r25	; 0x09
    6616:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6618:	8e 85       	ldd	r24, Y+14	; 0x0e
    661a:	28 2f       	mov	r18, r24
    661c:	30 e0       	ldi	r19, 0x00	; 0
    661e:	84 e0       	ldi	r24, 0x04	; 4
    6620:	90 e0       	ldi	r25, 0x00	; 0
    6622:	82 1b       	sub	r24, r18
    6624:	93 0b       	sbc	r25, r19
    6626:	e9 89       	ldd	r30, Y+17	; 0x11
    6628:	fa 89       	ldd	r31, Y+18	; 0x12
    662a:	95 87       	std	Z+13, r25	; 0x0d
    662c:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    662e:	e9 89       	ldd	r30, Y+17	; 0x11
    6630:	fa 89       	ldd	r31, Y+18	; 0x12
    6632:	89 89       	ldd	r24, Y+17	; 0x11
    6634:	9a 89       	ldd	r25, Y+18	; 0x12
    6636:	93 8b       	std	Z+19, r25	; 0x13
    6638:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    663a:	e9 89       	ldd	r30, Y+17	; 0x11
    663c:	fa 89       	ldd	r31, Y+18	; 0x12
    663e:	11 a2       	std	Z+33, r1	; 0x21
    6640:	12 a2       	std	Z+34, r1	; 0x22
    6642:	13 a2       	std	Z+35, r1	; 0x23
    6644:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    6646:	e9 89       	ldd	r30, Y+17	; 0x11
    6648:	fa 89       	ldd	r31, Y+18	; 0x12
    664a:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    664c:	8a 81       	ldd	r24, Y+2	; 0x02
    664e:	9b 81       	ldd	r25, Y+3	; 0x03
    6650:	2c 81       	ldd	r18, Y+4	; 0x04
    6652:	3d 81       	ldd	r19, Y+5	; 0x05
    6654:	4c 85       	ldd	r20, Y+12	; 0x0c
    6656:	5d 85       	ldd	r21, Y+13	; 0x0d
    6658:	b9 01       	movw	r22, r18
    665a:	0e 94 05 28 	call	0x500a	; 0x500a <pxPortInitialiseStack>
    665e:	e9 89       	ldd	r30, Y+17	; 0x11
    6660:	fa 89       	ldd	r31, Y+18	; 0x12
    6662:	91 83       	std	Z+1, r25	; 0x01
    6664:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    6666:	8f 85       	ldd	r24, Y+15	; 0x0f
    6668:	98 89       	ldd	r25, Y+16	; 0x10
    666a:	00 97       	sbiw	r24, 0x00	; 0
    666c:	31 f0       	breq	.+12     	; 0x667a <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    666e:	ef 85       	ldd	r30, Y+15	; 0x0f
    6670:	f8 89       	ldd	r31, Y+16	; 0x10
    6672:	89 89       	ldd	r24, Y+17	; 0x11
    6674:	9a 89       	ldd	r25, Y+18	; 0x12
    6676:	91 83       	std	Z+1, r25	; 0x01
    6678:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    667a:	64 96       	adiw	r28, 0x14	; 20
    667c:	0f b6       	in	r0, 0x3f	; 63
    667e:	f8 94       	cli
    6680:	de bf       	out	0x3e, r29	; 62
    6682:	0f be       	out	0x3f, r0	; 63
    6684:	cd bf       	out	0x3d, r28	; 61
    6686:	cf 91       	pop	r28
    6688:	df 91       	pop	r29
    668a:	1f 91       	pop	r17
    668c:	0f 91       	pop	r16
    668e:	ef 90       	pop	r14
    6690:	df 90       	pop	r13
    6692:	cf 90       	pop	r12
    6694:	bf 90       	pop	r11
    6696:	af 90       	pop	r10
    6698:	9f 90       	pop	r9
    669a:	8f 90       	pop	r8
    669c:	08 95       	ret

0000669e <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    669e:	df 93       	push	r29
    66a0:	cf 93       	push	r28
    66a2:	00 d0       	rcall	.+0      	; 0x66a4 <prvAddNewTaskToReadyList+0x6>
    66a4:	cd b7       	in	r28, 0x3d	; 61
    66a6:	de b7       	in	r29, 0x3e	; 62
    66a8:	9a 83       	std	Y+2, r25	; 0x02
    66aa:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    66ac:	0f b6       	in	r0, 0x3f	; 63
    66ae:	f8 94       	cli
    66b0:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    66b2:	80 91 97 05 	lds	r24, 0x0597
    66b6:	8f 5f       	subi	r24, 0xFF	; 255
    66b8:	80 93 97 05 	sts	0x0597, r24
		if( pxCurrentTCB == NULL )
    66bc:	80 91 94 05 	lds	r24, 0x0594
    66c0:	90 91 95 05 	lds	r25, 0x0595
    66c4:	00 97       	sbiw	r24, 0x00	; 0
    66c6:	69 f4       	brne	.+26     	; 0x66e2 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    66c8:	89 81       	ldd	r24, Y+1	; 0x01
    66ca:	9a 81       	ldd	r25, Y+2	; 0x02
    66cc:	90 93 95 05 	sts	0x0595, r25
    66d0:	80 93 94 05 	sts	0x0594, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    66d4:	80 91 97 05 	lds	r24, 0x0597
    66d8:	81 30       	cpi	r24, 0x01	; 1
    66da:	b9 f4       	brne	.+46     	; 0x670a <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    66dc:	0e 94 21 39 	call	0x7242	; 0x7242 <prvInitialiseTaskLists>
    66e0:	14 c0       	rjmp	.+40     	; 0x670a <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    66e2:	80 91 9b 05 	lds	r24, 0x059B
    66e6:	88 23       	and	r24, r24
    66e8:	81 f4       	brne	.+32     	; 0x670a <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    66ea:	e0 91 94 05 	lds	r30, 0x0594
    66ee:	f0 91 95 05 	lds	r31, 0x0595
    66f2:	96 89       	ldd	r25, Z+22	; 0x16
    66f4:	e9 81       	ldd	r30, Y+1	; 0x01
    66f6:	fa 81       	ldd	r31, Y+2	; 0x02
    66f8:	86 89       	ldd	r24, Z+22	; 0x16
    66fa:	89 17       	cp	r24, r25
    66fc:	30 f0       	brcs	.+12     	; 0x670a <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    66fe:	89 81       	ldd	r24, Y+1	; 0x01
    6700:	9a 81       	ldd	r25, Y+2	; 0x02
    6702:	90 93 95 05 	sts	0x0595, r25
    6706:	80 93 94 05 	sts	0x0594, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    670a:	80 91 9f 05 	lds	r24, 0x059F
    670e:	8f 5f       	subi	r24, 0xFF	; 255
    6710:	80 93 9f 05 	sts	0x059F, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    6714:	e9 81       	ldd	r30, Y+1	; 0x01
    6716:	fa 81       	ldd	r31, Y+2	; 0x02
    6718:	96 89       	ldd	r25, Z+22	; 0x16
    671a:	80 91 9a 05 	lds	r24, 0x059A
    671e:	89 17       	cp	r24, r25
    6720:	28 f4       	brcc	.+10     	; 0x672c <prvAddNewTaskToReadyList+0x8e>
    6722:	e9 81       	ldd	r30, Y+1	; 0x01
    6724:	fa 81       	ldd	r31, Y+2	; 0x02
    6726:	86 89       	ldd	r24, Z+22	; 0x16
    6728:	80 93 9a 05 	sts	0x059A, r24
    672c:	e9 81       	ldd	r30, Y+1	; 0x01
    672e:	fa 81       	ldd	r31, Y+2	; 0x02
    6730:	86 89       	ldd	r24, Z+22	; 0x16
    6732:	28 2f       	mov	r18, r24
    6734:	30 e0       	ldi	r19, 0x00	; 0
    6736:	c9 01       	movw	r24, r18
    6738:	88 0f       	add	r24, r24
    673a:	99 1f       	adc	r25, r25
    673c:	88 0f       	add	r24, r24
    673e:	99 1f       	adc	r25, r25
    6740:	88 0f       	add	r24, r24
    6742:	99 1f       	adc	r25, r25
    6744:	82 0f       	add	r24, r18
    6746:	93 1f       	adc	r25, r19
    6748:	ac 01       	movw	r20, r24
    674a:	4b 55       	subi	r20, 0x5B	; 91
    674c:	5a 4f       	sbci	r21, 0xFA	; 250
    674e:	89 81       	ldd	r24, Y+1	; 0x01
    6750:	9a 81       	ldd	r25, Y+2	; 0x02
    6752:	9c 01       	movw	r18, r24
    6754:	2e 5f       	subi	r18, 0xFE	; 254
    6756:	3f 4f       	sbci	r19, 0xFF	; 255
    6758:	ca 01       	movw	r24, r20
    675a:	b9 01       	movw	r22, r18
    675c:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    6760:	0f 90       	pop	r0
    6762:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    6764:	80 91 9b 05 	lds	r24, 0x059B
    6768:	88 23       	and	r24, r24
    676a:	61 f0       	breq	.+24     	; 0x6784 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    676c:	e0 91 94 05 	lds	r30, 0x0594
    6770:	f0 91 95 05 	lds	r31, 0x0595
    6774:	96 89       	ldd	r25, Z+22	; 0x16
    6776:	e9 81       	ldd	r30, Y+1	; 0x01
    6778:	fa 81       	ldd	r31, Y+2	; 0x02
    677a:	86 89       	ldd	r24, Z+22	; 0x16
    677c:	98 17       	cp	r25, r24
    677e:	10 f4       	brcc	.+4      	; 0x6784 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    6780:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    6784:	0f 90       	pop	r0
    6786:	0f 90       	pop	r0
    6788:	cf 91       	pop	r28
    678a:	df 91       	pop	r29
    678c:	08 95       	ret

0000678e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    678e:	df 93       	push	r29
    6790:	cf 93       	push	r28
    6792:	00 d0       	rcall	.+0      	; 0x6794 <vTaskDelete+0x6>
    6794:	00 d0       	rcall	.+0      	; 0x6796 <vTaskDelete+0x8>
    6796:	00 d0       	rcall	.+0      	; 0x6798 <vTaskDelete+0xa>
    6798:	cd b7       	in	r28, 0x3d	; 61
    679a:	de b7       	in	r29, 0x3e	; 62
    679c:	9c 83       	std	Y+4, r25	; 0x04
    679e:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    67a0:	0f b6       	in	r0, 0x3f	; 63
    67a2:	f8 94       	cli
    67a4:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    67a6:	8b 81       	ldd	r24, Y+3	; 0x03
    67a8:	9c 81       	ldd	r25, Y+4	; 0x04
    67aa:	00 97       	sbiw	r24, 0x00	; 0
    67ac:	39 f4       	brne	.+14     	; 0x67bc <vTaskDelete+0x2e>
    67ae:	80 91 94 05 	lds	r24, 0x0594
    67b2:	90 91 95 05 	lds	r25, 0x0595
    67b6:	9e 83       	std	Y+6, r25	; 0x06
    67b8:	8d 83       	std	Y+5, r24	; 0x05
    67ba:	04 c0       	rjmp	.+8      	; 0x67c4 <vTaskDelete+0x36>
    67bc:	8b 81       	ldd	r24, Y+3	; 0x03
    67be:	9c 81       	ldd	r25, Y+4	; 0x04
    67c0:	9e 83       	std	Y+6, r25	; 0x06
    67c2:	8d 83       	std	Y+5, r24	; 0x05
    67c4:	8d 81       	ldd	r24, Y+5	; 0x05
    67c6:	9e 81       	ldd	r25, Y+6	; 0x06
    67c8:	9a 83       	std	Y+2, r25	; 0x02
    67ca:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    67cc:	89 81       	ldd	r24, Y+1	; 0x01
    67ce:	9a 81       	ldd	r25, Y+2	; 0x02
    67d0:	02 96       	adiw	r24, 0x02	; 2
    67d2:	0e 94 24 27 	call	0x4e48	; 0x4e48 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    67d6:	e9 81       	ldd	r30, Y+1	; 0x01
    67d8:	fa 81       	ldd	r31, Y+2	; 0x02
    67da:	84 89       	ldd	r24, Z+20	; 0x14
    67dc:	95 89       	ldd	r25, Z+21	; 0x15
    67de:	00 97       	sbiw	r24, 0x00	; 0
    67e0:	29 f0       	breq	.+10     	; 0x67ec <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    67e2:	89 81       	ldd	r24, Y+1	; 0x01
    67e4:	9a 81       	ldd	r25, Y+2	; 0x02
    67e6:	0c 96       	adiw	r24, 0x0c	; 12
    67e8:	0e 94 24 27 	call	0x4e48	; 0x4e48 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    67ec:	80 91 9f 05 	lds	r24, 0x059F
    67f0:	8f 5f       	subi	r24, 0xFF	; 255
    67f2:	80 93 9f 05 	sts	0x059F, r24

			if( pxTCB == pxCurrentTCB )
    67f6:	20 91 94 05 	lds	r18, 0x0594
    67fa:	30 91 95 05 	lds	r19, 0x0595
    67fe:	89 81       	ldd	r24, Y+1	; 0x01
    6800:	9a 81       	ldd	r25, Y+2	; 0x02
    6802:	82 17       	cp	r24, r18
    6804:	93 07       	cpc	r25, r19
    6806:	81 f4       	brne	.+32     	; 0x6828 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    6808:	89 81       	ldd	r24, Y+1	; 0x01
    680a:	9a 81       	ldd	r25, Y+2	; 0x02
    680c:	9c 01       	movw	r18, r24
    680e:	2e 5f       	subi	r18, 0xFE	; 254
    6810:	3f 4f       	sbci	r19, 0xFF	; 255
    6812:	88 ee       	ldi	r24, 0xE8	; 232
    6814:	95 e0       	ldi	r25, 0x05	; 5
    6816:	b9 01       	movw	r22, r18
    6818:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    681c:	80 91 96 05 	lds	r24, 0x0596
    6820:	8f 5f       	subi	r24, 0xFF	; 255
    6822:	80 93 96 05 	sts	0x0596, r24
    6826:	0b c0       	rjmp	.+22     	; 0x683e <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    6828:	80 91 97 05 	lds	r24, 0x0597
    682c:	81 50       	subi	r24, 0x01	; 1
    682e:	80 93 97 05 	sts	0x0597, r24
				prvDeleteTCB( pxTCB );
    6832:	89 81       	ldd	r24, Y+1	; 0x01
    6834:	9a 81       	ldd	r25, Y+2	; 0x02
    6836:	0e 94 8d 39 	call	0x731a	; 0x731a <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    683a:	0e 94 a3 39 	call	0x7346	; 0x7346 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    683e:	0f 90       	pop	r0
    6840:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    6842:	80 91 9b 05 	lds	r24, 0x059B
    6846:	88 23       	and	r24, r24
    6848:	59 f0       	breq	.+22     	; 0x6860 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    684a:	20 91 94 05 	lds	r18, 0x0594
    684e:	30 91 95 05 	lds	r19, 0x0595
    6852:	89 81       	ldd	r24, Y+1	; 0x01
    6854:	9a 81       	ldd	r25, Y+2	; 0x02
    6856:	82 17       	cp	r24, r18
    6858:	93 07       	cpc	r25, r19
    685a:	11 f4       	brne	.+4      	; 0x6860 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    685c:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    6860:	26 96       	adiw	r28, 0x06	; 6
    6862:	0f b6       	in	r0, 0x3f	; 63
    6864:	f8 94       	cli
    6866:	de bf       	out	0x3e, r29	; 62
    6868:	0f be       	out	0x3f, r0	; 63
    686a:	cd bf       	out	0x3d, r28	; 61
    686c:	cf 91       	pop	r28
    686e:	df 91       	pop	r29
    6870:	08 95       	ret

00006872 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    6872:	df 93       	push	r29
    6874:	cf 93       	push	r28
    6876:	cd b7       	in	r28, 0x3d	; 61
    6878:	de b7       	in	r29, 0x3e	; 62
    687a:	2a 97       	sbiw	r28, 0x0a	; 10
    687c:	0f b6       	in	r0, 0x3f	; 63
    687e:	f8 94       	cli
    6880:	de bf       	out	0x3e, r29	; 62
    6882:	0f be       	out	0x3f, r0	; 63
    6884:	cd bf       	out	0x3d, r28	; 61
    6886:	98 87       	std	Y+8, r25	; 0x08
    6888:	8f 83       	std	Y+7, r24	; 0x07
    688a:	7a 87       	std	Y+10, r23	; 0x0a
    688c:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    688e:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    6890:	0e 94 0b 35 	call	0x6a16	; 0x6a16 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    6894:	80 91 98 05 	lds	r24, 0x0598
    6898:	90 91 99 05 	lds	r25, 0x0599
    689c:	9a 83       	std	Y+2, r25	; 0x02
    689e:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    68a0:	ef 81       	ldd	r30, Y+7	; 0x07
    68a2:	f8 85       	ldd	r31, Y+8	; 0x08
    68a4:	20 81       	ld	r18, Z
    68a6:	31 81       	ldd	r19, Z+1	; 0x01
    68a8:	89 85       	ldd	r24, Y+9	; 0x09
    68aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    68ac:	82 0f       	add	r24, r18
    68ae:	93 1f       	adc	r25, r19
    68b0:	9e 83       	std	Y+6, r25	; 0x06
    68b2:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    68b4:	ef 81       	ldd	r30, Y+7	; 0x07
    68b6:	f8 85       	ldd	r31, Y+8	; 0x08
    68b8:	20 81       	ld	r18, Z
    68ba:	31 81       	ldd	r19, Z+1	; 0x01
    68bc:	89 81       	ldd	r24, Y+1	; 0x01
    68be:	9a 81       	ldd	r25, Y+2	; 0x02
    68c0:	82 17       	cp	r24, r18
    68c2:	93 07       	cpc	r25, r19
    68c4:	98 f4       	brcc	.+38     	; 0x68ec <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    68c6:	ef 81       	ldd	r30, Y+7	; 0x07
    68c8:	f8 85       	ldd	r31, Y+8	; 0x08
    68ca:	20 81       	ld	r18, Z
    68cc:	31 81       	ldd	r19, Z+1	; 0x01
    68ce:	8d 81       	ldd	r24, Y+5	; 0x05
    68d0:	9e 81       	ldd	r25, Y+6	; 0x06
    68d2:	82 17       	cp	r24, r18
    68d4:	93 07       	cpc	r25, r19
    68d6:	e0 f4       	brcc	.+56     	; 0x6910 <vTaskDelayUntil+0x9e>
    68d8:	2d 81       	ldd	r18, Y+5	; 0x05
    68da:	3e 81       	ldd	r19, Y+6	; 0x06
    68dc:	89 81       	ldd	r24, Y+1	; 0x01
    68de:	9a 81       	ldd	r25, Y+2	; 0x02
    68e0:	82 17       	cp	r24, r18
    68e2:	93 07       	cpc	r25, r19
    68e4:	a8 f4       	brcc	.+42     	; 0x6910 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    68e6:	81 e0       	ldi	r24, 0x01	; 1
    68e8:	8b 83       	std	Y+3, r24	; 0x03
    68ea:	12 c0       	rjmp	.+36     	; 0x6910 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    68ec:	ef 81       	ldd	r30, Y+7	; 0x07
    68ee:	f8 85       	ldd	r31, Y+8	; 0x08
    68f0:	20 81       	ld	r18, Z
    68f2:	31 81       	ldd	r19, Z+1	; 0x01
    68f4:	8d 81       	ldd	r24, Y+5	; 0x05
    68f6:	9e 81       	ldd	r25, Y+6	; 0x06
    68f8:	82 17       	cp	r24, r18
    68fa:	93 07       	cpc	r25, r19
    68fc:	38 f0       	brcs	.+14     	; 0x690c <vTaskDelayUntil+0x9a>
    68fe:	2d 81       	ldd	r18, Y+5	; 0x05
    6900:	3e 81       	ldd	r19, Y+6	; 0x06
    6902:	89 81       	ldd	r24, Y+1	; 0x01
    6904:	9a 81       	ldd	r25, Y+2	; 0x02
    6906:	82 17       	cp	r24, r18
    6908:	93 07       	cpc	r25, r19
    690a:	10 f4       	brcc	.+4      	; 0x6910 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    690c:	81 e0       	ldi	r24, 0x01	; 1
    690e:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    6910:	ef 81       	ldd	r30, Y+7	; 0x07
    6912:	f8 85       	ldd	r31, Y+8	; 0x08
    6914:	8d 81       	ldd	r24, Y+5	; 0x05
    6916:	9e 81       	ldd	r25, Y+6	; 0x06
    6918:	91 83       	std	Z+1, r25	; 0x01
    691a:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    691c:	8b 81       	ldd	r24, Y+3	; 0x03
    691e:	88 23       	and	r24, r24
    6920:	49 f0       	breq	.+18     	; 0x6934 <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    6922:	8d 81       	ldd	r24, Y+5	; 0x05
    6924:	9e 81       	ldd	r25, Y+6	; 0x06
    6926:	29 81       	ldd	r18, Y+1	; 0x01
    6928:	3a 81       	ldd	r19, Y+2	; 0x02
    692a:	82 1b       	sub	r24, r18
    692c:	93 0b       	sbc	r25, r19
    692e:	60 e0       	ldi	r22, 0x00	; 0
    6930:	0e 94 9d 3d 	call	0x7b3a	; 0x7b3a <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    6934:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <xTaskResumeAll>
    6938:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    693a:	8c 81       	ldd	r24, Y+4	; 0x04
    693c:	88 23       	and	r24, r24
    693e:	11 f4       	brne	.+4      	; 0x6944 <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    6940:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    6944:	2a 96       	adiw	r28, 0x0a	; 10
    6946:	0f b6       	in	r0, 0x3f	; 63
    6948:	f8 94       	cli
    694a:	de bf       	out	0x3e, r29	; 62
    694c:	0f be       	out	0x3f, r0	; 63
    694e:	cd bf       	out	0x3d, r28	; 61
    6950:	cf 91       	pop	r28
    6952:	df 91       	pop	r29
    6954:	08 95       	ret

00006956 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    6956:	df 93       	push	r29
    6958:	cf 93       	push	r28
    695a:	00 d0       	rcall	.+0      	; 0x695c <vTaskDelay+0x6>
    695c:	0f 92       	push	r0
    695e:	cd b7       	in	r28, 0x3d	; 61
    6960:	de b7       	in	r29, 0x3e	; 62
    6962:	9b 83       	std	Y+3, r25	; 0x03
    6964:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    6966:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    6968:	8a 81       	ldd	r24, Y+2	; 0x02
    696a:	9b 81       	ldd	r25, Y+3	; 0x03
    696c:	00 97       	sbiw	r24, 0x00	; 0
    696e:	51 f0       	breq	.+20     	; 0x6984 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    6970:	0e 94 0b 35 	call	0x6a16	; 0x6a16 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    6974:	8a 81       	ldd	r24, Y+2	; 0x02
    6976:	9b 81       	ldd	r25, Y+3	; 0x03
    6978:	60 e0       	ldi	r22, 0x00	; 0
    697a:	0e 94 9d 3d 	call	0x7b3a	; 0x7b3a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    697e:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <xTaskResumeAll>
    6982:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    6984:	89 81       	ldd	r24, Y+1	; 0x01
    6986:	88 23       	and	r24, r24
    6988:	11 f4       	brne	.+4      	; 0x698e <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    698a:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    698e:	0f 90       	pop	r0
    6990:	0f 90       	pop	r0
    6992:	0f 90       	pop	r0
    6994:	cf 91       	pop	r28
    6996:	df 91       	pop	r29
    6998:	08 95       	ret

0000699a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    699a:	ef 92       	push	r14
    699c:	ff 92       	push	r15
    699e:	0f 93       	push	r16
    69a0:	df 93       	push	r29
    69a2:	cf 93       	push	r28
    69a4:	0f 92       	push	r0
    69a6:	cd b7       	in	r28, 0x3d	; 61
    69a8:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    69aa:	87 e1       	ldi	r24, 0x17	; 23
    69ac:	99 e3       	ldi	r25, 0x39	; 57
    69ae:	2b e6       	ldi	r18, 0x6B	; 107
    69b0:	30 e0       	ldi	r19, 0x00	; 0
    69b2:	e2 ea       	ldi	r30, 0xA2	; 162
    69b4:	f5 e0       	ldi	r31, 0x05	; 5
    69b6:	b9 01       	movw	r22, r18
    69b8:	40 e8       	ldi	r20, 0x80	; 128
    69ba:	50 e0       	ldi	r21, 0x00	; 0
    69bc:	20 e0       	ldi	r18, 0x00	; 0
    69be:	30 e0       	ldi	r19, 0x00	; 0
    69c0:	00 e0       	ldi	r16, 0x00	; 0
    69c2:	7f 01       	movw	r14, r30
    69c4:	0e 94 1b 32 	call	0x6436	; 0x6436 <xTaskCreate>
    69c8:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    69ca:	89 81       	ldd	r24, Y+1	; 0x01
    69cc:	81 30       	cpi	r24, 0x01	; 1
    69ce:	81 f4       	brne	.+32     	; 0x69f0 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    69d0:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    69d2:	8f ef       	ldi	r24, 0xFF	; 255
    69d4:	9f ef       	ldi	r25, 0xFF	; 255
    69d6:	90 93 a1 05 	sts	0x05A1, r25
    69da:	80 93 a0 05 	sts	0x05A0, r24
		xSchedulerRunning = pdTRUE;
    69de:	81 e0       	ldi	r24, 0x01	; 1
    69e0:	80 93 9b 05 	sts	0x059B, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    69e4:	10 92 99 05 	sts	0x0599, r1
    69e8:	10 92 98 05 	sts	0x0598, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    69ec:	0e 94 88 29 	call	0x5310	; 0x5310 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    69f0:	0f 90       	pop	r0
    69f2:	cf 91       	pop	r28
    69f4:	df 91       	pop	r29
    69f6:	0f 91       	pop	r16
    69f8:	ff 90       	pop	r15
    69fa:	ef 90       	pop	r14
    69fc:	08 95       	ret

000069fe <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    69fe:	df 93       	push	r29
    6a00:	cf 93       	push	r28
    6a02:	cd b7       	in	r28, 0x3d	; 61
    6a04:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    6a06:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    6a08:	10 92 9b 05 	sts	0x059B, r1
	vPortEndScheduler();
    6a0c:	0e 94 bd 29 	call	0x537a	; 0x537a <vPortEndScheduler>
}
    6a10:	cf 91       	pop	r28
    6a12:	df 91       	pop	r29
    6a14:	08 95       	ret

00006a16 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    6a16:	df 93       	push	r29
    6a18:	cf 93       	push	r28
    6a1a:	cd b7       	in	r28, 0x3d	; 61
    6a1c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    6a1e:	80 91 a4 05 	lds	r24, 0x05A4
    6a22:	8f 5f       	subi	r24, 0xFF	; 255
    6a24:	80 93 a4 05 	sts	0x05A4, r24
	portMEMORY_BARRIER();
}
    6a28:	cf 91       	pop	r28
    6a2a:	df 91       	pop	r29
    6a2c:	08 95       	ret

00006a2e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    6a2e:	df 93       	push	r29
    6a30:	cf 93       	push	r28
    6a32:	00 d0       	rcall	.+0      	; 0x6a34 <xTaskResumeAll+0x6>
    6a34:	00 d0       	rcall	.+0      	; 0x6a36 <xTaskResumeAll+0x8>
    6a36:	cd b7       	in	r28, 0x3d	; 61
    6a38:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    6a3a:	1c 82       	std	Y+4, r1	; 0x04
    6a3c:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    6a3e:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    6a40:	0f b6       	in	r0, 0x3f	; 63
    6a42:	f8 94       	cli
    6a44:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    6a46:	80 91 a4 05 	lds	r24, 0x05A4
    6a4a:	81 50       	subi	r24, 0x01	; 1
    6a4c:	80 93 a4 05 	sts	0x05A4, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6a50:	80 91 a4 05 	lds	r24, 0x05A4
    6a54:	88 23       	and	r24, r24
    6a56:	09 f0       	breq	.+2      	; 0x6a5a <xTaskResumeAll+0x2c>
    6a58:	73 c0       	rjmp	.+230    	; 0x6b40 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    6a5a:	80 91 97 05 	lds	r24, 0x0597
    6a5e:	88 23       	and	r24, r24
    6a60:	09 f4       	brne	.+2      	; 0x6a64 <xTaskResumeAll+0x36>
    6a62:	6e c0       	rjmp	.+220    	; 0x6b40 <xTaskResumeAll+0x112>
    6a64:	45 c0       	rjmp	.+138    	; 0x6af0 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6a66:	e0 91 e4 05 	lds	r30, 0x05E4
    6a6a:	f0 91 e5 05 	lds	r31, 0x05E5
    6a6e:	86 81       	ldd	r24, Z+6	; 0x06
    6a70:	97 81       	ldd	r25, Z+7	; 0x07
    6a72:	9c 83       	std	Y+4, r25	; 0x04
    6a74:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    6a76:	8b 81       	ldd	r24, Y+3	; 0x03
    6a78:	9c 81       	ldd	r25, Y+4	; 0x04
    6a7a:	0c 96       	adiw	r24, 0x0c	; 12
    6a7c:	0e 94 24 27 	call	0x4e48	; 0x4e48 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6a80:	8b 81       	ldd	r24, Y+3	; 0x03
    6a82:	9c 81       	ldd	r25, Y+4	; 0x04
    6a84:	02 96       	adiw	r24, 0x02	; 2
    6a86:	0e 94 24 27 	call	0x4e48	; 0x4e48 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    6a8a:	eb 81       	ldd	r30, Y+3	; 0x03
    6a8c:	fc 81       	ldd	r31, Y+4	; 0x04
    6a8e:	96 89       	ldd	r25, Z+22	; 0x16
    6a90:	80 91 9a 05 	lds	r24, 0x059A
    6a94:	89 17       	cp	r24, r25
    6a96:	28 f4       	brcc	.+10     	; 0x6aa2 <xTaskResumeAll+0x74>
    6a98:	eb 81       	ldd	r30, Y+3	; 0x03
    6a9a:	fc 81       	ldd	r31, Y+4	; 0x04
    6a9c:	86 89       	ldd	r24, Z+22	; 0x16
    6a9e:	80 93 9a 05 	sts	0x059A, r24
    6aa2:	eb 81       	ldd	r30, Y+3	; 0x03
    6aa4:	fc 81       	ldd	r31, Y+4	; 0x04
    6aa6:	86 89       	ldd	r24, Z+22	; 0x16
    6aa8:	28 2f       	mov	r18, r24
    6aaa:	30 e0       	ldi	r19, 0x00	; 0
    6aac:	c9 01       	movw	r24, r18
    6aae:	88 0f       	add	r24, r24
    6ab0:	99 1f       	adc	r25, r25
    6ab2:	88 0f       	add	r24, r24
    6ab4:	99 1f       	adc	r25, r25
    6ab6:	88 0f       	add	r24, r24
    6ab8:	99 1f       	adc	r25, r25
    6aba:	82 0f       	add	r24, r18
    6abc:	93 1f       	adc	r25, r19
    6abe:	ac 01       	movw	r20, r24
    6ac0:	4b 55       	subi	r20, 0x5B	; 91
    6ac2:	5a 4f       	sbci	r21, 0xFA	; 250
    6ac4:	8b 81       	ldd	r24, Y+3	; 0x03
    6ac6:	9c 81       	ldd	r25, Y+4	; 0x04
    6ac8:	9c 01       	movw	r18, r24
    6aca:	2e 5f       	subi	r18, 0xFE	; 254
    6acc:	3f 4f       	sbci	r19, 0xFF	; 255
    6ace:	ca 01       	movw	r24, r20
    6ad0:	b9 01       	movw	r22, r18
    6ad2:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    6ad6:	eb 81       	ldd	r30, Y+3	; 0x03
    6ad8:	fc 81       	ldd	r31, Y+4	; 0x04
    6ada:	96 89       	ldd	r25, Z+22	; 0x16
    6adc:	e0 91 94 05 	lds	r30, 0x0594
    6ae0:	f0 91 95 05 	lds	r31, 0x0595
    6ae4:	86 89       	ldd	r24, Z+22	; 0x16
    6ae6:	98 17       	cp	r25, r24
    6ae8:	18 f0       	brcs	.+6      	; 0x6af0 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    6aea:	81 e0       	ldi	r24, 0x01	; 1
    6aec:	80 93 9d 05 	sts	0x059D, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    6af0:	80 91 df 05 	lds	r24, 0x05DF
    6af4:	88 23       	and	r24, r24
    6af6:	09 f0       	breq	.+2      	; 0x6afa <xTaskResumeAll+0xcc>
    6af8:	b6 cf       	rjmp	.-148    	; 0x6a66 <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    6afa:	8b 81       	ldd	r24, Y+3	; 0x03
    6afc:	9c 81       	ldd	r25, Y+4	; 0x04
    6afe:	00 97       	sbiw	r24, 0x00	; 0
    6b00:	11 f0       	breq	.+4      	; 0x6b06 <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    6b02:	0e 94 a3 39 	call	0x7346	; 0x7346 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    6b06:	80 91 9c 05 	lds	r24, 0x059C
    6b0a:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    6b0c:	89 81       	ldd	r24, Y+1	; 0x01
    6b0e:	88 23       	and	r24, r24
    6b10:	79 f0       	breq	.+30     	; 0x6b30 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    6b12:	0e 94 07 36 	call	0x6c0e	; 0x6c0e <xTaskIncrementTick>
    6b16:	88 23       	and	r24, r24
    6b18:	19 f0       	breq	.+6      	; 0x6b20 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    6b1a:	81 e0       	ldi	r24, 0x01	; 1
    6b1c:	80 93 9d 05 	sts	0x059D, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    6b20:	89 81       	ldd	r24, Y+1	; 0x01
    6b22:	81 50       	subi	r24, 0x01	; 1
    6b24:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    6b26:	89 81       	ldd	r24, Y+1	; 0x01
    6b28:	88 23       	and	r24, r24
    6b2a:	99 f7       	brne	.-26     	; 0x6b12 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    6b2c:	10 92 9c 05 	sts	0x059C, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    6b30:	80 91 9d 05 	lds	r24, 0x059D
    6b34:	88 23       	and	r24, r24
    6b36:	21 f0       	breq	.+8      	; 0x6b40 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    6b38:	81 e0       	ldi	r24, 0x01	; 1
    6b3a:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    6b3c:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    6b40:	0f 90       	pop	r0
    6b42:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    6b44:	8a 81       	ldd	r24, Y+2	; 0x02
}
    6b46:	0f 90       	pop	r0
    6b48:	0f 90       	pop	r0
    6b4a:	0f 90       	pop	r0
    6b4c:	0f 90       	pop	r0
    6b4e:	cf 91       	pop	r28
    6b50:	df 91       	pop	r29
    6b52:	08 95       	ret

00006b54 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    6b54:	df 93       	push	r29
    6b56:	cf 93       	push	r28
    6b58:	00 d0       	rcall	.+0      	; 0x6b5a <xTaskGetTickCount+0x6>
    6b5a:	cd b7       	in	r28, 0x3d	; 61
    6b5c:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    6b5e:	0f b6       	in	r0, 0x3f	; 63
    6b60:	f8 94       	cli
    6b62:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    6b64:	80 91 98 05 	lds	r24, 0x0598
    6b68:	90 91 99 05 	lds	r25, 0x0599
    6b6c:	9a 83       	std	Y+2, r25	; 0x02
    6b6e:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    6b70:	0f 90       	pop	r0
    6b72:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    6b74:	89 81       	ldd	r24, Y+1	; 0x01
    6b76:	9a 81       	ldd	r25, Y+2	; 0x02
}
    6b78:	0f 90       	pop	r0
    6b7a:	0f 90       	pop	r0
    6b7c:	cf 91       	pop	r28
    6b7e:	df 91       	pop	r29
    6b80:	08 95       	ret

00006b82 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    6b82:	df 93       	push	r29
    6b84:	cf 93       	push	r28
    6b86:	00 d0       	rcall	.+0      	; 0x6b88 <xTaskGetTickCountFromISR+0x6>
    6b88:	0f 92       	push	r0
    6b8a:	cd b7       	in	r28, 0x3d	; 61
    6b8c:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    6b8e:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    6b90:	80 91 98 05 	lds	r24, 0x0598
    6b94:	90 91 99 05 	lds	r25, 0x0599
    6b98:	9b 83       	std	Y+3, r25	; 0x03
    6b9a:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    6b9c:	8a 81       	ldd	r24, Y+2	; 0x02
    6b9e:	9b 81       	ldd	r25, Y+3	; 0x03
}
    6ba0:	0f 90       	pop	r0
    6ba2:	0f 90       	pop	r0
    6ba4:	0f 90       	pop	r0
    6ba6:	cf 91       	pop	r28
    6ba8:	df 91       	pop	r29
    6baa:	08 95       	ret

00006bac <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    6bac:	df 93       	push	r29
    6bae:	cf 93       	push	r28
    6bb0:	cd b7       	in	r28, 0x3d	; 61
    6bb2:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    6bb4:	80 91 97 05 	lds	r24, 0x0597
}
    6bb8:	cf 91       	pop	r28
    6bba:	df 91       	pop	r29
    6bbc:	08 95       	ret

00006bbe <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    6bbe:	df 93       	push	r29
    6bc0:	cf 93       	push	r28
    6bc2:	00 d0       	rcall	.+0      	; 0x6bc4 <pcTaskGetName+0x6>
    6bc4:	00 d0       	rcall	.+0      	; 0x6bc6 <pcTaskGetName+0x8>
    6bc6:	00 d0       	rcall	.+0      	; 0x6bc8 <pcTaskGetName+0xa>
    6bc8:	cd b7       	in	r28, 0x3d	; 61
    6bca:	de b7       	in	r29, 0x3e	; 62
    6bcc:	9c 83       	std	Y+4, r25	; 0x04
    6bce:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    6bd0:	8b 81       	ldd	r24, Y+3	; 0x03
    6bd2:	9c 81       	ldd	r25, Y+4	; 0x04
    6bd4:	00 97       	sbiw	r24, 0x00	; 0
    6bd6:	39 f4       	brne	.+14     	; 0x6be6 <pcTaskGetName+0x28>
    6bd8:	80 91 94 05 	lds	r24, 0x0594
    6bdc:	90 91 95 05 	lds	r25, 0x0595
    6be0:	9e 83       	std	Y+6, r25	; 0x06
    6be2:	8d 83       	std	Y+5, r24	; 0x05
    6be4:	04 c0       	rjmp	.+8      	; 0x6bee <pcTaskGetName+0x30>
    6be6:	8b 81       	ldd	r24, Y+3	; 0x03
    6be8:	9c 81       	ldd	r25, Y+4	; 0x04
    6bea:	9e 83       	std	Y+6, r25	; 0x06
    6bec:	8d 83       	std	Y+5, r24	; 0x05
    6bee:	8d 81       	ldd	r24, Y+5	; 0x05
    6bf0:	9e 81       	ldd	r25, Y+6	; 0x06
    6bf2:	9a 83       	std	Y+2, r25	; 0x02
    6bf4:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    6bf6:	89 81       	ldd	r24, Y+1	; 0x01
    6bf8:	9a 81       	ldd	r25, Y+2	; 0x02
    6bfa:	49 96       	adiw	r24, 0x19	; 25
}
    6bfc:	26 96       	adiw	r28, 0x06	; 6
    6bfe:	0f b6       	in	r0, 0x3f	; 63
    6c00:	f8 94       	cli
    6c02:	de bf       	out	0x3e, r29	; 62
    6c04:	0f be       	out	0x3f, r0	; 63
    6c06:	cd bf       	out	0x3d, r28	; 61
    6c08:	cf 91       	pop	r28
    6c0a:	df 91       	pop	r29
    6c0c:	08 95       	ret

00006c0e <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    6c0e:	df 93       	push	r29
    6c10:	cf 93       	push	r28
    6c12:	cd b7       	in	r28, 0x3d	; 61
    6c14:	de b7       	in	r29, 0x3e	; 62
    6c16:	29 97       	sbiw	r28, 0x09	; 9
    6c18:	0f b6       	in	r0, 0x3f	; 63
    6c1a:	f8 94       	cli
    6c1c:	de bf       	out	0x3e, r29	; 62
    6c1e:	0f be       	out	0x3f, r0	; 63
    6c20:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    6c22:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6c24:	80 91 a4 05 	lds	r24, 0x05A4
    6c28:	88 23       	and	r24, r24
    6c2a:	09 f0       	breq	.+2      	; 0x6c2e <xTaskIncrementTick+0x20>
    6c2c:	c0 c0       	rjmp	.+384    	; 0x6dae <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    6c2e:	80 91 98 05 	lds	r24, 0x0598
    6c32:	90 91 99 05 	lds	r25, 0x0599
    6c36:	01 96       	adiw	r24, 0x01	; 1
    6c38:	9c 83       	std	Y+4, r25	; 0x04
    6c3a:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    6c3c:	8b 81       	ldd	r24, Y+3	; 0x03
    6c3e:	9c 81       	ldd	r25, Y+4	; 0x04
    6c40:	90 93 99 05 	sts	0x0599, r25
    6c44:	80 93 98 05 	sts	0x0598, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    6c48:	8b 81       	ldd	r24, Y+3	; 0x03
    6c4a:	9c 81       	ldd	r25, Y+4	; 0x04
    6c4c:	00 97       	sbiw	r24, 0x00	; 0
    6c4e:	d9 f4       	brne	.+54     	; 0x6c86 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    6c50:	80 91 db 05 	lds	r24, 0x05DB
    6c54:	90 91 dc 05 	lds	r25, 0x05DC
    6c58:	9a 83       	std	Y+2, r25	; 0x02
    6c5a:	89 83       	std	Y+1, r24	; 0x01
    6c5c:	80 91 dd 05 	lds	r24, 0x05DD
    6c60:	90 91 de 05 	lds	r25, 0x05DE
    6c64:	90 93 dc 05 	sts	0x05DC, r25
    6c68:	80 93 db 05 	sts	0x05DB, r24
    6c6c:	89 81       	ldd	r24, Y+1	; 0x01
    6c6e:	9a 81       	ldd	r25, Y+2	; 0x02
    6c70:	90 93 de 05 	sts	0x05DE, r25
    6c74:	80 93 dd 05 	sts	0x05DD, r24
    6c78:	80 91 9e 05 	lds	r24, 0x059E
    6c7c:	8f 5f       	subi	r24, 0xFF	; 255
    6c7e:	80 93 9e 05 	sts	0x059E, r24
    6c82:	0e 94 a3 39 	call	0x7346	; 0x7346 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    6c86:	20 91 a0 05 	lds	r18, 0x05A0
    6c8a:	30 91 a1 05 	lds	r19, 0x05A1
    6c8e:	8b 81       	ldd	r24, Y+3	; 0x03
    6c90:	9c 81       	ldd	r25, Y+4	; 0x04
    6c92:	82 17       	cp	r24, r18
    6c94:	93 07       	cpc	r25, r19
    6c96:	08 f4       	brcc	.+2      	; 0x6c9a <xTaskIncrementTick+0x8c>
    6c98:	71 c0       	rjmp	.+226    	; 0x6d7c <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    6c9a:	e0 91 db 05 	lds	r30, 0x05DB
    6c9e:	f0 91 dc 05 	lds	r31, 0x05DC
    6ca2:	80 81       	ld	r24, Z
    6ca4:	88 23       	and	r24, r24
    6ca6:	39 f4       	brne	.+14     	; 0x6cb6 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6ca8:	8f ef       	ldi	r24, 0xFF	; 255
    6caa:	9f ef       	ldi	r25, 0xFF	; 255
    6cac:	90 93 a1 05 	sts	0x05A1, r25
    6cb0:	80 93 a0 05 	sts	0x05A0, r24
    6cb4:	63 c0       	rjmp	.+198    	; 0x6d7c <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6cb6:	e0 91 db 05 	lds	r30, 0x05DB
    6cba:	f0 91 dc 05 	lds	r31, 0x05DC
    6cbe:	05 80       	ldd	r0, Z+5	; 0x05
    6cc0:	f6 81       	ldd	r31, Z+6	; 0x06
    6cc2:	e0 2d       	mov	r30, r0
    6cc4:	86 81       	ldd	r24, Z+6	; 0x06
    6cc6:	97 81       	ldd	r25, Z+7	; 0x07
    6cc8:	99 87       	std	Y+9, r25	; 0x09
    6cca:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    6ccc:	e8 85       	ldd	r30, Y+8	; 0x08
    6cce:	f9 85       	ldd	r31, Y+9	; 0x09
    6cd0:	82 81       	ldd	r24, Z+2	; 0x02
    6cd2:	93 81       	ldd	r25, Z+3	; 0x03
    6cd4:	9f 83       	std	Y+7, r25	; 0x07
    6cd6:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    6cd8:	2b 81       	ldd	r18, Y+3	; 0x03
    6cda:	3c 81       	ldd	r19, Y+4	; 0x04
    6cdc:	8e 81       	ldd	r24, Y+6	; 0x06
    6cde:	9f 81       	ldd	r25, Y+7	; 0x07
    6ce0:	28 17       	cp	r18, r24
    6ce2:	39 07       	cpc	r19, r25
    6ce4:	38 f4       	brcc	.+14     	; 0x6cf4 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    6ce6:	8e 81       	ldd	r24, Y+6	; 0x06
    6ce8:	9f 81       	ldd	r25, Y+7	; 0x07
    6cea:	90 93 a1 05 	sts	0x05A1, r25
    6cee:	80 93 a0 05 	sts	0x05A0, r24
    6cf2:	44 c0       	rjmp	.+136    	; 0x6d7c <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    6cf4:	88 85       	ldd	r24, Y+8	; 0x08
    6cf6:	99 85       	ldd	r25, Y+9	; 0x09
    6cf8:	02 96       	adiw	r24, 0x02	; 2
    6cfa:	0e 94 24 27 	call	0x4e48	; 0x4e48 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    6cfe:	e8 85       	ldd	r30, Y+8	; 0x08
    6d00:	f9 85       	ldd	r31, Y+9	; 0x09
    6d02:	84 89       	ldd	r24, Z+20	; 0x14
    6d04:	95 89       	ldd	r25, Z+21	; 0x15
    6d06:	00 97       	sbiw	r24, 0x00	; 0
    6d08:	29 f0       	breq	.+10     	; 0x6d14 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    6d0a:	88 85       	ldd	r24, Y+8	; 0x08
    6d0c:	99 85       	ldd	r25, Y+9	; 0x09
    6d0e:	0c 96       	adiw	r24, 0x0c	; 12
    6d10:	0e 94 24 27 	call	0x4e48	; 0x4e48 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    6d14:	e8 85       	ldd	r30, Y+8	; 0x08
    6d16:	f9 85       	ldd	r31, Y+9	; 0x09
    6d18:	96 89       	ldd	r25, Z+22	; 0x16
    6d1a:	80 91 9a 05 	lds	r24, 0x059A
    6d1e:	89 17       	cp	r24, r25
    6d20:	28 f4       	brcc	.+10     	; 0x6d2c <xTaskIncrementTick+0x11e>
    6d22:	e8 85       	ldd	r30, Y+8	; 0x08
    6d24:	f9 85       	ldd	r31, Y+9	; 0x09
    6d26:	86 89       	ldd	r24, Z+22	; 0x16
    6d28:	80 93 9a 05 	sts	0x059A, r24
    6d2c:	e8 85       	ldd	r30, Y+8	; 0x08
    6d2e:	f9 85       	ldd	r31, Y+9	; 0x09
    6d30:	86 89       	ldd	r24, Z+22	; 0x16
    6d32:	28 2f       	mov	r18, r24
    6d34:	30 e0       	ldi	r19, 0x00	; 0
    6d36:	c9 01       	movw	r24, r18
    6d38:	88 0f       	add	r24, r24
    6d3a:	99 1f       	adc	r25, r25
    6d3c:	88 0f       	add	r24, r24
    6d3e:	99 1f       	adc	r25, r25
    6d40:	88 0f       	add	r24, r24
    6d42:	99 1f       	adc	r25, r25
    6d44:	82 0f       	add	r24, r18
    6d46:	93 1f       	adc	r25, r19
    6d48:	ac 01       	movw	r20, r24
    6d4a:	4b 55       	subi	r20, 0x5B	; 91
    6d4c:	5a 4f       	sbci	r21, 0xFA	; 250
    6d4e:	88 85       	ldd	r24, Y+8	; 0x08
    6d50:	99 85       	ldd	r25, Y+9	; 0x09
    6d52:	9c 01       	movw	r18, r24
    6d54:	2e 5f       	subi	r18, 0xFE	; 254
    6d56:	3f 4f       	sbci	r19, 0xFF	; 255
    6d58:	ca 01       	movw	r24, r20
    6d5a:	b9 01       	movw	r22, r18
    6d5c:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    6d60:	e8 85       	ldd	r30, Y+8	; 0x08
    6d62:	f9 85       	ldd	r31, Y+9	; 0x09
    6d64:	96 89       	ldd	r25, Z+22	; 0x16
    6d66:	e0 91 94 05 	lds	r30, 0x0594
    6d6a:	f0 91 95 05 	lds	r31, 0x0595
    6d6e:	86 89       	ldd	r24, Z+22	; 0x16
    6d70:	98 17       	cp	r25, r24
    6d72:	08 f4       	brcc	.+2      	; 0x6d76 <xTaskIncrementTick+0x168>
    6d74:	92 cf       	rjmp	.-220    	; 0x6c9a <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    6d76:	81 e0       	ldi	r24, 0x01	; 1
    6d78:	8d 83       	std	Y+5, r24	; 0x05
    6d7a:	8f cf       	rjmp	.-226    	; 0x6c9a <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    6d7c:	e0 91 94 05 	lds	r30, 0x0594
    6d80:	f0 91 95 05 	lds	r31, 0x0595
    6d84:	86 89       	ldd	r24, Z+22	; 0x16
    6d86:	28 2f       	mov	r18, r24
    6d88:	30 e0       	ldi	r19, 0x00	; 0
    6d8a:	c9 01       	movw	r24, r18
    6d8c:	88 0f       	add	r24, r24
    6d8e:	99 1f       	adc	r25, r25
    6d90:	88 0f       	add	r24, r24
    6d92:	99 1f       	adc	r25, r25
    6d94:	88 0f       	add	r24, r24
    6d96:	99 1f       	adc	r25, r25
    6d98:	82 0f       	add	r24, r18
    6d9a:	93 1f       	adc	r25, r19
    6d9c:	fc 01       	movw	r30, r24
    6d9e:	eb 55       	subi	r30, 0x5B	; 91
    6da0:	fa 4f       	sbci	r31, 0xFA	; 250
    6da2:	80 81       	ld	r24, Z
    6da4:	82 30       	cpi	r24, 0x02	; 2
    6da6:	40 f0       	brcs	.+16     	; 0x6db8 <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    6da8:	81 e0       	ldi	r24, 0x01	; 1
    6daa:	8d 83       	std	Y+5, r24	; 0x05
    6dac:	05 c0       	rjmp	.+10     	; 0x6db8 <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    6dae:	80 91 9c 05 	lds	r24, 0x059C
    6db2:	8f 5f       	subi	r24, 0xFF	; 255
    6db4:	80 93 9c 05 	sts	0x059C, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    6db8:	80 91 9d 05 	lds	r24, 0x059D
    6dbc:	88 23       	and	r24, r24
    6dbe:	11 f0       	breq	.+4      	; 0x6dc4 <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    6dc0:	81 e0       	ldi	r24, 0x01	; 1
    6dc2:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    6dc4:	8d 81       	ldd	r24, Y+5	; 0x05
}
    6dc6:	29 96       	adiw	r28, 0x09	; 9
    6dc8:	0f b6       	in	r0, 0x3f	; 63
    6dca:	f8 94       	cli
    6dcc:	de bf       	out	0x3e, r29	; 62
    6dce:	0f be       	out	0x3f, r0	; 63
    6dd0:	cd bf       	out	0x3d, r28	; 61
    6dd2:	cf 91       	pop	r28
    6dd4:	df 91       	pop	r29
    6dd6:	08 95       	ret

00006dd8 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    6dd8:	df 93       	push	r29
    6dda:	cf 93       	push	r28
    6ddc:	00 d0       	rcall	.+0      	; 0x6dde <vTaskSwitchContext+0x6>
    6dde:	0f 92       	push	r0
    6de0:	cd b7       	in	r28, 0x3d	; 61
    6de2:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    6de4:	80 91 a4 05 	lds	r24, 0x05A4
    6de8:	88 23       	and	r24, r24
    6dea:	21 f0       	breq	.+8      	; 0x6df4 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    6dec:	81 e0       	ldi	r24, 0x01	; 1
    6dee:	80 93 9d 05 	sts	0x059D, r24
    6df2:	59 c0       	rjmp	.+178    	; 0x6ea6 <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    6df4:	10 92 9d 05 	sts	0x059D, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6df8:	80 91 9a 05 	lds	r24, 0x059A
    6dfc:	8b 83       	std	Y+3, r24	; 0x03
    6dfe:	03 c0       	rjmp	.+6      	; 0x6e06 <vTaskSwitchContext+0x2e>
    6e00:	8b 81       	ldd	r24, Y+3	; 0x03
    6e02:	81 50       	subi	r24, 0x01	; 1
    6e04:	8b 83       	std	Y+3, r24	; 0x03
    6e06:	8b 81       	ldd	r24, Y+3	; 0x03
    6e08:	28 2f       	mov	r18, r24
    6e0a:	30 e0       	ldi	r19, 0x00	; 0
    6e0c:	c9 01       	movw	r24, r18
    6e0e:	88 0f       	add	r24, r24
    6e10:	99 1f       	adc	r25, r25
    6e12:	88 0f       	add	r24, r24
    6e14:	99 1f       	adc	r25, r25
    6e16:	88 0f       	add	r24, r24
    6e18:	99 1f       	adc	r25, r25
    6e1a:	82 0f       	add	r24, r18
    6e1c:	93 1f       	adc	r25, r19
    6e1e:	fc 01       	movw	r30, r24
    6e20:	eb 55       	subi	r30, 0x5B	; 91
    6e22:	fa 4f       	sbci	r31, 0xFA	; 250
    6e24:	80 81       	ld	r24, Z
    6e26:	88 23       	and	r24, r24
    6e28:	59 f3       	breq	.-42     	; 0x6e00 <vTaskSwitchContext+0x28>
    6e2a:	8b 81       	ldd	r24, Y+3	; 0x03
    6e2c:	28 2f       	mov	r18, r24
    6e2e:	30 e0       	ldi	r19, 0x00	; 0
    6e30:	c9 01       	movw	r24, r18
    6e32:	88 0f       	add	r24, r24
    6e34:	99 1f       	adc	r25, r25
    6e36:	88 0f       	add	r24, r24
    6e38:	99 1f       	adc	r25, r25
    6e3a:	88 0f       	add	r24, r24
    6e3c:	99 1f       	adc	r25, r25
    6e3e:	82 0f       	add	r24, r18
    6e40:	93 1f       	adc	r25, r19
    6e42:	8b 55       	subi	r24, 0x5B	; 91
    6e44:	9a 4f       	sbci	r25, 0xFA	; 250
    6e46:	9a 83       	std	Y+2, r25	; 0x02
    6e48:	89 83       	std	Y+1, r24	; 0x01
    6e4a:	e9 81       	ldd	r30, Y+1	; 0x01
    6e4c:	fa 81       	ldd	r31, Y+2	; 0x02
    6e4e:	01 80       	ldd	r0, Z+1	; 0x01
    6e50:	f2 81       	ldd	r31, Z+2	; 0x02
    6e52:	e0 2d       	mov	r30, r0
    6e54:	82 81       	ldd	r24, Z+2	; 0x02
    6e56:	93 81       	ldd	r25, Z+3	; 0x03
    6e58:	e9 81       	ldd	r30, Y+1	; 0x01
    6e5a:	fa 81       	ldd	r31, Y+2	; 0x02
    6e5c:	92 83       	std	Z+2, r25	; 0x02
    6e5e:	81 83       	std	Z+1, r24	; 0x01
    6e60:	e9 81       	ldd	r30, Y+1	; 0x01
    6e62:	fa 81       	ldd	r31, Y+2	; 0x02
    6e64:	21 81       	ldd	r18, Z+1	; 0x01
    6e66:	32 81       	ldd	r19, Z+2	; 0x02
    6e68:	89 81       	ldd	r24, Y+1	; 0x01
    6e6a:	9a 81       	ldd	r25, Y+2	; 0x02
    6e6c:	03 96       	adiw	r24, 0x03	; 3
    6e6e:	28 17       	cp	r18, r24
    6e70:	39 07       	cpc	r19, r25
    6e72:	59 f4       	brne	.+22     	; 0x6e8a <vTaskSwitchContext+0xb2>
    6e74:	e9 81       	ldd	r30, Y+1	; 0x01
    6e76:	fa 81       	ldd	r31, Y+2	; 0x02
    6e78:	01 80       	ldd	r0, Z+1	; 0x01
    6e7a:	f2 81       	ldd	r31, Z+2	; 0x02
    6e7c:	e0 2d       	mov	r30, r0
    6e7e:	82 81       	ldd	r24, Z+2	; 0x02
    6e80:	93 81       	ldd	r25, Z+3	; 0x03
    6e82:	e9 81       	ldd	r30, Y+1	; 0x01
    6e84:	fa 81       	ldd	r31, Y+2	; 0x02
    6e86:	92 83       	std	Z+2, r25	; 0x02
    6e88:	81 83       	std	Z+1, r24	; 0x01
    6e8a:	e9 81       	ldd	r30, Y+1	; 0x01
    6e8c:	fa 81       	ldd	r31, Y+2	; 0x02
    6e8e:	01 80       	ldd	r0, Z+1	; 0x01
    6e90:	f2 81       	ldd	r31, Z+2	; 0x02
    6e92:	e0 2d       	mov	r30, r0
    6e94:	86 81       	ldd	r24, Z+6	; 0x06
    6e96:	97 81       	ldd	r25, Z+7	; 0x07
    6e98:	90 93 95 05 	sts	0x0595, r25
    6e9c:	80 93 94 05 	sts	0x0594, r24
    6ea0:	8b 81       	ldd	r24, Y+3	; 0x03
    6ea2:	80 93 9a 05 	sts	0x059A, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    6ea6:	0f 90       	pop	r0
    6ea8:	0f 90       	pop	r0
    6eaa:	0f 90       	pop	r0
    6eac:	cf 91       	pop	r28
    6eae:	df 91       	pop	r29
    6eb0:	08 95       	ret

00006eb2 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    6eb2:	df 93       	push	r29
    6eb4:	cf 93       	push	r28
    6eb6:	00 d0       	rcall	.+0      	; 0x6eb8 <vTaskPlaceOnEventList+0x6>
    6eb8:	00 d0       	rcall	.+0      	; 0x6eba <vTaskPlaceOnEventList+0x8>
    6eba:	cd b7       	in	r28, 0x3d	; 61
    6ebc:	de b7       	in	r29, 0x3e	; 62
    6ebe:	9a 83       	std	Y+2, r25	; 0x02
    6ec0:	89 83       	std	Y+1, r24	; 0x01
    6ec2:	7c 83       	std	Y+4, r23	; 0x04
    6ec4:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    6ec6:	80 91 94 05 	lds	r24, 0x0594
    6eca:	90 91 95 05 	lds	r25, 0x0595
    6ece:	9c 01       	movw	r18, r24
    6ed0:	24 5f       	subi	r18, 0xF4	; 244
    6ed2:	3f 4f       	sbci	r19, 0xFF	; 255
    6ed4:	89 81       	ldd	r24, Y+1	; 0x01
    6ed6:	9a 81       	ldd	r25, Y+2	; 0x02
    6ed8:	b9 01       	movw	r22, r18
    6eda:	0e 94 b8 26 	call	0x4d70	; 0x4d70 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    6ede:	8b 81       	ldd	r24, Y+3	; 0x03
    6ee0:	9c 81       	ldd	r25, Y+4	; 0x04
    6ee2:	61 e0       	ldi	r22, 0x01	; 1
    6ee4:	0e 94 9d 3d 	call	0x7b3a	; 0x7b3a <prvAddCurrentTaskToDelayedList>
}
    6ee8:	0f 90       	pop	r0
    6eea:	0f 90       	pop	r0
    6eec:	0f 90       	pop	r0
    6eee:	0f 90       	pop	r0
    6ef0:	cf 91       	pop	r28
    6ef2:	df 91       	pop	r29
    6ef4:	08 95       	ret

00006ef6 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    6ef6:	df 93       	push	r29
    6ef8:	cf 93       	push	r28
    6efa:	00 d0       	rcall	.+0      	; 0x6efc <vTaskPlaceOnUnorderedEventList+0x6>
    6efc:	00 d0       	rcall	.+0      	; 0x6efe <vTaskPlaceOnUnorderedEventList+0x8>
    6efe:	00 d0       	rcall	.+0      	; 0x6f00 <vTaskPlaceOnUnorderedEventList+0xa>
    6f00:	cd b7       	in	r28, 0x3d	; 61
    6f02:	de b7       	in	r29, 0x3e	; 62
    6f04:	9a 83       	std	Y+2, r25	; 0x02
    6f06:	89 83       	std	Y+1, r24	; 0x01
    6f08:	7c 83       	std	Y+4, r23	; 0x04
    6f0a:	6b 83       	std	Y+3, r22	; 0x03
    6f0c:	5e 83       	std	Y+6, r21	; 0x06
    6f0e:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    6f10:	e0 91 94 05 	lds	r30, 0x0594
    6f14:	f0 91 95 05 	lds	r31, 0x0595
    6f18:	8b 81       	ldd	r24, Y+3	; 0x03
    6f1a:	9c 81       	ldd	r25, Y+4	; 0x04
    6f1c:	90 68       	ori	r25, 0x80	; 128
    6f1e:	95 87       	std	Z+13, r25	; 0x0d
    6f20:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    6f22:	80 91 94 05 	lds	r24, 0x0594
    6f26:	90 91 95 05 	lds	r25, 0x0595
    6f2a:	9c 01       	movw	r18, r24
    6f2c:	24 5f       	subi	r18, 0xF4	; 244
    6f2e:	3f 4f       	sbci	r19, 0xFF	; 255
    6f30:	89 81       	ldd	r24, Y+1	; 0x01
    6f32:	9a 81       	ldd	r25, Y+2	; 0x02
    6f34:	b9 01       	movw	r22, r18
    6f36:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    6f3a:	8d 81       	ldd	r24, Y+5	; 0x05
    6f3c:	9e 81       	ldd	r25, Y+6	; 0x06
    6f3e:	61 e0       	ldi	r22, 0x01	; 1
    6f40:	0e 94 9d 3d 	call	0x7b3a	; 0x7b3a <prvAddCurrentTaskToDelayedList>
}
    6f44:	26 96       	adiw	r28, 0x06	; 6
    6f46:	0f b6       	in	r0, 0x3f	; 63
    6f48:	f8 94       	cli
    6f4a:	de bf       	out	0x3e, r29	; 62
    6f4c:	0f be       	out	0x3f, r0	; 63
    6f4e:	cd bf       	out	0x3d, r28	; 61
    6f50:	cf 91       	pop	r28
    6f52:	df 91       	pop	r29
    6f54:	08 95       	ret

00006f56 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    6f56:	df 93       	push	r29
    6f58:	cf 93       	push	r28
    6f5a:	00 d0       	rcall	.+0      	; 0x6f5c <xTaskRemoveFromEventList+0x6>
    6f5c:	00 d0       	rcall	.+0      	; 0x6f5e <xTaskRemoveFromEventList+0x8>
    6f5e:	0f 92       	push	r0
    6f60:	cd b7       	in	r28, 0x3d	; 61
    6f62:	de b7       	in	r29, 0x3e	; 62
    6f64:	9d 83       	std	Y+5, r25	; 0x05
    6f66:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    6f68:	ec 81       	ldd	r30, Y+4	; 0x04
    6f6a:	fd 81       	ldd	r31, Y+5	; 0x05
    6f6c:	05 80       	ldd	r0, Z+5	; 0x05
    6f6e:	f6 81       	ldd	r31, Z+6	; 0x06
    6f70:	e0 2d       	mov	r30, r0
    6f72:	86 81       	ldd	r24, Z+6	; 0x06
    6f74:	97 81       	ldd	r25, Z+7	; 0x07
    6f76:	9b 83       	std	Y+3, r25	; 0x03
    6f78:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    6f7a:	8a 81       	ldd	r24, Y+2	; 0x02
    6f7c:	9b 81       	ldd	r25, Y+3	; 0x03
    6f7e:	0c 96       	adiw	r24, 0x0c	; 12
    6f80:	0e 94 24 27 	call	0x4e48	; 0x4e48 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    6f84:	80 91 a4 05 	lds	r24, 0x05A4
    6f88:	88 23       	and	r24, r24
    6f8a:	61 f5       	brne	.+88     	; 0x6fe4 <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    6f8c:	8a 81       	ldd	r24, Y+2	; 0x02
    6f8e:	9b 81       	ldd	r25, Y+3	; 0x03
    6f90:	02 96       	adiw	r24, 0x02	; 2
    6f92:	0e 94 24 27 	call	0x4e48	; 0x4e48 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    6f96:	ea 81       	ldd	r30, Y+2	; 0x02
    6f98:	fb 81       	ldd	r31, Y+3	; 0x03
    6f9a:	96 89       	ldd	r25, Z+22	; 0x16
    6f9c:	80 91 9a 05 	lds	r24, 0x059A
    6fa0:	89 17       	cp	r24, r25
    6fa2:	28 f4       	brcc	.+10     	; 0x6fae <xTaskRemoveFromEventList+0x58>
    6fa4:	ea 81       	ldd	r30, Y+2	; 0x02
    6fa6:	fb 81       	ldd	r31, Y+3	; 0x03
    6fa8:	86 89       	ldd	r24, Z+22	; 0x16
    6faa:	80 93 9a 05 	sts	0x059A, r24
    6fae:	ea 81       	ldd	r30, Y+2	; 0x02
    6fb0:	fb 81       	ldd	r31, Y+3	; 0x03
    6fb2:	86 89       	ldd	r24, Z+22	; 0x16
    6fb4:	28 2f       	mov	r18, r24
    6fb6:	30 e0       	ldi	r19, 0x00	; 0
    6fb8:	c9 01       	movw	r24, r18
    6fba:	88 0f       	add	r24, r24
    6fbc:	99 1f       	adc	r25, r25
    6fbe:	88 0f       	add	r24, r24
    6fc0:	99 1f       	adc	r25, r25
    6fc2:	88 0f       	add	r24, r24
    6fc4:	99 1f       	adc	r25, r25
    6fc6:	82 0f       	add	r24, r18
    6fc8:	93 1f       	adc	r25, r19
    6fca:	ac 01       	movw	r20, r24
    6fcc:	4b 55       	subi	r20, 0x5B	; 91
    6fce:	5a 4f       	sbci	r21, 0xFA	; 250
    6fd0:	8a 81       	ldd	r24, Y+2	; 0x02
    6fd2:	9b 81       	ldd	r25, Y+3	; 0x03
    6fd4:	9c 01       	movw	r18, r24
    6fd6:	2e 5f       	subi	r18, 0xFE	; 254
    6fd8:	3f 4f       	sbci	r19, 0xFF	; 255
    6fda:	ca 01       	movw	r24, r20
    6fdc:	b9 01       	movw	r22, r18
    6fde:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <vListInsertEnd>
    6fe2:	0a c0       	rjmp	.+20     	; 0x6ff8 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    6fe4:	8a 81       	ldd	r24, Y+2	; 0x02
    6fe6:	9b 81       	ldd	r25, Y+3	; 0x03
    6fe8:	9c 01       	movw	r18, r24
    6fea:	24 5f       	subi	r18, 0xF4	; 244
    6fec:	3f 4f       	sbci	r19, 0xFF	; 255
    6fee:	8f ed       	ldi	r24, 0xDF	; 223
    6ff0:	95 e0       	ldi	r25, 0x05	; 5
    6ff2:	b9 01       	movw	r22, r18
    6ff4:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    6ff8:	ea 81       	ldd	r30, Y+2	; 0x02
    6ffa:	fb 81       	ldd	r31, Y+3	; 0x03
    6ffc:	96 89       	ldd	r25, Z+22	; 0x16
    6ffe:	e0 91 94 05 	lds	r30, 0x0594
    7002:	f0 91 95 05 	lds	r31, 0x0595
    7006:	86 89       	ldd	r24, Z+22	; 0x16
    7008:	89 17       	cp	r24, r25
    700a:	30 f4       	brcc	.+12     	; 0x7018 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    700c:	81 e0       	ldi	r24, 0x01	; 1
    700e:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    7010:	81 e0       	ldi	r24, 0x01	; 1
    7012:	80 93 9d 05 	sts	0x059D, r24
    7016:	01 c0       	rjmp	.+2      	; 0x701a <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    7018:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    701a:	89 81       	ldd	r24, Y+1	; 0x01
}
    701c:	0f 90       	pop	r0
    701e:	0f 90       	pop	r0
    7020:	0f 90       	pop	r0
    7022:	0f 90       	pop	r0
    7024:	0f 90       	pop	r0
    7026:	cf 91       	pop	r28
    7028:	df 91       	pop	r29
    702a:	08 95       	ret

0000702c <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    702c:	df 93       	push	r29
    702e:	cf 93       	push	r28
    7030:	00 d0       	rcall	.+0      	; 0x7032 <vTaskRemoveFromUnorderedEventList+0x6>
    7032:	00 d0       	rcall	.+0      	; 0x7034 <vTaskRemoveFromUnorderedEventList+0x8>
    7034:	00 d0       	rcall	.+0      	; 0x7036 <vTaskRemoveFromUnorderedEventList+0xa>
    7036:	cd b7       	in	r28, 0x3d	; 61
    7038:	de b7       	in	r29, 0x3e	; 62
    703a:	9c 83       	std	Y+4, r25	; 0x04
    703c:	8b 83       	std	Y+3, r24	; 0x03
    703e:	7e 83       	std	Y+6, r23	; 0x06
    7040:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    7042:	8d 81       	ldd	r24, Y+5	; 0x05
    7044:	9e 81       	ldd	r25, Y+6	; 0x06
    7046:	90 68       	ori	r25, 0x80	; 128
    7048:	eb 81       	ldd	r30, Y+3	; 0x03
    704a:	fc 81       	ldd	r31, Y+4	; 0x04
    704c:	91 83       	std	Z+1, r25	; 0x01
    704e:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    7050:	eb 81       	ldd	r30, Y+3	; 0x03
    7052:	fc 81       	ldd	r31, Y+4	; 0x04
    7054:	86 81       	ldd	r24, Z+6	; 0x06
    7056:	97 81       	ldd	r25, Z+7	; 0x07
    7058:	9a 83       	std	Y+2, r25	; 0x02
    705a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    705c:	8b 81       	ldd	r24, Y+3	; 0x03
    705e:	9c 81       	ldd	r25, Y+4	; 0x04
    7060:	0e 94 24 27 	call	0x4e48	; 0x4e48 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    7064:	89 81       	ldd	r24, Y+1	; 0x01
    7066:	9a 81       	ldd	r25, Y+2	; 0x02
    7068:	02 96       	adiw	r24, 0x02	; 2
    706a:	0e 94 24 27 	call	0x4e48	; 0x4e48 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    706e:	e9 81       	ldd	r30, Y+1	; 0x01
    7070:	fa 81       	ldd	r31, Y+2	; 0x02
    7072:	96 89       	ldd	r25, Z+22	; 0x16
    7074:	80 91 9a 05 	lds	r24, 0x059A
    7078:	89 17       	cp	r24, r25
    707a:	28 f4       	brcc	.+10     	; 0x7086 <vTaskRemoveFromUnorderedEventList+0x5a>
    707c:	e9 81       	ldd	r30, Y+1	; 0x01
    707e:	fa 81       	ldd	r31, Y+2	; 0x02
    7080:	86 89       	ldd	r24, Z+22	; 0x16
    7082:	80 93 9a 05 	sts	0x059A, r24
    7086:	e9 81       	ldd	r30, Y+1	; 0x01
    7088:	fa 81       	ldd	r31, Y+2	; 0x02
    708a:	86 89       	ldd	r24, Z+22	; 0x16
    708c:	28 2f       	mov	r18, r24
    708e:	30 e0       	ldi	r19, 0x00	; 0
    7090:	c9 01       	movw	r24, r18
    7092:	88 0f       	add	r24, r24
    7094:	99 1f       	adc	r25, r25
    7096:	88 0f       	add	r24, r24
    7098:	99 1f       	adc	r25, r25
    709a:	88 0f       	add	r24, r24
    709c:	99 1f       	adc	r25, r25
    709e:	82 0f       	add	r24, r18
    70a0:	93 1f       	adc	r25, r19
    70a2:	ac 01       	movw	r20, r24
    70a4:	4b 55       	subi	r20, 0x5B	; 91
    70a6:	5a 4f       	sbci	r21, 0xFA	; 250
    70a8:	89 81       	ldd	r24, Y+1	; 0x01
    70aa:	9a 81       	ldd	r25, Y+2	; 0x02
    70ac:	9c 01       	movw	r18, r24
    70ae:	2e 5f       	subi	r18, 0xFE	; 254
    70b0:	3f 4f       	sbci	r19, 0xFF	; 255
    70b2:	ca 01       	movw	r24, r20
    70b4:	b9 01       	movw	r22, r18
    70b6:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    70ba:	e9 81       	ldd	r30, Y+1	; 0x01
    70bc:	fa 81       	ldd	r31, Y+2	; 0x02
    70be:	96 89       	ldd	r25, Z+22	; 0x16
    70c0:	e0 91 94 05 	lds	r30, 0x0594
    70c4:	f0 91 95 05 	lds	r31, 0x0595
    70c8:	86 89       	ldd	r24, Z+22	; 0x16
    70ca:	89 17       	cp	r24, r25
    70cc:	18 f4       	brcc	.+6      	; 0x70d4 <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    70ce:	81 e0       	ldi	r24, 0x01	; 1
    70d0:	80 93 9d 05 	sts	0x059D, r24
	}
}
    70d4:	26 96       	adiw	r28, 0x06	; 6
    70d6:	0f b6       	in	r0, 0x3f	; 63
    70d8:	f8 94       	cli
    70da:	de bf       	out	0x3e, r29	; 62
    70dc:	0f be       	out	0x3f, r0	; 63
    70de:	cd bf       	out	0x3d, r28	; 61
    70e0:	cf 91       	pop	r28
    70e2:	df 91       	pop	r29
    70e4:	08 95       	ret

000070e6 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    70e6:	df 93       	push	r29
    70e8:	cf 93       	push	r28
    70ea:	00 d0       	rcall	.+0      	; 0x70ec <vTaskSetTimeOutState+0x6>
    70ec:	cd b7       	in	r28, 0x3d	; 61
    70ee:	de b7       	in	r29, 0x3e	; 62
    70f0:	9a 83       	std	Y+2, r25	; 0x02
    70f2:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    70f4:	0f b6       	in	r0, 0x3f	; 63
    70f6:	f8 94       	cli
    70f8:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    70fa:	80 91 9e 05 	lds	r24, 0x059E
    70fe:	e9 81       	ldd	r30, Y+1	; 0x01
    7100:	fa 81       	ldd	r31, Y+2	; 0x02
    7102:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    7104:	80 91 98 05 	lds	r24, 0x0598
    7108:	90 91 99 05 	lds	r25, 0x0599
    710c:	e9 81       	ldd	r30, Y+1	; 0x01
    710e:	fa 81       	ldd	r31, Y+2	; 0x02
    7110:	92 83       	std	Z+2, r25	; 0x02
    7112:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    7114:	0f 90       	pop	r0
    7116:	0f be       	out	0x3f, r0	; 63
}
    7118:	0f 90       	pop	r0
    711a:	0f 90       	pop	r0
    711c:	cf 91       	pop	r28
    711e:	df 91       	pop	r29
    7120:	08 95       	ret

00007122 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    7122:	df 93       	push	r29
    7124:	cf 93       	push	r28
    7126:	00 d0       	rcall	.+0      	; 0x7128 <vTaskInternalSetTimeOutState+0x6>
    7128:	cd b7       	in	r28, 0x3d	; 61
    712a:	de b7       	in	r29, 0x3e	; 62
    712c:	9a 83       	std	Y+2, r25	; 0x02
    712e:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    7130:	80 91 9e 05 	lds	r24, 0x059E
    7134:	e9 81       	ldd	r30, Y+1	; 0x01
    7136:	fa 81       	ldd	r31, Y+2	; 0x02
    7138:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    713a:	80 91 98 05 	lds	r24, 0x0598
    713e:	90 91 99 05 	lds	r25, 0x0599
    7142:	e9 81       	ldd	r30, Y+1	; 0x01
    7144:	fa 81       	ldd	r31, Y+2	; 0x02
    7146:	92 83       	std	Z+2, r25	; 0x02
    7148:	81 83       	std	Z+1, r24	; 0x01
}
    714a:	0f 90       	pop	r0
    714c:	0f 90       	pop	r0
    714e:	cf 91       	pop	r28
    7150:	df 91       	pop	r29
    7152:	08 95       	ret

00007154 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    7154:	df 93       	push	r29
    7156:	cf 93       	push	r28
    7158:	cd b7       	in	r28, 0x3d	; 61
    715a:	de b7       	in	r29, 0x3e	; 62
    715c:	29 97       	sbiw	r28, 0x09	; 9
    715e:	0f b6       	in	r0, 0x3f	; 63
    7160:	f8 94       	cli
    7162:	de bf       	out	0x3e, r29	; 62
    7164:	0f be       	out	0x3f, r0	; 63
    7166:	cd bf       	out	0x3d, r28	; 61
    7168:	9f 83       	std	Y+7, r25	; 0x07
    716a:	8e 83       	std	Y+6, r24	; 0x06
    716c:	79 87       	std	Y+9, r23	; 0x09
    716e:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    7170:	0f b6       	in	r0, 0x3f	; 63
    7172:	f8 94       	cli
    7174:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    7176:	80 91 98 05 	lds	r24, 0x0598
    717a:	90 91 99 05 	lds	r25, 0x0599
    717e:	9c 83       	std	Y+4, r25	; 0x04
    7180:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    7182:	ee 81       	ldd	r30, Y+6	; 0x06
    7184:	ff 81       	ldd	r31, Y+7	; 0x07
    7186:	21 81       	ldd	r18, Z+1	; 0x01
    7188:	32 81       	ldd	r19, Z+2	; 0x02
    718a:	8b 81       	ldd	r24, Y+3	; 0x03
    718c:	9c 81       	ldd	r25, Y+4	; 0x04
    718e:	82 1b       	sub	r24, r18
    7190:	93 0b       	sbc	r25, r19
    7192:	9a 83       	std	Y+2, r25	; 0x02
    7194:	89 83       	std	Y+1, r24	; 0x01
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    7196:	ee 81       	ldd	r30, Y+6	; 0x06
    7198:	ff 81       	ldd	r31, Y+7	; 0x07
    719a:	90 81       	ld	r25, Z
    719c:	80 91 9e 05 	lds	r24, 0x059E
    71a0:	98 17       	cp	r25, r24
    71a2:	61 f0       	breq	.+24     	; 0x71bc <xTaskCheckForTimeOut+0x68>
    71a4:	ee 81       	ldd	r30, Y+6	; 0x06
    71a6:	ff 81       	ldd	r31, Y+7	; 0x07
    71a8:	21 81       	ldd	r18, Z+1	; 0x01
    71aa:	32 81       	ldd	r19, Z+2	; 0x02
    71ac:	8b 81       	ldd	r24, Y+3	; 0x03
    71ae:	9c 81       	ldd	r25, Y+4	; 0x04
    71b0:	82 17       	cp	r24, r18
    71b2:	93 07       	cpc	r25, r19
    71b4:	18 f0       	brcs	.+6      	; 0x71bc <xTaskCheckForTimeOut+0x68>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    71b6:	81 e0       	ldi	r24, 0x01	; 1
    71b8:	8d 83       	std	Y+5, r24	; 0x05
    71ba:	23 c0       	rjmp	.+70     	; 0x7202 <xTaskCheckForTimeOut+0xae>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    71bc:	e8 85       	ldd	r30, Y+8	; 0x08
    71be:	f9 85       	ldd	r31, Y+9	; 0x09
    71c0:	20 81       	ld	r18, Z
    71c2:	31 81       	ldd	r19, Z+1	; 0x01
    71c4:	89 81       	ldd	r24, Y+1	; 0x01
    71c6:	9a 81       	ldd	r25, Y+2	; 0x02
    71c8:	82 17       	cp	r24, r18
    71ca:	93 07       	cpc	r25, r19
    71cc:	a0 f4       	brcc	.+40     	; 0x71f6 <xTaskCheckForTimeOut+0xa2>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    71ce:	e8 85       	ldd	r30, Y+8	; 0x08
    71d0:	f9 85       	ldd	r31, Y+9	; 0x09
    71d2:	20 81       	ld	r18, Z
    71d4:	31 81       	ldd	r19, Z+1	; 0x01
    71d6:	89 81       	ldd	r24, Y+1	; 0x01
    71d8:	9a 81       	ldd	r25, Y+2	; 0x02
    71da:	a9 01       	movw	r20, r18
    71dc:	48 1b       	sub	r20, r24
    71de:	59 0b       	sbc	r21, r25
    71e0:	ca 01       	movw	r24, r20
    71e2:	e8 85       	ldd	r30, Y+8	; 0x08
    71e4:	f9 85       	ldd	r31, Y+9	; 0x09
    71e6:	91 83       	std	Z+1, r25	; 0x01
    71e8:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    71ea:	8e 81       	ldd	r24, Y+6	; 0x06
    71ec:	9f 81       	ldd	r25, Y+7	; 0x07
    71ee:	0e 94 91 38 	call	0x7122	; 0x7122 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    71f2:	1d 82       	std	Y+5, r1	; 0x05
    71f4:	06 c0       	rjmp	.+12     	; 0x7202 <xTaskCheckForTimeOut+0xae>
		}
		else
		{
			*pxTicksToWait = 0;
    71f6:	e8 85       	ldd	r30, Y+8	; 0x08
    71f8:	f9 85       	ldd	r31, Y+9	; 0x09
    71fa:	11 82       	std	Z+1, r1	; 0x01
    71fc:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    71fe:	81 e0       	ldi	r24, 0x01	; 1
    7200:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    7202:	0f 90       	pop	r0
    7204:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    7206:	8d 81       	ldd	r24, Y+5	; 0x05
}
    7208:	29 96       	adiw	r28, 0x09	; 9
    720a:	0f b6       	in	r0, 0x3f	; 63
    720c:	f8 94       	cli
    720e:	de bf       	out	0x3e, r29	; 62
    7210:	0f be       	out	0x3f, r0	; 63
    7212:	cd bf       	out	0x3d, r28	; 61
    7214:	cf 91       	pop	r28
    7216:	df 91       	pop	r29
    7218:	08 95       	ret

0000721a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    721a:	df 93       	push	r29
    721c:	cf 93       	push	r28
    721e:	cd b7       	in	r28, 0x3d	; 61
    7220:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    7222:	81 e0       	ldi	r24, 0x01	; 1
    7224:	80 93 9d 05 	sts	0x059D, r24
}
    7228:	cf 91       	pop	r28
    722a:	df 91       	pop	r29
    722c:	08 95       	ret

0000722e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    722e:	df 93       	push	r29
    7230:	cf 93       	push	r28
    7232:	00 d0       	rcall	.+0      	; 0x7234 <prvIdleTask+0x6>
    7234:	cd b7       	in	r28, 0x3d	; 61
    7236:	de b7       	in	r29, 0x3e	; 62
    7238:	9a 83       	std	Y+2, r25	; 0x02
    723a:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    723c:	0e 94 5e 39 	call	0x72bc	; 0x72bc <prvCheckTasksWaitingTermination>
    7240:	fd cf       	rjmp	.-6      	; 0x723c <prvIdleTask+0xe>

00007242 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    7242:	df 93       	push	r29
    7244:	cf 93       	push	r28
    7246:	0f 92       	push	r0
    7248:	cd b7       	in	r28, 0x3d	; 61
    724a:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    724c:	19 82       	std	Y+1, r1	; 0x01
    724e:	13 c0       	rjmp	.+38     	; 0x7276 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    7250:	89 81       	ldd	r24, Y+1	; 0x01
    7252:	28 2f       	mov	r18, r24
    7254:	30 e0       	ldi	r19, 0x00	; 0
    7256:	c9 01       	movw	r24, r18
    7258:	88 0f       	add	r24, r24
    725a:	99 1f       	adc	r25, r25
    725c:	88 0f       	add	r24, r24
    725e:	99 1f       	adc	r25, r25
    7260:	88 0f       	add	r24, r24
    7262:	99 1f       	adc	r25, r25
    7264:	82 0f       	add	r24, r18
    7266:	93 1f       	adc	r25, r19
    7268:	8b 55       	subi	r24, 0x5B	; 91
    726a:	9a 4f       	sbci	r25, 0xFA	; 250
    726c:	0e 94 3a 26 	call	0x4c74	; 0x4c74 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    7270:	89 81       	ldd	r24, Y+1	; 0x01
    7272:	8f 5f       	subi	r24, 0xFF	; 255
    7274:	89 83       	std	Y+1, r24	; 0x01
    7276:	89 81       	ldd	r24, Y+1	; 0x01
    7278:	84 30       	cpi	r24, 0x04	; 4
    727a:	50 f3       	brcs	.-44     	; 0x7250 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    727c:	89 ec       	ldi	r24, 0xC9	; 201
    727e:	95 e0       	ldi	r25, 0x05	; 5
    7280:	0e 94 3a 26 	call	0x4c74	; 0x4c74 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    7284:	82 ed       	ldi	r24, 0xD2	; 210
    7286:	95 e0       	ldi	r25, 0x05	; 5
    7288:	0e 94 3a 26 	call	0x4c74	; 0x4c74 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    728c:	8f ed       	ldi	r24, 0xDF	; 223
    728e:	95 e0       	ldi	r25, 0x05	; 5
    7290:	0e 94 3a 26 	call	0x4c74	; 0x4c74 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    7294:	88 ee       	ldi	r24, 0xE8	; 232
    7296:	95 e0       	ldi	r25, 0x05	; 5
    7298:	0e 94 3a 26 	call	0x4c74	; 0x4c74 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    729c:	89 ec       	ldi	r24, 0xC9	; 201
    729e:	95 e0       	ldi	r25, 0x05	; 5
    72a0:	90 93 dc 05 	sts	0x05DC, r25
    72a4:	80 93 db 05 	sts	0x05DB, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    72a8:	82 ed       	ldi	r24, 0xD2	; 210
    72aa:	95 e0       	ldi	r25, 0x05	; 5
    72ac:	90 93 de 05 	sts	0x05DE, r25
    72b0:	80 93 dd 05 	sts	0x05DD, r24
}
    72b4:	0f 90       	pop	r0
    72b6:	cf 91       	pop	r28
    72b8:	df 91       	pop	r29
    72ba:	08 95       	ret

000072bc <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    72bc:	df 93       	push	r29
    72be:	cf 93       	push	r28
    72c0:	00 d0       	rcall	.+0      	; 0x72c2 <prvCheckTasksWaitingTermination+0x6>
    72c2:	cd b7       	in	r28, 0x3d	; 61
    72c4:	de b7       	in	r29, 0x3e	; 62
    72c6:	20 c0       	rjmp	.+64     	; 0x7308 <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    72c8:	0f b6       	in	r0, 0x3f	; 63
    72ca:	f8 94       	cli
    72cc:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    72ce:	e0 91 ed 05 	lds	r30, 0x05ED
    72d2:	f0 91 ee 05 	lds	r31, 0x05EE
    72d6:	86 81       	ldd	r24, Z+6	; 0x06
    72d8:	97 81       	ldd	r25, Z+7	; 0x07
    72da:	9a 83       	std	Y+2, r25	; 0x02
    72dc:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    72de:	89 81       	ldd	r24, Y+1	; 0x01
    72e0:	9a 81       	ldd	r25, Y+2	; 0x02
    72e2:	02 96       	adiw	r24, 0x02	; 2
    72e4:	0e 94 24 27 	call	0x4e48	; 0x4e48 <uxListRemove>
				--uxCurrentNumberOfTasks;
    72e8:	80 91 97 05 	lds	r24, 0x0597
    72ec:	81 50       	subi	r24, 0x01	; 1
    72ee:	80 93 97 05 	sts	0x0597, r24
				--uxDeletedTasksWaitingCleanUp;
    72f2:	80 91 96 05 	lds	r24, 0x0596
    72f6:	81 50       	subi	r24, 0x01	; 1
    72f8:	80 93 96 05 	sts	0x0596, r24
			}
			taskEXIT_CRITICAL();
    72fc:	0f 90       	pop	r0
    72fe:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    7300:	89 81       	ldd	r24, Y+1	; 0x01
    7302:	9a 81       	ldd	r25, Y+2	; 0x02
    7304:	0e 94 8d 39 	call	0x731a	; 0x731a <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    7308:	80 91 96 05 	lds	r24, 0x0596
    730c:	88 23       	and	r24, r24
    730e:	e1 f6       	brne	.-72     	; 0x72c8 <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    7310:	0f 90       	pop	r0
    7312:	0f 90       	pop	r0
    7314:	cf 91       	pop	r28
    7316:	df 91       	pop	r29
    7318:	08 95       	ret

0000731a <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    731a:	df 93       	push	r29
    731c:	cf 93       	push	r28
    731e:	00 d0       	rcall	.+0      	; 0x7320 <prvDeleteTCB+0x6>
    7320:	cd b7       	in	r28, 0x3d	; 61
    7322:	de b7       	in	r29, 0x3e	; 62
    7324:	9a 83       	std	Y+2, r25	; 0x02
    7326:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    7328:	e9 81       	ldd	r30, Y+1	; 0x01
    732a:	fa 81       	ldd	r31, Y+2	; 0x02
    732c:	87 89       	ldd	r24, Z+23	; 0x17
    732e:	90 8d       	ldd	r25, Z+24	; 0x18
    7330:	0e 94 14 26 	call	0x4c28	; 0x4c28 <vPortFree>
			vPortFree( pxTCB );
    7334:	89 81       	ldd	r24, Y+1	; 0x01
    7336:	9a 81       	ldd	r25, Y+2	; 0x02
    7338:	0e 94 14 26 	call	0x4c28	; 0x4c28 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    733c:	0f 90       	pop	r0
    733e:	0f 90       	pop	r0
    7340:	cf 91       	pop	r28
    7342:	df 91       	pop	r29
    7344:	08 95       	ret

00007346 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    7346:	df 93       	push	r29
    7348:	cf 93       	push	r28
    734a:	00 d0       	rcall	.+0      	; 0x734c <prvResetNextTaskUnblockTime+0x6>
    734c:	cd b7       	in	r28, 0x3d	; 61
    734e:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    7350:	e0 91 db 05 	lds	r30, 0x05DB
    7354:	f0 91 dc 05 	lds	r31, 0x05DC
    7358:	80 81       	ld	r24, Z
    735a:	88 23       	and	r24, r24
    735c:	39 f4       	brne	.+14     	; 0x736c <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    735e:	8f ef       	ldi	r24, 0xFF	; 255
    7360:	9f ef       	ldi	r25, 0xFF	; 255
    7362:	90 93 a1 05 	sts	0x05A1, r25
    7366:	80 93 a0 05 	sts	0x05A0, r24
    736a:	13 c0       	rjmp	.+38     	; 0x7392 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    736c:	e0 91 db 05 	lds	r30, 0x05DB
    7370:	f0 91 dc 05 	lds	r31, 0x05DC
    7374:	05 80       	ldd	r0, Z+5	; 0x05
    7376:	f6 81       	ldd	r31, Z+6	; 0x06
    7378:	e0 2d       	mov	r30, r0
    737a:	86 81       	ldd	r24, Z+6	; 0x06
    737c:	97 81       	ldd	r25, Z+7	; 0x07
    737e:	9a 83       	std	Y+2, r25	; 0x02
    7380:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    7382:	e9 81       	ldd	r30, Y+1	; 0x01
    7384:	fa 81       	ldd	r31, Y+2	; 0x02
    7386:	82 81       	ldd	r24, Z+2	; 0x02
    7388:	93 81       	ldd	r25, Z+3	; 0x03
    738a:	90 93 a1 05 	sts	0x05A1, r25
    738e:	80 93 a0 05 	sts	0x05A0, r24
	}
}
    7392:	0f 90       	pop	r0
    7394:	0f 90       	pop	r0
    7396:	cf 91       	pop	r28
    7398:	df 91       	pop	r29
    739a:	08 95       	ret

0000739c <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    739c:	df 93       	push	r29
    739e:	cf 93       	push	r28
    73a0:	00 d0       	rcall	.+0      	; 0x73a2 <uxTaskResetEventItemValue+0x6>
    73a2:	cd b7       	in	r28, 0x3d	; 61
    73a4:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    73a6:	e0 91 94 05 	lds	r30, 0x0594
    73aa:	f0 91 95 05 	lds	r31, 0x0595
    73ae:	84 85       	ldd	r24, Z+12	; 0x0c
    73b0:	95 85       	ldd	r25, Z+13	; 0x0d
    73b2:	9a 83       	std	Y+2, r25	; 0x02
    73b4:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    73b6:	a0 91 94 05 	lds	r26, 0x0594
    73ba:	b0 91 95 05 	lds	r27, 0x0595
    73be:	e0 91 94 05 	lds	r30, 0x0594
    73c2:	f0 91 95 05 	lds	r31, 0x0595
    73c6:	86 89       	ldd	r24, Z+22	; 0x16
    73c8:	28 2f       	mov	r18, r24
    73ca:	30 e0       	ldi	r19, 0x00	; 0
    73cc:	84 e0       	ldi	r24, 0x04	; 4
    73ce:	90 e0       	ldi	r25, 0x00	; 0
    73d0:	82 1b       	sub	r24, r18
    73d2:	93 0b       	sbc	r25, r19
    73d4:	1d 96       	adiw	r26, 0x0d	; 13
    73d6:	9c 93       	st	X, r25
    73d8:	8e 93       	st	-X, r24
    73da:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    73dc:	89 81       	ldd	r24, Y+1	; 0x01
    73de:	9a 81       	ldd	r25, Y+2	; 0x02
}
    73e0:	0f 90       	pop	r0
    73e2:	0f 90       	pop	r0
    73e4:	cf 91       	pop	r28
    73e6:	df 91       	pop	r29
    73e8:	08 95       	ret

000073ea <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    73ea:	df 93       	push	r29
    73ec:	cf 93       	push	r28
    73ee:	cd b7       	in	r28, 0x3d	; 61
    73f0:	de b7       	in	r29, 0x3e	; 62
    73f2:	27 97       	sbiw	r28, 0x07	; 7
    73f4:	0f b6       	in	r0, 0x3f	; 63
    73f6:	f8 94       	cli
    73f8:	de bf       	out	0x3e, r29	; 62
    73fa:	0f be       	out	0x3f, r0	; 63
    73fc:	cd bf       	out	0x3d, r28	; 61
    73fe:	8d 83       	std	Y+5, r24	; 0x05
    7400:	7f 83       	std	Y+7, r23	; 0x07
    7402:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    7404:	0f b6       	in	r0, 0x3f	; 63
    7406:	f8 94       	cli
    7408:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    740a:	e0 91 94 05 	lds	r30, 0x0594
    740e:	f0 91 95 05 	lds	r31, 0x0595
    7412:	81 a1       	ldd	r24, Z+33	; 0x21
    7414:	92 a1       	ldd	r25, Z+34	; 0x22
    7416:	a3 a1       	ldd	r26, Z+35	; 0x23
    7418:	b4 a1       	ldd	r27, Z+36	; 0x24
    741a:	00 97       	sbiw	r24, 0x00	; 0
    741c:	a1 05       	cpc	r26, r1
    741e:	b1 05       	cpc	r27, r1
    7420:	89 f4       	brne	.+34     	; 0x7444 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    7422:	e0 91 94 05 	lds	r30, 0x0594
    7426:	f0 91 95 05 	lds	r31, 0x0595
    742a:	81 e0       	ldi	r24, 0x01	; 1
    742c:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    742e:	8e 81       	ldd	r24, Y+6	; 0x06
    7430:	9f 81       	ldd	r25, Y+7	; 0x07
    7432:	00 97       	sbiw	r24, 0x00	; 0
    7434:	39 f0       	breq	.+14     	; 0x7444 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    7436:	8e 81       	ldd	r24, Y+6	; 0x06
    7438:	9f 81       	ldd	r25, Y+7	; 0x07
    743a:	61 e0       	ldi	r22, 0x01	; 1
    743c:	0e 94 9d 3d 	call	0x7b3a	; 0x7b3a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    7440:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    7444:	0f 90       	pop	r0
    7446:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    7448:	0f b6       	in	r0, 0x3f	; 63
    744a:	f8 94       	cli
    744c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    744e:	e0 91 94 05 	lds	r30, 0x0594
    7452:	f0 91 95 05 	lds	r31, 0x0595
    7456:	81 a1       	ldd	r24, Z+33	; 0x21
    7458:	92 a1       	ldd	r25, Z+34	; 0x22
    745a:	a3 a1       	ldd	r26, Z+35	; 0x23
    745c:	b4 a1       	ldd	r27, Z+36	; 0x24
    745e:	89 83       	std	Y+1, r24	; 0x01
    7460:	9a 83       	std	Y+2, r25	; 0x02
    7462:	ab 83       	std	Y+3, r26	; 0x03
    7464:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    7466:	89 81       	ldd	r24, Y+1	; 0x01
    7468:	9a 81       	ldd	r25, Y+2	; 0x02
    746a:	ab 81       	ldd	r26, Y+3	; 0x03
    746c:	bc 81       	ldd	r27, Y+4	; 0x04
    746e:	00 97       	sbiw	r24, 0x00	; 0
    7470:	a1 05       	cpc	r26, r1
    7472:	b1 05       	cpc	r27, r1
    7474:	d9 f0       	breq	.+54     	; 0x74ac <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    7476:	8d 81       	ldd	r24, Y+5	; 0x05
    7478:	88 23       	and	r24, r24
    747a:	49 f0       	breq	.+18     	; 0x748e <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    747c:	e0 91 94 05 	lds	r30, 0x0594
    7480:	f0 91 95 05 	lds	r31, 0x0595
    7484:	11 a2       	std	Z+33, r1	; 0x21
    7486:	12 a2       	std	Z+34, r1	; 0x22
    7488:	13 a2       	std	Z+35, r1	; 0x23
    748a:	14 a2       	std	Z+36, r1	; 0x24
    748c:	0f c0       	rjmp	.+30     	; 0x74ac <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    748e:	e0 91 94 05 	lds	r30, 0x0594
    7492:	f0 91 95 05 	lds	r31, 0x0595
    7496:	89 81       	ldd	r24, Y+1	; 0x01
    7498:	9a 81       	ldd	r25, Y+2	; 0x02
    749a:	ab 81       	ldd	r26, Y+3	; 0x03
    749c:	bc 81       	ldd	r27, Y+4	; 0x04
    749e:	01 97       	sbiw	r24, 0x01	; 1
    74a0:	a1 09       	sbc	r26, r1
    74a2:	b1 09       	sbc	r27, r1
    74a4:	81 a3       	std	Z+33, r24	; 0x21
    74a6:	92 a3       	std	Z+34, r25	; 0x22
    74a8:	a3 a3       	std	Z+35, r26	; 0x23
    74aa:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    74ac:	e0 91 94 05 	lds	r30, 0x0594
    74b0:	f0 91 95 05 	lds	r31, 0x0595
    74b4:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    74b6:	0f 90       	pop	r0
    74b8:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    74ba:	89 81       	ldd	r24, Y+1	; 0x01
    74bc:	9a 81       	ldd	r25, Y+2	; 0x02
    74be:	ab 81       	ldd	r26, Y+3	; 0x03
    74c0:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    74c2:	bc 01       	movw	r22, r24
    74c4:	cd 01       	movw	r24, r26
    74c6:	27 96       	adiw	r28, 0x07	; 7
    74c8:	0f b6       	in	r0, 0x3f	; 63
    74ca:	f8 94       	cli
    74cc:	de bf       	out	0x3e, r29	; 62
    74ce:	0f be       	out	0x3f, r0	; 63
    74d0:	cd bf       	out	0x3d, r28	; 61
    74d2:	cf 91       	pop	r28
    74d4:	df 91       	pop	r29
    74d6:	08 95       	ret

000074d8 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    74d8:	ef 92       	push	r14
    74da:	ff 92       	push	r15
    74dc:	0f 93       	push	r16
    74de:	1f 93       	push	r17
    74e0:	df 93       	push	r29
    74e2:	cf 93       	push	r28
    74e4:	cd b7       	in	r28, 0x3d	; 61
    74e6:	de b7       	in	r29, 0x3e	; 62
    74e8:	2d 97       	sbiw	r28, 0x0d	; 13
    74ea:	0f b6       	in	r0, 0x3f	; 63
    74ec:	f8 94       	cli
    74ee:	de bf       	out	0x3e, r29	; 62
    74f0:	0f be       	out	0x3f, r0	; 63
    74f2:	cd bf       	out	0x3d, r28	; 61
    74f4:	6a 83       	std	Y+2, r22	; 0x02
    74f6:	7b 83       	std	Y+3, r23	; 0x03
    74f8:	8c 83       	std	Y+4, r24	; 0x04
    74fa:	9d 83       	std	Y+5, r25	; 0x05
    74fc:	2e 83       	std	Y+6, r18	; 0x06
    74fe:	3f 83       	std	Y+7, r19	; 0x07
    7500:	48 87       	std	Y+8, r20	; 0x08
    7502:	59 87       	std	Y+9, r21	; 0x09
    7504:	1b 87       	std	Y+11, r17	; 0x0b
    7506:	0a 87       	std	Y+10, r16	; 0x0a
    7508:	fd 86       	std	Y+13, r15	; 0x0d
    750a:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    750c:	0f b6       	in	r0, 0x3f	; 63
    750e:	f8 94       	cli
    7510:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    7512:	e0 91 94 05 	lds	r30, 0x0594
    7516:	f0 91 95 05 	lds	r31, 0x0595
    751a:	85 a1       	ldd	r24, Z+37	; 0x25
    751c:	82 30       	cpi	r24, 0x02	; 2
    751e:	49 f1       	breq	.+82     	; 0x7572 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    7520:	e0 91 94 05 	lds	r30, 0x0594
    7524:	f0 91 95 05 	lds	r31, 0x0595
    7528:	21 a1       	ldd	r18, Z+33	; 0x21
    752a:	32 a1       	ldd	r19, Z+34	; 0x22
    752c:	43 a1       	ldd	r20, Z+35	; 0x23
    752e:	54 a1       	ldd	r21, Z+36	; 0x24
    7530:	8a 81       	ldd	r24, Y+2	; 0x02
    7532:	9b 81       	ldd	r25, Y+3	; 0x03
    7534:	ac 81       	ldd	r26, Y+4	; 0x04
    7536:	bd 81       	ldd	r27, Y+5	; 0x05
    7538:	80 95       	com	r24
    753a:	90 95       	com	r25
    753c:	a0 95       	com	r26
    753e:	b0 95       	com	r27
    7540:	82 23       	and	r24, r18
    7542:	93 23       	and	r25, r19
    7544:	a4 23       	and	r26, r20
    7546:	b5 23       	and	r27, r21
    7548:	81 a3       	std	Z+33, r24	; 0x21
    754a:	92 a3       	std	Z+34, r25	; 0x22
    754c:	a3 a3       	std	Z+35, r26	; 0x23
    754e:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    7550:	e0 91 94 05 	lds	r30, 0x0594
    7554:	f0 91 95 05 	lds	r31, 0x0595
    7558:	81 e0       	ldi	r24, 0x01	; 1
    755a:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    755c:	8c 85       	ldd	r24, Y+12	; 0x0c
    755e:	9d 85       	ldd	r25, Y+13	; 0x0d
    7560:	00 97       	sbiw	r24, 0x00	; 0
    7562:	39 f0       	breq	.+14     	; 0x7572 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    7564:	8c 85       	ldd	r24, Y+12	; 0x0c
    7566:	9d 85       	ldd	r25, Y+13	; 0x0d
    7568:	61 e0       	ldi	r22, 0x01	; 1
    756a:	0e 94 9d 3d 	call	0x7b3a	; 0x7b3a <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    756e:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    7572:	0f 90       	pop	r0
    7574:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    7576:	0f b6       	in	r0, 0x3f	; 63
    7578:	f8 94       	cli
    757a:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    757c:	8a 85       	ldd	r24, Y+10	; 0x0a
    757e:	9b 85       	ldd	r25, Y+11	; 0x0b
    7580:	00 97       	sbiw	r24, 0x00	; 0
    7582:	71 f0       	breq	.+28     	; 0x75a0 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    7584:	e0 91 94 05 	lds	r30, 0x0594
    7588:	f0 91 95 05 	lds	r31, 0x0595
    758c:	81 a1       	ldd	r24, Z+33	; 0x21
    758e:	92 a1       	ldd	r25, Z+34	; 0x22
    7590:	a3 a1       	ldd	r26, Z+35	; 0x23
    7592:	b4 a1       	ldd	r27, Z+36	; 0x24
    7594:	ea 85       	ldd	r30, Y+10	; 0x0a
    7596:	fb 85       	ldd	r31, Y+11	; 0x0b
    7598:	80 83       	st	Z, r24
    759a:	91 83       	std	Z+1, r25	; 0x01
    759c:	a2 83       	std	Z+2, r26	; 0x02
    759e:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    75a0:	e0 91 94 05 	lds	r30, 0x0594
    75a4:	f0 91 95 05 	lds	r31, 0x0595
    75a8:	85 a1       	ldd	r24, Z+37	; 0x25
    75aa:	82 30       	cpi	r24, 0x02	; 2
    75ac:	11 f0       	breq	.+4      	; 0x75b2 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    75ae:	19 82       	std	Y+1, r1	; 0x01
    75b0:	1a c0       	rjmp	.+52     	; 0x75e6 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    75b2:	e0 91 94 05 	lds	r30, 0x0594
    75b6:	f0 91 95 05 	lds	r31, 0x0595
    75ba:	21 a1       	ldd	r18, Z+33	; 0x21
    75bc:	32 a1       	ldd	r19, Z+34	; 0x22
    75be:	43 a1       	ldd	r20, Z+35	; 0x23
    75c0:	54 a1       	ldd	r21, Z+36	; 0x24
    75c2:	8e 81       	ldd	r24, Y+6	; 0x06
    75c4:	9f 81       	ldd	r25, Y+7	; 0x07
    75c6:	a8 85       	ldd	r26, Y+8	; 0x08
    75c8:	b9 85       	ldd	r27, Y+9	; 0x09
    75ca:	80 95       	com	r24
    75cc:	90 95       	com	r25
    75ce:	a0 95       	com	r26
    75d0:	b0 95       	com	r27
    75d2:	82 23       	and	r24, r18
    75d4:	93 23       	and	r25, r19
    75d6:	a4 23       	and	r26, r20
    75d8:	b5 23       	and	r27, r21
    75da:	81 a3       	std	Z+33, r24	; 0x21
    75dc:	92 a3       	std	Z+34, r25	; 0x22
    75de:	a3 a3       	std	Z+35, r26	; 0x23
    75e0:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    75e2:	81 e0       	ldi	r24, 0x01	; 1
    75e4:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    75e6:	e0 91 94 05 	lds	r30, 0x0594
    75ea:	f0 91 95 05 	lds	r31, 0x0595
    75ee:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    75f0:	0f 90       	pop	r0
    75f2:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    75f4:	89 81       	ldd	r24, Y+1	; 0x01
	}
    75f6:	2d 96       	adiw	r28, 0x0d	; 13
    75f8:	0f b6       	in	r0, 0x3f	; 63
    75fa:	f8 94       	cli
    75fc:	de bf       	out	0x3e, r29	; 62
    75fe:	0f be       	out	0x3f, r0	; 63
    7600:	cd bf       	out	0x3d, r28	; 61
    7602:	cf 91       	pop	r28
    7604:	df 91       	pop	r29
    7606:	1f 91       	pop	r17
    7608:	0f 91       	pop	r16
    760a:	ff 90       	pop	r15
    760c:	ef 90       	pop	r14
    760e:	08 95       	ret

00007610 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    7610:	0f 93       	push	r16
    7612:	1f 93       	push	r17
    7614:	df 93       	push	r29
    7616:	cf 93       	push	r28
    7618:	cd b7       	in	r28, 0x3d	; 61
    761a:	de b7       	in	r29, 0x3e	; 62
    761c:	2f 97       	sbiw	r28, 0x0f	; 15
    761e:	0f b6       	in	r0, 0x3f	; 63
    7620:	f8 94       	cli
    7622:	de bf       	out	0x3e, r29	; 62
    7624:	0f be       	out	0x3f, r0	; 63
    7626:	cd bf       	out	0x3d, r28	; 61
    7628:	9e 83       	std	Y+6, r25	; 0x06
    762a:	8d 83       	std	Y+5, r24	; 0x05
    762c:	4f 83       	std	Y+7, r20	; 0x07
    762e:	58 87       	std	Y+8, r21	; 0x08
    7630:	69 87       	std	Y+9, r22	; 0x09
    7632:	7a 87       	std	Y+10, r23	; 0x0a
    7634:	2b 87       	std	Y+11, r18	; 0x0b
    7636:	1d 87       	std	Y+13, r17	; 0x0d
    7638:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    763a:	81 e0       	ldi	r24, 0x01	; 1
    763c:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    763e:	8d 81       	ldd	r24, Y+5	; 0x05
    7640:	9e 81       	ldd	r25, Y+6	; 0x06
    7642:	9c 83       	std	Y+4, r25	; 0x04
    7644:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    7646:	0f b6       	in	r0, 0x3f	; 63
    7648:	f8 94       	cli
    764a:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    764c:	8c 85       	ldd	r24, Y+12	; 0x0c
    764e:	9d 85       	ldd	r25, Y+13	; 0x0d
    7650:	00 97       	sbiw	r24, 0x00	; 0
    7652:	61 f0       	breq	.+24     	; 0x766c <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    7654:	eb 81       	ldd	r30, Y+3	; 0x03
    7656:	fc 81       	ldd	r31, Y+4	; 0x04
    7658:	81 a1       	ldd	r24, Z+33	; 0x21
    765a:	92 a1       	ldd	r25, Z+34	; 0x22
    765c:	a3 a1       	ldd	r26, Z+35	; 0x23
    765e:	b4 a1       	ldd	r27, Z+36	; 0x24
    7660:	ec 85       	ldd	r30, Y+12	; 0x0c
    7662:	fd 85       	ldd	r31, Y+13	; 0x0d
    7664:	80 83       	st	Z, r24
    7666:	91 83       	std	Z+1, r25	; 0x01
    7668:	a2 83       	std	Z+2, r26	; 0x02
    766a:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    766c:	eb 81       	ldd	r30, Y+3	; 0x03
    766e:	fc 81       	ldd	r31, Y+4	; 0x04
    7670:	85 a1       	ldd	r24, Z+37	; 0x25
    7672:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    7674:	eb 81       	ldd	r30, Y+3	; 0x03
    7676:	fc 81       	ldd	r31, Y+4	; 0x04
    7678:	82 e0       	ldi	r24, 0x02	; 2
    767a:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    767c:	8b 85       	ldd	r24, Y+11	; 0x0b
    767e:	28 2f       	mov	r18, r24
    7680:	30 e0       	ldi	r19, 0x00	; 0
    7682:	3f 87       	std	Y+15, r19	; 0x0f
    7684:	2e 87       	std	Y+14, r18	; 0x0e
    7686:	8e 85       	ldd	r24, Y+14	; 0x0e
    7688:	9f 85       	ldd	r25, Y+15	; 0x0f
    768a:	82 30       	cpi	r24, 0x02	; 2
    768c:	91 05       	cpc	r25, r1
    768e:	59 f1       	breq	.+86     	; 0x76e6 <xTaskGenericNotify+0xd6>
    7690:	2e 85       	ldd	r18, Y+14	; 0x0e
    7692:	3f 85       	ldd	r19, Y+15	; 0x0f
    7694:	23 30       	cpi	r18, 0x03	; 3
    7696:	31 05       	cpc	r19, r1
    7698:	34 f4       	brge	.+12     	; 0x76a6 <xTaskGenericNotify+0x96>
    769a:	8e 85       	ldd	r24, Y+14	; 0x0e
    769c:	9f 85       	ldd	r25, Y+15	; 0x0f
    769e:	81 30       	cpi	r24, 0x01	; 1
    76a0:	91 05       	cpc	r25, r1
    76a2:	61 f0       	breq	.+24     	; 0x76bc <xTaskGenericNotify+0xac>
    76a4:	4a c0       	rjmp	.+148    	; 0x773a <xTaskGenericNotify+0x12a>
    76a6:	2e 85       	ldd	r18, Y+14	; 0x0e
    76a8:	3f 85       	ldd	r19, Y+15	; 0x0f
    76aa:	23 30       	cpi	r18, 0x03	; 3
    76ac:	31 05       	cpc	r19, r1
    76ae:	59 f1       	breq	.+86     	; 0x7706 <xTaskGenericNotify+0xf6>
    76b0:	8e 85       	ldd	r24, Y+14	; 0x0e
    76b2:	9f 85       	ldd	r25, Y+15	; 0x0f
    76b4:	84 30       	cpi	r24, 0x04	; 4
    76b6:	91 05       	cpc	r25, r1
    76b8:	89 f1       	breq	.+98     	; 0x771c <xTaskGenericNotify+0x10c>
    76ba:	3f c0       	rjmp	.+126    	; 0x773a <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    76bc:	eb 81       	ldd	r30, Y+3	; 0x03
    76be:	fc 81       	ldd	r31, Y+4	; 0x04
    76c0:	21 a1       	ldd	r18, Z+33	; 0x21
    76c2:	32 a1       	ldd	r19, Z+34	; 0x22
    76c4:	43 a1       	ldd	r20, Z+35	; 0x23
    76c6:	54 a1       	ldd	r21, Z+36	; 0x24
    76c8:	8f 81       	ldd	r24, Y+7	; 0x07
    76ca:	98 85       	ldd	r25, Y+8	; 0x08
    76cc:	a9 85       	ldd	r26, Y+9	; 0x09
    76ce:	ba 85       	ldd	r27, Y+10	; 0x0a
    76d0:	82 2b       	or	r24, r18
    76d2:	93 2b       	or	r25, r19
    76d4:	a4 2b       	or	r26, r20
    76d6:	b5 2b       	or	r27, r21
    76d8:	eb 81       	ldd	r30, Y+3	; 0x03
    76da:	fc 81       	ldd	r31, Y+4	; 0x04
    76dc:	81 a3       	std	Z+33, r24	; 0x21
    76de:	92 a3       	std	Z+34, r25	; 0x22
    76e0:	a3 a3       	std	Z+35, r26	; 0x23
    76e2:	b4 a3       	std	Z+36, r27	; 0x24
    76e4:	2a c0       	rjmp	.+84     	; 0x773a <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    76e6:	eb 81       	ldd	r30, Y+3	; 0x03
    76e8:	fc 81       	ldd	r31, Y+4	; 0x04
    76ea:	81 a1       	ldd	r24, Z+33	; 0x21
    76ec:	92 a1       	ldd	r25, Z+34	; 0x22
    76ee:	a3 a1       	ldd	r26, Z+35	; 0x23
    76f0:	b4 a1       	ldd	r27, Z+36	; 0x24
    76f2:	01 96       	adiw	r24, 0x01	; 1
    76f4:	a1 1d       	adc	r26, r1
    76f6:	b1 1d       	adc	r27, r1
    76f8:	eb 81       	ldd	r30, Y+3	; 0x03
    76fa:	fc 81       	ldd	r31, Y+4	; 0x04
    76fc:	81 a3       	std	Z+33, r24	; 0x21
    76fe:	92 a3       	std	Z+34, r25	; 0x22
    7700:	a3 a3       	std	Z+35, r26	; 0x23
    7702:	b4 a3       	std	Z+36, r27	; 0x24
    7704:	1a c0       	rjmp	.+52     	; 0x773a <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    7706:	eb 81       	ldd	r30, Y+3	; 0x03
    7708:	fc 81       	ldd	r31, Y+4	; 0x04
    770a:	8f 81       	ldd	r24, Y+7	; 0x07
    770c:	98 85       	ldd	r25, Y+8	; 0x08
    770e:	a9 85       	ldd	r26, Y+9	; 0x09
    7710:	ba 85       	ldd	r27, Y+10	; 0x0a
    7712:	81 a3       	std	Z+33, r24	; 0x21
    7714:	92 a3       	std	Z+34, r25	; 0x22
    7716:	a3 a3       	std	Z+35, r26	; 0x23
    7718:	b4 a3       	std	Z+36, r27	; 0x24
    771a:	0f c0       	rjmp	.+30     	; 0x773a <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    771c:	89 81       	ldd	r24, Y+1	; 0x01
    771e:	82 30       	cpi	r24, 0x02	; 2
    7720:	59 f0       	breq	.+22     	; 0x7738 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    7722:	eb 81       	ldd	r30, Y+3	; 0x03
    7724:	fc 81       	ldd	r31, Y+4	; 0x04
    7726:	8f 81       	ldd	r24, Y+7	; 0x07
    7728:	98 85       	ldd	r25, Y+8	; 0x08
    772a:	a9 85       	ldd	r26, Y+9	; 0x09
    772c:	ba 85       	ldd	r27, Y+10	; 0x0a
    772e:	81 a3       	std	Z+33, r24	; 0x21
    7730:	92 a3       	std	Z+34, r25	; 0x22
    7732:	a3 a3       	std	Z+35, r26	; 0x23
    7734:	b4 a3       	std	Z+36, r27	; 0x24
    7736:	01 c0       	rjmp	.+2      	; 0x773a <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    7738:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    773a:	89 81       	ldd	r24, Y+1	; 0x01
    773c:	81 30       	cpi	r24, 0x01	; 1
    773e:	b9 f5       	brne	.+110    	; 0x77ae <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    7740:	8b 81       	ldd	r24, Y+3	; 0x03
    7742:	9c 81       	ldd	r25, Y+4	; 0x04
    7744:	02 96       	adiw	r24, 0x02	; 2
    7746:	0e 94 24 27 	call	0x4e48	; 0x4e48 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    774a:	eb 81       	ldd	r30, Y+3	; 0x03
    774c:	fc 81       	ldd	r31, Y+4	; 0x04
    774e:	96 89       	ldd	r25, Z+22	; 0x16
    7750:	80 91 9a 05 	lds	r24, 0x059A
    7754:	89 17       	cp	r24, r25
    7756:	28 f4       	brcc	.+10     	; 0x7762 <xTaskGenericNotify+0x152>
    7758:	eb 81       	ldd	r30, Y+3	; 0x03
    775a:	fc 81       	ldd	r31, Y+4	; 0x04
    775c:	86 89       	ldd	r24, Z+22	; 0x16
    775e:	80 93 9a 05 	sts	0x059A, r24
    7762:	eb 81       	ldd	r30, Y+3	; 0x03
    7764:	fc 81       	ldd	r31, Y+4	; 0x04
    7766:	86 89       	ldd	r24, Z+22	; 0x16
    7768:	28 2f       	mov	r18, r24
    776a:	30 e0       	ldi	r19, 0x00	; 0
    776c:	c9 01       	movw	r24, r18
    776e:	88 0f       	add	r24, r24
    7770:	99 1f       	adc	r25, r25
    7772:	88 0f       	add	r24, r24
    7774:	99 1f       	adc	r25, r25
    7776:	88 0f       	add	r24, r24
    7778:	99 1f       	adc	r25, r25
    777a:	82 0f       	add	r24, r18
    777c:	93 1f       	adc	r25, r19
    777e:	ac 01       	movw	r20, r24
    7780:	4b 55       	subi	r20, 0x5B	; 91
    7782:	5a 4f       	sbci	r21, 0xFA	; 250
    7784:	8b 81       	ldd	r24, Y+3	; 0x03
    7786:	9c 81       	ldd	r25, Y+4	; 0x04
    7788:	9c 01       	movw	r18, r24
    778a:	2e 5f       	subi	r18, 0xFE	; 254
    778c:	3f 4f       	sbci	r19, 0xFF	; 255
    778e:	ca 01       	movw	r24, r20
    7790:	b9 01       	movw	r22, r18
    7792:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    7796:	eb 81       	ldd	r30, Y+3	; 0x03
    7798:	fc 81       	ldd	r31, Y+4	; 0x04
    779a:	96 89       	ldd	r25, Z+22	; 0x16
    779c:	e0 91 94 05 	lds	r30, 0x0594
    77a0:	f0 91 95 05 	lds	r31, 0x0595
    77a4:	86 89       	ldd	r24, Z+22	; 0x16
    77a6:	89 17       	cp	r24, r25
    77a8:	10 f4       	brcc	.+4      	; 0x77ae <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    77aa:	0e 94 c4 29 	call	0x5388	; 0x5388 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    77ae:	0f 90       	pop	r0
    77b0:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    77b2:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    77b4:	2f 96       	adiw	r28, 0x0f	; 15
    77b6:	0f b6       	in	r0, 0x3f	; 63
    77b8:	f8 94       	cli
    77ba:	de bf       	out	0x3e, r29	; 62
    77bc:	0f be       	out	0x3f, r0	; 63
    77be:	cd bf       	out	0x3d, r28	; 61
    77c0:	cf 91       	pop	r28
    77c2:	df 91       	pop	r29
    77c4:	1f 91       	pop	r17
    77c6:	0f 91       	pop	r16
    77c8:	08 95       	ret

000077ca <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    77ca:	ef 92       	push	r14
    77cc:	ff 92       	push	r15
    77ce:	0f 93       	push	r16
    77d0:	1f 93       	push	r17
    77d2:	df 93       	push	r29
    77d4:	cf 93       	push	r28
    77d6:	cd b7       	in	r28, 0x3d	; 61
    77d8:	de b7       	in	r29, 0x3e	; 62
    77da:	62 97       	sbiw	r28, 0x12	; 18
    77dc:	0f b6       	in	r0, 0x3f	; 63
    77de:	f8 94       	cli
    77e0:	de bf       	out	0x3e, r29	; 62
    77e2:	0f be       	out	0x3f, r0	; 63
    77e4:	cd bf       	out	0x3d, r28	; 61
    77e6:	9f 83       	std	Y+7, r25	; 0x07
    77e8:	8e 83       	std	Y+6, r24	; 0x06
    77ea:	48 87       	std	Y+8, r20	; 0x08
    77ec:	59 87       	std	Y+9, r21	; 0x09
    77ee:	6a 87       	std	Y+10, r22	; 0x0a
    77f0:	7b 87       	std	Y+11, r23	; 0x0b
    77f2:	2c 87       	std	Y+12, r18	; 0x0c
    77f4:	1e 87       	std	Y+14, r17	; 0x0e
    77f6:	0d 87       	std	Y+13, r16	; 0x0d
    77f8:	f8 8a       	std	Y+16, r15	; 0x10
    77fa:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    77fc:	81 e0       	ldi	r24, 0x01	; 1
    77fe:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    7800:	8e 81       	ldd	r24, Y+6	; 0x06
    7802:	9f 81       	ldd	r25, Y+7	; 0x07
    7804:	9d 83       	std	Y+5, r25	; 0x05
    7806:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    7808:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    780a:	8d 85       	ldd	r24, Y+13	; 0x0d
    780c:	9e 85       	ldd	r25, Y+14	; 0x0e
    780e:	00 97       	sbiw	r24, 0x00	; 0
    7810:	61 f0       	breq	.+24     	; 0x782a <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    7812:	ec 81       	ldd	r30, Y+4	; 0x04
    7814:	fd 81       	ldd	r31, Y+5	; 0x05
    7816:	81 a1       	ldd	r24, Z+33	; 0x21
    7818:	92 a1       	ldd	r25, Z+34	; 0x22
    781a:	a3 a1       	ldd	r26, Z+35	; 0x23
    781c:	b4 a1       	ldd	r27, Z+36	; 0x24
    781e:	ed 85       	ldd	r30, Y+13	; 0x0d
    7820:	fe 85       	ldd	r31, Y+14	; 0x0e
    7822:	80 83       	st	Z, r24
    7824:	91 83       	std	Z+1, r25	; 0x01
    7826:	a2 83       	std	Z+2, r26	; 0x02
    7828:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    782a:	ec 81       	ldd	r30, Y+4	; 0x04
    782c:	fd 81       	ldd	r31, Y+5	; 0x05
    782e:	85 a1       	ldd	r24, Z+37	; 0x25
    7830:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    7832:	ec 81       	ldd	r30, Y+4	; 0x04
    7834:	fd 81       	ldd	r31, Y+5	; 0x05
    7836:	82 e0       	ldi	r24, 0x02	; 2
    7838:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    783a:	8c 85       	ldd	r24, Y+12	; 0x0c
    783c:	28 2f       	mov	r18, r24
    783e:	30 e0       	ldi	r19, 0x00	; 0
    7840:	3a 8b       	std	Y+18, r19	; 0x12
    7842:	29 8b       	std	Y+17, r18	; 0x11
    7844:	89 89       	ldd	r24, Y+17	; 0x11
    7846:	9a 89       	ldd	r25, Y+18	; 0x12
    7848:	82 30       	cpi	r24, 0x02	; 2
    784a:	91 05       	cpc	r25, r1
    784c:	59 f1       	breq	.+86     	; 0x78a4 <xTaskGenericNotifyFromISR+0xda>
    784e:	29 89       	ldd	r18, Y+17	; 0x11
    7850:	3a 89       	ldd	r19, Y+18	; 0x12
    7852:	23 30       	cpi	r18, 0x03	; 3
    7854:	31 05       	cpc	r19, r1
    7856:	34 f4       	brge	.+12     	; 0x7864 <xTaskGenericNotifyFromISR+0x9a>
    7858:	89 89       	ldd	r24, Y+17	; 0x11
    785a:	9a 89       	ldd	r25, Y+18	; 0x12
    785c:	81 30       	cpi	r24, 0x01	; 1
    785e:	91 05       	cpc	r25, r1
    7860:	61 f0       	breq	.+24     	; 0x787a <xTaskGenericNotifyFromISR+0xb0>
    7862:	4a c0       	rjmp	.+148    	; 0x78f8 <xTaskGenericNotifyFromISR+0x12e>
    7864:	29 89       	ldd	r18, Y+17	; 0x11
    7866:	3a 89       	ldd	r19, Y+18	; 0x12
    7868:	23 30       	cpi	r18, 0x03	; 3
    786a:	31 05       	cpc	r19, r1
    786c:	59 f1       	breq	.+86     	; 0x78c4 <xTaskGenericNotifyFromISR+0xfa>
    786e:	89 89       	ldd	r24, Y+17	; 0x11
    7870:	9a 89       	ldd	r25, Y+18	; 0x12
    7872:	84 30       	cpi	r24, 0x04	; 4
    7874:	91 05       	cpc	r25, r1
    7876:	89 f1       	breq	.+98     	; 0x78da <xTaskGenericNotifyFromISR+0x110>
    7878:	3f c0       	rjmp	.+126    	; 0x78f8 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    787a:	ec 81       	ldd	r30, Y+4	; 0x04
    787c:	fd 81       	ldd	r31, Y+5	; 0x05
    787e:	21 a1       	ldd	r18, Z+33	; 0x21
    7880:	32 a1       	ldd	r19, Z+34	; 0x22
    7882:	43 a1       	ldd	r20, Z+35	; 0x23
    7884:	54 a1       	ldd	r21, Z+36	; 0x24
    7886:	88 85       	ldd	r24, Y+8	; 0x08
    7888:	99 85       	ldd	r25, Y+9	; 0x09
    788a:	aa 85       	ldd	r26, Y+10	; 0x0a
    788c:	bb 85       	ldd	r27, Y+11	; 0x0b
    788e:	82 2b       	or	r24, r18
    7890:	93 2b       	or	r25, r19
    7892:	a4 2b       	or	r26, r20
    7894:	b5 2b       	or	r27, r21
    7896:	ec 81       	ldd	r30, Y+4	; 0x04
    7898:	fd 81       	ldd	r31, Y+5	; 0x05
    789a:	81 a3       	std	Z+33, r24	; 0x21
    789c:	92 a3       	std	Z+34, r25	; 0x22
    789e:	a3 a3       	std	Z+35, r26	; 0x23
    78a0:	b4 a3       	std	Z+36, r27	; 0x24
    78a2:	2a c0       	rjmp	.+84     	; 0x78f8 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    78a4:	ec 81       	ldd	r30, Y+4	; 0x04
    78a6:	fd 81       	ldd	r31, Y+5	; 0x05
    78a8:	81 a1       	ldd	r24, Z+33	; 0x21
    78aa:	92 a1       	ldd	r25, Z+34	; 0x22
    78ac:	a3 a1       	ldd	r26, Z+35	; 0x23
    78ae:	b4 a1       	ldd	r27, Z+36	; 0x24
    78b0:	01 96       	adiw	r24, 0x01	; 1
    78b2:	a1 1d       	adc	r26, r1
    78b4:	b1 1d       	adc	r27, r1
    78b6:	ec 81       	ldd	r30, Y+4	; 0x04
    78b8:	fd 81       	ldd	r31, Y+5	; 0x05
    78ba:	81 a3       	std	Z+33, r24	; 0x21
    78bc:	92 a3       	std	Z+34, r25	; 0x22
    78be:	a3 a3       	std	Z+35, r26	; 0x23
    78c0:	b4 a3       	std	Z+36, r27	; 0x24
    78c2:	1a c0       	rjmp	.+52     	; 0x78f8 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    78c4:	ec 81       	ldd	r30, Y+4	; 0x04
    78c6:	fd 81       	ldd	r31, Y+5	; 0x05
    78c8:	88 85       	ldd	r24, Y+8	; 0x08
    78ca:	99 85       	ldd	r25, Y+9	; 0x09
    78cc:	aa 85       	ldd	r26, Y+10	; 0x0a
    78ce:	bb 85       	ldd	r27, Y+11	; 0x0b
    78d0:	81 a3       	std	Z+33, r24	; 0x21
    78d2:	92 a3       	std	Z+34, r25	; 0x22
    78d4:	a3 a3       	std	Z+35, r26	; 0x23
    78d6:	b4 a3       	std	Z+36, r27	; 0x24
    78d8:	0f c0       	rjmp	.+30     	; 0x78f8 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    78da:	8b 81       	ldd	r24, Y+3	; 0x03
    78dc:	82 30       	cpi	r24, 0x02	; 2
    78de:	59 f0       	breq	.+22     	; 0x78f6 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    78e0:	ec 81       	ldd	r30, Y+4	; 0x04
    78e2:	fd 81       	ldd	r31, Y+5	; 0x05
    78e4:	88 85       	ldd	r24, Y+8	; 0x08
    78e6:	99 85       	ldd	r25, Y+9	; 0x09
    78e8:	aa 85       	ldd	r26, Y+10	; 0x0a
    78ea:	bb 85       	ldd	r27, Y+11	; 0x0b
    78ec:	81 a3       	std	Z+33, r24	; 0x21
    78ee:	92 a3       	std	Z+34, r25	; 0x22
    78f0:	a3 a3       	std	Z+35, r26	; 0x23
    78f2:	b4 a3       	std	Z+36, r27	; 0x24
    78f4:	01 c0       	rjmp	.+2      	; 0x78f8 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    78f6:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    78f8:	8b 81       	ldd	r24, Y+3	; 0x03
    78fa:	81 30       	cpi	r24, 0x01	; 1
    78fc:	09 f0       	breq	.+2      	; 0x7900 <xTaskGenericNotifyFromISR+0x136>
    78fe:	4f c0       	rjmp	.+158    	; 0x799e <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    7900:	80 91 a4 05 	lds	r24, 0x05A4
    7904:	88 23       	and	r24, r24
    7906:	61 f5       	brne	.+88     	; 0x7960 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    7908:	8c 81       	ldd	r24, Y+4	; 0x04
    790a:	9d 81       	ldd	r25, Y+5	; 0x05
    790c:	02 96       	adiw	r24, 0x02	; 2
    790e:	0e 94 24 27 	call	0x4e48	; 0x4e48 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    7912:	ec 81       	ldd	r30, Y+4	; 0x04
    7914:	fd 81       	ldd	r31, Y+5	; 0x05
    7916:	96 89       	ldd	r25, Z+22	; 0x16
    7918:	80 91 9a 05 	lds	r24, 0x059A
    791c:	89 17       	cp	r24, r25
    791e:	28 f4       	brcc	.+10     	; 0x792a <xTaskGenericNotifyFromISR+0x160>
    7920:	ec 81       	ldd	r30, Y+4	; 0x04
    7922:	fd 81       	ldd	r31, Y+5	; 0x05
    7924:	86 89       	ldd	r24, Z+22	; 0x16
    7926:	80 93 9a 05 	sts	0x059A, r24
    792a:	ec 81       	ldd	r30, Y+4	; 0x04
    792c:	fd 81       	ldd	r31, Y+5	; 0x05
    792e:	86 89       	ldd	r24, Z+22	; 0x16
    7930:	28 2f       	mov	r18, r24
    7932:	30 e0       	ldi	r19, 0x00	; 0
    7934:	c9 01       	movw	r24, r18
    7936:	88 0f       	add	r24, r24
    7938:	99 1f       	adc	r25, r25
    793a:	88 0f       	add	r24, r24
    793c:	99 1f       	adc	r25, r25
    793e:	88 0f       	add	r24, r24
    7940:	99 1f       	adc	r25, r25
    7942:	82 0f       	add	r24, r18
    7944:	93 1f       	adc	r25, r19
    7946:	ac 01       	movw	r20, r24
    7948:	4b 55       	subi	r20, 0x5B	; 91
    794a:	5a 4f       	sbci	r21, 0xFA	; 250
    794c:	8c 81       	ldd	r24, Y+4	; 0x04
    794e:	9d 81       	ldd	r25, Y+5	; 0x05
    7950:	9c 01       	movw	r18, r24
    7952:	2e 5f       	subi	r18, 0xFE	; 254
    7954:	3f 4f       	sbci	r19, 0xFF	; 255
    7956:	ca 01       	movw	r24, r20
    7958:	b9 01       	movw	r22, r18
    795a:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <vListInsertEnd>
    795e:	0a c0       	rjmp	.+20     	; 0x7974 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    7960:	8c 81       	ldd	r24, Y+4	; 0x04
    7962:	9d 81       	ldd	r25, Y+5	; 0x05
    7964:	9c 01       	movw	r18, r24
    7966:	24 5f       	subi	r18, 0xF4	; 244
    7968:	3f 4f       	sbci	r19, 0xFF	; 255
    796a:	8f ed       	ldi	r24, 0xDF	; 223
    796c:	95 e0       	ldi	r25, 0x05	; 5
    796e:	b9 01       	movw	r22, r18
    7970:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    7974:	ec 81       	ldd	r30, Y+4	; 0x04
    7976:	fd 81       	ldd	r31, Y+5	; 0x05
    7978:	96 89       	ldd	r25, Z+22	; 0x16
    797a:	e0 91 94 05 	lds	r30, 0x0594
    797e:	f0 91 95 05 	lds	r31, 0x0595
    7982:	86 89       	ldd	r24, Z+22	; 0x16
    7984:	89 17       	cp	r24, r25
    7986:	58 f4       	brcc	.+22     	; 0x799e <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    7988:	8f 85       	ldd	r24, Y+15	; 0x0f
    798a:	98 89       	ldd	r25, Y+16	; 0x10
    798c:	00 97       	sbiw	r24, 0x00	; 0
    798e:	21 f0       	breq	.+8      	; 0x7998 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    7990:	ef 85       	ldd	r30, Y+15	; 0x0f
    7992:	f8 89       	ldd	r31, Y+16	; 0x10
    7994:	81 e0       	ldi	r24, 0x01	; 1
    7996:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    7998:	81 e0       	ldi	r24, 0x01	; 1
    799a:	80 93 9d 05 	sts	0x059D, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    799e:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    79a0:	62 96       	adiw	r28, 0x12	; 18
    79a2:	0f b6       	in	r0, 0x3f	; 63
    79a4:	f8 94       	cli
    79a6:	de bf       	out	0x3e, r29	; 62
    79a8:	0f be       	out	0x3f, r0	; 63
    79aa:	cd bf       	out	0x3d, r28	; 61
    79ac:	cf 91       	pop	r28
    79ae:	df 91       	pop	r29
    79b0:	1f 91       	pop	r17
    79b2:	0f 91       	pop	r16
    79b4:	ff 90       	pop	r15
    79b6:	ef 90       	pop	r14
    79b8:	08 95       	ret

000079ba <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    79ba:	df 93       	push	r29
    79bc:	cf 93       	push	r28
    79be:	cd b7       	in	r28, 0x3d	; 61
    79c0:	de b7       	in	r29, 0x3e	; 62
    79c2:	28 97       	sbiw	r28, 0x08	; 8
    79c4:	0f b6       	in	r0, 0x3f	; 63
    79c6:	f8 94       	cli
    79c8:	de bf       	out	0x3e, r29	; 62
    79ca:	0f be       	out	0x3f, r0	; 63
    79cc:	cd bf       	out	0x3d, r28	; 61
    79ce:	9e 83       	std	Y+6, r25	; 0x06
    79d0:	8d 83       	std	Y+5, r24	; 0x05
    79d2:	78 87       	std	Y+8, r23	; 0x08
    79d4:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    79d6:	8d 81       	ldd	r24, Y+5	; 0x05
    79d8:	9e 81       	ldd	r25, Y+6	; 0x06
    79da:	9c 83       	std	Y+4, r25	; 0x04
    79dc:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    79de:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    79e0:	eb 81       	ldd	r30, Y+3	; 0x03
    79e2:	fc 81       	ldd	r31, Y+4	; 0x04
    79e4:	85 a1       	ldd	r24, Z+37	; 0x25
    79e6:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    79e8:	eb 81       	ldd	r30, Y+3	; 0x03
    79ea:	fc 81       	ldd	r31, Y+4	; 0x04
    79ec:	82 e0       	ldi	r24, 0x02	; 2
    79ee:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    79f0:	eb 81       	ldd	r30, Y+3	; 0x03
    79f2:	fc 81       	ldd	r31, Y+4	; 0x04
    79f4:	81 a1       	ldd	r24, Z+33	; 0x21
    79f6:	92 a1       	ldd	r25, Z+34	; 0x22
    79f8:	a3 a1       	ldd	r26, Z+35	; 0x23
    79fa:	b4 a1       	ldd	r27, Z+36	; 0x24
    79fc:	01 96       	adiw	r24, 0x01	; 1
    79fe:	a1 1d       	adc	r26, r1
    7a00:	b1 1d       	adc	r27, r1
    7a02:	eb 81       	ldd	r30, Y+3	; 0x03
    7a04:	fc 81       	ldd	r31, Y+4	; 0x04
    7a06:	81 a3       	std	Z+33, r24	; 0x21
    7a08:	92 a3       	std	Z+34, r25	; 0x22
    7a0a:	a3 a3       	std	Z+35, r26	; 0x23
    7a0c:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    7a0e:	8a 81       	ldd	r24, Y+2	; 0x02
    7a10:	81 30       	cpi	r24, 0x01	; 1
    7a12:	09 f0       	breq	.+2      	; 0x7a16 <vTaskNotifyGiveFromISR+0x5c>
    7a14:	4f c0       	rjmp	.+158    	; 0x7ab4 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    7a16:	80 91 a4 05 	lds	r24, 0x05A4
    7a1a:	88 23       	and	r24, r24
    7a1c:	61 f5       	brne	.+88     	; 0x7a76 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    7a1e:	8b 81       	ldd	r24, Y+3	; 0x03
    7a20:	9c 81       	ldd	r25, Y+4	; 0x04
    7a22:	02 96       	adiw	r24, 0x02	; 2
    7a24:	0e 94 24 27 	call	0x4e48	; 0x4e48 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    7a28:	eb 81       	ldd	r30, Y+3	; 0x03
    7a2a:	fc 81       	ldd	r31, Y+4	; 0x04
    7a2c:	96 89       	ldd	r25, Z+22	; 0x16
    7a2e:	80 91 9a 05 	lds	r24, 0x059A
    7a32:	89 17       	cp	r24, r25
    7a34:	28 f4       	brcc	.+10     	; 0x7a40 <vTaskNotifyGiveFromISR+0x86>
    7a36:	eb 81       	ldd	r30, Y+3	; 0x03
    7a38:	fc 81       	ldd	r31, Y+4	; 0x04
    7a3a:	86 89       	ldd	r24, Z+22	; 0x16
    7a3c:	80 93 9a 05 	sts	0x059A, r24
    7a40:	eb 81       	ldd	r30, Y+3	; 0x03
    7a42:	fc 81       	ldd	r31, Y+4	; 0x04
    7a44:	86 89       	ldd	r24, Z+22	; 0x16
    7a46:	28 2f       	mov	r18, r24
    7a48:	30 e0       	ldi	r19, 0x00	; 0
    7a4a:	c9 01       	movw	r24, r18
    7a4c:	88 0f       	add	r24, r24
    7a4e:	99 1f       	adc	r25, r25
    7a50:	88 0f       	add	r24, r24
    7a52:	99 1f       	adc	r25, r25
    7a54:	88 0f       	add	r24, r24
    7a56:	99 1f       	adc	r25, r25
    7a58:	82 0f       	add	r24, r18
    7a5a:	93 1f       	adc	r25, r19
    7a5c:	ac 01       	movw	r20, r24
    7a5e:	4b 55       	subi	r20, 0x5B	; 91
    7a60:	5a 4f       	sbci	r21, 0xFA	; 250
    7a62:	8b 81       	ldd	r24, Y+3	; 0x03
    7a64:	9c 81       	ldd	r25, Y+4	; 0x04
    7a66:	9c 01       	movw	r18, r24
    7a68:	2e 5f       	subi	r18, 0xFE	; 254
    7a6a:	3f 4f       	sbci	r19, 0xFF	; 255
    7a6c:	ca 01       	movw	r24, r20
    7a6e:	b9 01       	movw	r22, r18
    7a70:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <vListInsertEnd>
    7a74:	0a c0       	rjmp	.+20     	; 0x7a8a <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    7a76:	8b 81       	ldd	r24, Y+3	; 0x03
    7a78:	9c 81       	ldd	r25, Y+4	; 0x04
    7a7a:	9c 01       	movw	r18, r24
    7a7c:	24 5f       	subi	r18, 0xF4	; 244
    7a7e:	3f 4f       	sbci	r19, 0xFF	; 255
    7a80:	8f ed       	ldi	r24, 0xDF	; 223
    7a82:	95 e0       	ldi	r25, 0x05	; 5
    7a84:	b9 01       	movw	r22, r18
    7a86:	0e 94 74 26 	call	0x4ce8	; 0x4ce8 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    7a8a:	eb 81       	ldd	r30, Y+3	; 0x03
    7a8c:	fc 81       	ldd	r31, Y+4	; 0x04
    7a8e:	96 89       	ldd	r25, Z+22	; 0x16
    7a90:	e0 91 94 05 	lds	r30, 0x0594
    7a94:	f0 91 95 05 	lds	r31, 0x0595
    7a98:	86 89       	ldd	r24, Z+22	; 0x16
    7a9a:	89 17       	cp	r24, r25
    7a9c:	58 f4       	brcc	.+22     	; 0x7ab4 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    7a9e:	8f 81       	ldd	r24, Y+7	; 0x07
    7aa0:	98 85       	ldd	r25, Y+8	; 0x08
    7aa2:	00 97       	sbiw	r24, 0x00	; 0
    7aa4:	21 f0       	breq	.+8      	; 0x7aae <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    7aa6:	ef 81       	ldd	r30, Y+7	; 0x07
    7aa8:	f8 85       	ldd	r31, Y+8	; 0x08
    7aaa:	81 e0       	ldi	r24, 0x01	; 1
    7aac:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    7aae:	81 e0       	ldi	r24, 0x01	; 1
    7ab0:	80 93 9d 05 	sts	0x059D, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    7ab4:	28 96       	adiw	r28, 0x08	; 8
    7ab6:	0f b6       	in	r0, 0x3f	; 63
    7ab8:	f8 94       	cli
    7aba:	de bf       	out	0x3e, r29	; 62
    7abc:	0f be       	out	0x3f, r0	; 63
    7abe:	cd bf       	out	0x3d, r28	; 61
    7ac0:	cf 91       	pop	r28
    7ac2:	df 91       	pop	r29
    7ac4:	08 95       	ret

00007ac6 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    7ac6:	df 93       	push	r29
    7ac8:	cf 93       	push	r28
    7aca:	cd b7       	in	r28, 0x3d	; 61
    7acc:	de b7       	in	r29, 0x3e	; 62
    7ace:	27 97       	sbiw	r28, 0x07	; 7
    7ad0:	0f b6       	in	r0, 0x3f	; 63
    7ad2:	f8 94       	cli
    7ad4:	de bf       	out	0x3e, r29	; 62
    7ad6:	0f be       	out	0x3f, r0	; 63
    7ad8:	cd bf       	out	0x3d, r28	; 61
    7ada:	9d 83       	std	Y+5, r25	; 0x05
    7adc:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    7ade:	8c 81       	ldd	r24, Y+4	; 0x04
    7ae0:	9d 81       	ldd	r25, Y+5	; 0x05
    7ae2:	00 97       	sbiw	r24, 0x00	; 0
    7ae4:	39 f4       	brne	.+14     	; 0x7af4 <xTaskNotifyStateClear+0x2e>
    7ae6:	80 91 94 05 	lds	r24, 0x0594
    7aea:	90 91 95 05 	lds	r25, 0x0595
    7aee:	9f 83       	std	Y+7, r25	; 0x07
    7af0:	8e 83       	std	Y+6, r24	; 0x06
    7af2:	04 c0       	rjmp	.+8      	; 0x7afc <xTaskNotifyStateClear+0x36>
    7af4:	8c 81       	ldd	r24, Y+4	; 0x04
    7af6:	9d 81       	ldd	r25, Y+5	; 0x05
    7af8:	9f 83       	std	Y+7, r25	; 0x07
    7afa:	8e 83       	std	Y+6, r24	; 0x06
    7afc:	8e 81       	ldd	r24, Y+6	; 0x06
    7afe:	9f 81       	ldd	r25, Y+7	; 0x07
    7b00:	9b 83       	std	Y+3, r25	; 0x03
    7b02:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    7b04:	0f b6       	in	r0, 0x3f	; 63
    7b06:	f8 94       	cli
    7b08:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    7b0a:	ea 81       	ldd	r30, Y+2	; 0x02
    7b0c:	fb 81       	ldd	r31, Y+3	; 0x03
    7b0e:	85 a1       	ldd	r24, Z+37	; 0x25
    7b10:	82 30       	cpi	r24, 0x02	; 2
    7b12:	31 f4       	brne	.+12     	; 0x7b20 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    7b14:	ea 81       	ldd	r30, Y+2	; 0x02
    7b16:	fb 81       	ldd	r31, Y+3	; 0x03
    7b18:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    7b1a:	81 e0       	ldi	r24, 0x01	; 1
    7b1c:	89 83       	std	Y+1, r24	; 0x01
    7b1e:	01 c0       	rjmp	.+2      	; 0x7b22 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    7b20:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    7b22:	0f 90       	pop	r0
    7b24:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    7b26:	89 81       	ldd	r24, Y+1	; 0x01
	}
    7b28:	27 96       	adiw	r28, 0x07	; 7
    7b2a:	0f b6       	in	r0, 0x3f	; 63
    7b2c:	f8 94       	cli
    7b2e:	de bf       	out	0x3e, r29	; 62
    7b30:	0f be       	out	0x3f, r0	; 63
    7b32:	cd bf       	out	0x3d, r28	; 61
    7b34:	cf 91       	pop	r28
    7b36:	df 91       	pop	r29
    7b38:	08 95       	ret

00007b3a <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    7b3a:	df 93       	push	r29
    7b3c:	cf 93       	push	r28
    7b3e:	cd b7       	in	r28, 0x3d	; 61
    7b40:	de b7       	in	r29, 0x3e	; 62
    7b42:	27 97       	sbiw	r28, 0x07	; 7
    7b44:	0f b6       	in	r0, 0x3f	; 63
    7b46:	f8 94       	cli
    7b48:	de bf       	out	0x3e, r29	; 62
    7b4a:	0f be       	out	0x3f, r0	; 63
    7b4c:	cd bf       	out	0x3d, r28	; 61
    7b4e:	9e 83       	std	Y+6, r25	; 0x06
    7b50:	8d 83       	std	Y+5, r24	; 0x05
    7b52:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    7b54:	80 91 98 05 	lds	r24, 0x0598
    7b58:	90 91 99 05 	lds	r25, 0x0599
    7b5c:	9a 83       	std	Y+2, r25	; 0x02
    7b5e:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    7b60:	80 91 94 05 	lds	r24, 0x0594
    7b64:	90 91 95 05 	lds	r25, 0x0595
    7b68:	02 96       	adiw	r24, 0x02	; 2
    7b6a:	0e 94 24 27 	call	0x4e48	; 0x4e48 <uxListRemove>
	#else /* INCLUDE_vTaskSuspend */
	{
		/* Calculate the time at which the task should be woken if the event
		does not occur.  This may overflow but this doesn't matter, the kernel
		will manage it correctly. */
		xTimeToWake = xConstTickCount + xTicksToWait;
    7b6e:	29 81       	ldd	r18, Y+1	; 0x01
    7b70:	3a 81       	ldd	r19, Y+2	; 0x02
    7b72:	8d 81       	ldd	r24, Y+5	; 0x05
    7b74:	9e 81       	ldd	r25, Y+6	; 0x06
    7b76:	82 0f       	add	r24, r18
    7b78:	93 1f       	adc	r25, r19
    7b7a:	9c 83       	std	Y+4, r25	; 0x04
    7b7c:	8b 83       	std	Y+3, r24	; 0x03

		/* The list item will be inserted in wake time order. */
		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    7b7e:	e0 91 94 05 	lds	r30, 0x0594
    7b82:	f0 91 95 05 	lds	r31, 0x0595
    7b86:	8b 81       	ldd	r24, Y+3	; 0x03
    7b88:	9c 81       	ldd	r25, Y+4	; 0x04
    7b8a:	93 83       	std	Z+3, r25	; 0x03
    7b8c:	82 83       	std	Z+2, r24	; 0x02

		if( xTimeToWake < xConstTickCount )
    7b8e:	2b 81       	ldd	r18, Y+3	; 0x03
    7b90:	3c 81       	ldd	r19, Y+4	; 0x04
    7b92:	89 81       	ldd	r24, Y+1	; 0x01
    7b94:	9a 81       	ldd	r25, Y+2	; 0x02
    7b96:	28 17       	cp	r18, r24
    7b98:	39 07       	cpc	r19, r25
    7b9a:	70 f4       	brcc	.+28     	; 0x7bb8 <prvAddCurrentTaskToDelayedList+0x7e>
		{
			/* Wake time has overflowed.  Place this item in the overflow list. */
			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    7b9c:	80 91 dd 05 	lds	r24, 0x05DD
    7ba0:	90 91 de 05 	lds	r25, 0x05DE
    7ba4:	20 91 94 05 	lds	r18, 0x0594
    7ba8:	30 91 95 05 	lds	r19, 0x0595
    7bac:	2e 5f       	subi	r18, 0xFE	; 254
    7bae:	3f 4f       	sbci	r19, 0xFF	; 255
    7bb0:	b9 01       	movw	r22, r18
    7bb2:	0e 94 b8 26 	call	0x4d70	; 0x4d70 <vListInsert>
    7bb6:	1e c0       	rjmp	.+60     	; 0x7bf4 <prvAddCurrentTaskToDelayedList+0xba>
		}
		else
		{
			/* The wake time has not overflowed, so the current block list is used. */
			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    7bb8:	40 91 db 05 	lds	r20, 0x05DB
    7bbc:	50 91 dc 05 	lds	r21, 0x05DC
    7bc0:	80 91 94 05 	lds	r24, 0x0594
    7bc4:	90 91 95 05 	lds	r25, 0x0595
    7bc8:	9c 01       	movw	r18, r24
    7bca:	2e 5f       	subi	r18, 0xFE	; 254
    7bcc:	3f 4f       	sbci	r19, 0xFF	; 255
    7bce:	ca 01       	movw	r24, r20
    7bd0:	b9 01       	movw	r22, r18
    7bd2:	0e 94 b8 26 	call	0x4d70	; 0x4d70 <vListInsert>

			/* If the task entering the blocked state was placed at the head of the
			list of blocked tasks then xNextTaskUnblockTime needs to be updated
			too. */
			if( xTimeToWake < xNextTaskUnblockTime )
    7bd6:	20 91 a0 05 	lds	r18, 0x05A0
    7bda:	30 91 a1 05 	lds	r19, 0x05A1
    7bde:	8b 81       	ldd	r24, Y+3	; 0x03
    7be0:	9c 81       	ldd	r25, Y+4	; 0x04
    7be2:	82 17       	cp	r24, r18
    7be4:	93 07       	cpc	r25, r19
    7be6:	30 f4       	brcc	.+12     	; 0x7bf4 <prvAddCurrentTaskToDelayedList+0xba>
			{
				xNextTaskUnblockTime = xTimeToWake;
    7be8:	8b 81       	ldd	r24, Y+3	; 0x03
    7bea:	9c 81       	ldd	r25, Y+4	; 0x04
    7bec:	90 93 a1 05 	sts	0x05A1, r25
    7bf0:	80 93 a0 05 	sts	0x05A0, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    7bf4:	27 96       	adiw	r28, 0x07	; 7
    7bf6:	0f b6       	in	r0, 0x3f	; 63
    7bf8:	f8 94       	cli
    7bfa:	de bf       	out	0x3e, r29	; 62
    7bfc:	0f be       	out	0x3f, r0	; 63
    7bfe:	cd bf       	out	0x3d, r28	; 61
    7c00:	cf 91       	pop	r28
    7c02:	df 91       	pop	r29
    7c04:	08 95       	ret

00007c06 <__mulsi3>:
    7c06:	62 9f       	mul	r22, r18
    7c08:	d0 01       	movw	r26, r0
    7c0a:	73 9f       	mul	r23, r19
    7c0c:	f0 01       	movw	r30, r0
    7c0e:	82 9f       	mul	r24, r18
    7c10:	e0 0d       	add	r30, r0
    7c12:	f1 1d       	adc	r31, r1
    7c14:	64 9f       	mul	r22, r20
    7c16:	e0 0d       	add	r30, r0
    7c18:	f1 1d       	adc	r31, r1
    7c1a:	92 9f       	mul	r25, r18
    7c1c:	f0 0d       	add	r31, r0
    7c1e:	83 9f       	mul	r24, r19
    7c20:	f0 0d       	add	r31, r0
    7c22:	74 9f       	mul	r23, r20
    7c24:	f0 0d       	add	r31, r0
    7c26:	65 9f       	mul	r22, r21
    7c28:	f0 0d       	add	r31, r0
    7c2a:	99 27       	eor	r25, r25
    7c2c:	72 9f       	mul	r23, r18
    7c2e:	b0 0d       	add	r27, r0
    7c30:	e1 1d       	adc	r30, r1
    7c32:	f9 1f       	adc	r31, r25
    7c34:	63 9f       	mul	r22, r19
    7c36:	b0 0d       	add	r27, r0
    7c38:	e1 1d       	adc	r30, r1
    7c3a:	f9 1f       	adc	r31, r25
    7c3c:	bd 01       	movw	r22, r26
    7c3e:	cf 01       	movw	r24, r30
    7c40:	11 24       	eor	r1, r1
    7c42:	08 95       	ret

00007c44 <__divmodsi4>:
    7c44:	97 fb       	bst	r25, 7
    7c46:	09 2e       	mov	r0, r25
    7c48:	05 26       	eor	r0, r21
    7c4a:	0e d0       	rcall	.+28     	; 0x7c68 <__divmodsi4_neg1>
    7c4c:	57 fd       	sbrc	r21, 7
    7c4e:	04 d0       	rcall	.+8      	; 0x7c58 <__divmodsi4_neg2>
    7c50:	14 d0       	rcall	.+40     	; 0x7c7a <__udivmodsi4>
    7c52:	0a d0       	rcall	.+20     	; 0x7c68 <__divmodsi4_neg1>
    7c54:	00 1c       	adc	r0, r0
    7c56:	38 f4       	brcc	.+14     	; 0x7c66 <__divmodsi4_exit>

00007c58 <__divmodsi4_neg2>:
    7c58:	50 95       	com	r21
    7c5a:	40 95       	com	r20
    7c5c:	30 95       	com	r19
    7c5e:	21 95       	neg	r18
    7c60:	3f 4f       	sbci	r19, 0xFF	; 255
    7c62:	4f 4f       	sbci	r20, 0xFF	; 255
    7c64:	5f 4f       	sbci	r21, 0xFF	; 255

00007c66 <__divmodsi4_exit>:
    7c66:	08 95       	ret

00007c68 <__divmodsi4_neg1>:
    7c68:	f6 f7       	brtc	.-4      	; 0x7c66 <__divmodsi4_exit>
    7c6a:	90 95       	com	r25
    7c6c:	80 95       	com	r24
    7c6e:	70 95       	com	r23
    7c70:	61 95       	neg	r22
    7c72:	7f 4f       	sbci	r23, 0xFF	; 255
    7c74:	8f 4f       	sbci	r24, 0xFF	; 255
    7c76:	9f 4f       	sbci	r25, 0xFF	; 255
    7c78:	08 95       	ret

00007c7a <__udivmodsi4>:
    7c7a:	a1 e2       	ldi	r26, 0x21	; 33
    7c7c:	1a 2e       	mov	r1, r26
    7c7e:	aa 1b       	sub	r26, r26
    7c80:	bb 1b       	sub	r27, r27
    7c82:	fd 01       	movw	r30, r26
    7c84:	0d c0       	rjmp	.+26     	; 0x7ca0 <__udivmodsi4_ep>

00007c86 <__udivmodsi4_loop>:
    7c86:	aa 1f       	adc	r26, r26
    7c88:	bb 1f       	adc	r27, r27
    7c8a:	ee 1f       	adc	r30, r30
    7c8c:	ff 1f       	adc	r31, r31
    7c8e:	a2 17       	cp	r26, r18
    7c90:	b3 07       	cpc	r27, r19
    7c92:	e4 07       	cpc	r30, r20
    7c94:	f5 07       	cpc	r31, r21
    7c96:	20 f0       	brcs	.+8      	; 0x7ca0 <__udivmodsi4_ep>
    7c98:	a2 1b       	sub	r26, r18
    7c9a:	b3 0b       	sbc	r27, r19
    7c9c:	e4 0b       	sbc	r30, r20
    7c9e:	f5 0b       	sbc	r31, r21

00007ca0 <__udivmodsi4_ep>:
    7ca0:	66 1f       	adc	r22, r22
    7ca2:	77 1f       	adc	r23, r23
    7ca4:	88 1f       	adc	r24, r24
    7ca6:	99 1f       	adc	r25, r25
    7ca8:	1a 94       	dec	r1
    7caa:	69 f7       	brne	.-38     	; 0x7c86 <__udivmodsi4_loop>
    7cac:	60 95       	com	r22
    7cae:	70 95       	com	r23
    7cb0:	80 95       	com	r24
    7cb2:	90 95       	com	r25
    7cb4:	9b 01       	movw	r18, r22
    7cb6:	ac 01       	movw	r20, r24
    7cb8:	bd 01       	movw	r22, r26
    7cba:	cf 01       	movw	r24, r30
    7cbc:	08 95       	ret

00007cbe <__prologue_saves__>:
    7cbe:	2f 92       	push	r2
    7cc0:	3f 92       	push	r3
    7cc2:	4f 92       	push	r4
    7cc4:	5f 92       	push	r5
    7cc6:	6f 92       	push	r6
    7cc8:	7f 92       	push	r7
    7cca:	8f 92       	push	r8
    7ccc:	9f 92       	push	r9
    7cce:	af 92       	push	r10
    7cd0:	bf 92       	push	r11
    7cd2:	cf 92       	push	r12
    7cd4:	df 92       	push	r13
    7cd6:	ef 92       	push	r14
    7cd8:	ff 92       	push	r15
    7cda:	0f 93       	push	r16
    7cdc:	1f 93       	push	r17
    7cde:	cf 93       	push	r28
    7ce0:	df 93       	push	r29
    7ce2:	cd b7       	in	r28, 0x3d	; 61
    7ce4:	de b7       	in	r29, 0x3e	; 62
    7ce6:	ca 1b       	sub	r28, r26
    7ce8:	db 0b       	sbc	r29, r27
    7cea:	0f b6       	in	r0, 0x3f	; 63
    7cec:	f8 94       	cli
    7cee:	de bf       	out	0x3e, r29	; 62
    7cf0:	0f be       	out	0x3f, r0	; 63
    7cf2:	cd bf       	out	0x3d, r28	; 61
    7cf4:	09 94       	ijmp

00007cf6 <__epilogue_restores__>:
    7cf6:	2a 88       	ldd	r2, Y+18	; 0x12
    7cf8:	39 88       	ldd	r3, Y+17	; 0x11
    7cfa:	48 88       	ldd	r4, Y+16	; 0x10
    7cfc:	5f 84       	ldd	r5, Y+15	; 0x0f
    7cfe:	6e 84       	ldd	r6, Y+14	; 0x0e
    7d00:	7d 84       	ldd	r7, Y+13	; 0x0d
    7d02:	8c 84       	ldd	r8, Y+12	; 0x0c
    7d04:	9b 84       	ldd	r9, Y+11	; 0x0b
    7d06:	aa 84       	ldd	r10, Y+10	; 0x0a
    7d08:	b9 84       	ldd	r11, Y+9	; 0x09
    7d0a:	c8 84       	ldd	r12, Y+8	; 0x08
    7d0c:	df 80       	ldd	r13, Y+7	; 0x07
    7d0e:	ee 80       	ldd	r14, Y+6	; 0x06
    7d10:	fd 80       	ldd	r15, Y+5	; 0x05
    7d12:	0c 81       	ldd	r16, Y+4	; 0x04
    7d14:	1b 81       	ldd	r17, Y+3	; 0x03
    7d16:	aa 81       	ldd	r26, Y+2	; 0x02
    7d18:	b9 81       	ldd	r27, Y+1	; 0x01
    7d1a:	ce 0f       	add	r28, r30
    7d1c:	d1 1d       	adc	r29, r1
    7d1e:	0f b6       	in	r0, 0x3f	; 63
    7d20:	f8 94       	cli
    7d22:	de bf       	out	0x3e, r29	; 62
    7d24:	0f be       	out	0x3f, r0	; 63
    7d26:	cd bf       	out	0x3d, r28	; 61
    7d28:	ed 01       	movw	r28, r26
    7d2a:	08 95       	ret

00007d2c <memcpy>:
    7d2c:	fb 01       	movw	r30, r22
    7d2e:	dc 01       	movw	r26, r24
    7d30:	02 c0       	rjmp	.+4      	; 0x7d36 <memcpy+0xa>
    7d32:	01 90       	ld	r0, Z+
    7d34:	0d 92       	st	X+, r0
    7d36:	41 50       	subi	r20, 0x01	; 1
    7d38:	50 40       	sbci	r21, 0x00	; 0
    7d3a:	d8 f7       	brcc	.-10     	; 0x7d32 <memcpy+0x6>
    7d3c:	08 95       	ret

00007d3e <_exit>:
    7d3e:	f8 94       	cli

00007d40 <__stop_program>:
    7d40:	ff cf       	rjmp	.-2      	; 0x7d40 <__stop_program>
